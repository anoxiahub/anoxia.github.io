<!-- build time: Sun Aug 20 2023 21:50:29 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://anoxiahub.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://anoxiahub.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://anoxiahub.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="JUC"><link rel="canonical" href="https://anoxiahub.github.io/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><title>多线程相关面试题 - 面经 | 智慧笔记 = = 欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">多线程相关面试题</h1><div class="meta"><span class="item" title="创建时间：2023-08-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-15T00:00:00+08:00">2023-08-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">智慧笔记</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.eRdTrmQxxb-t_gEdsGlA9AAAAA?pid=ImgDet&rs=1"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/interview/" itemprop="item" rel="index" title="分类于 面经"><span itemprop="name">面经</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anoxiahub.github.io/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="anoxia"><meta itemprop="description" content="欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸, anoxia的后端博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><blockquote><p>有关多线程内容可以看<a href="/java/JUC%E8%AF%A6%E8%A7%A3">JUC详解</a></p></blockquote><h3 id="面试官：聊一下并行和并发有什么区别？"><a href="#面试官：聊一下并行和并发有什么区别？" class="headerlink" title="面试官：聊一下并行和并发有什么区别？"></a>面试官：聊一下并行和并发有什么区别？</h3><blockquote><p><strong>候选人：</strong></p><p>是这样的~~</p><p>现在都是多核CPU，在多核CPU下</p><p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p><p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p></blockquote><h3 id="面试官：说一下线程和进程的区别？"><a href="#面试官：说一下线程和进程的区别？" class="headerlink" title="面试官：说一下线程和进程的区别？"></a>面试官：说一下线程和进程的区别？</h3><blockquote><p><strong>候选人：</strong></p><p>嗯，好~</p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li></ul></blockquote><h3 id="面试官：如果在java中创建线程有哪些方式？"><a href="#面试官：如果在java中创建线程有哪些方式？" class="headerlink" title="面试官：如果在java中创建线程有哪些方式？"></a>面试官：如果在java中创建线程有哪些方式？</h3><blockquote><p><strong>候选人：</strong></p><p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p></blockquote><h3 id="面试官：好的，刚才你说的runnable-和-callable-两个接口创建线程有什么不同呢？"><a href="#面试官：好的，刚才你说的runnable-和-callable-两个接口创建线程有什么不同呢？" class="headerlink" title="面试官：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？"></a>面试官：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</h3><blockquote><p><strong>候选人：</strong></p><p>是这样的~</p><p>最主要的两个线程一个是有返回值，一个是没有返回值的。</p><p>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p><p>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息</p><p>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用FutureTask.get()得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p></blockquote><h3 id="面试官：线程包括哪些状态，状态之间是如何变化的？"><a href="#面试官：线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="面试官：线程包括哪些状态，状态之间是如何变化的？"></a>面试官：线程包括哪些状态，状态之间是如何变化的？</h3><blockquote><p><strong>候选人：</strong></p><p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p><p>关于线程的状态切换情况比较多。我分别介绍一下</p><p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p><p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p><p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p><p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p></blockquote><h3 id="面试官：嗯，好的，刚才你说的线程中的-wait-和-sleep方法有什么不同呢？"><a href="#面试官：嗯，好的，刚才你说的线程中的-wait-和-sleep方法有什么不同呢？" class="headerlink" title="面试官：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？"></a>面试官：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？</h3><blockquote><p><strong>候选人：</strong></p><p>它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</p><p>不同点主要有三个方面：</p><p>第一：方法归属不同</p><p>sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有</p><p>第二：线程醒来时机不同</p><p>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去</p><p>第三：锁特性不同</p><p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</p><p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃 cpu，但你们还可以用）</p><p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）</p></blockquote><h3 id="面试官：好的，我现在举一个场景，你来分析一下怎么做，新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#面试官：好的，我现在举一个场景，你来分析一下怎么做，新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="面试官：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>面试官：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h3><blockquote><p><strong>候选人：</strong></p><p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p><p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>比如说：</p><p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p></blockquote><h3 id="面试官：在我们使用线程的过程中，有两个方法。线程的-run-和-start-有什么区别？"><a href="#面试官：在我们使用线程的过程中，有两个方法。线程的-run-和-start-有什么区别？" class="headerlink" title="面试官：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？"></a>面试官：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</h3><blockquote><p><strong>候选人：</strong></p><p>start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。</p></blockquote><h3 id="面试官：那如何停止一个正在运行的线程呢？"><a href="#面试官：那如何停止一个正在运行的线程呢？" class="headerlink" title="面试官：那如何停止一个正在运行的线程呢？"></a>面试官：那如何停止一个正在运行的线程呢？</h3><blockquote><p><strong>候选人</strong>：</p><p>有三种方式可以停止线程</p><p>第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记</p><p>第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废</p><p>第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程</p><p>我们项目中使用的话，建议使用第一种或第三种方式中断线程</p></blockquote><h3 id="面试官：讲一下synchronized关键字的底层原理？"><a href="#面试官：讲一下synchronized关键字的底层原理？" class="headerlink" title="面试官：讲一下synchronized关键字的底层原理？"></a>面试官：讲一下synchronized关键字的底层原理？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯~~好的，</p><p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p><p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p></blockquote><h3 id="面试官：好的，你能具体说下Monitor-吗？"><a href="#面试官：好的，你能具体说下Monitor-吗？" class="headerlink" title="面试官：好的，你能具体说下Monitor 吗？"></a>面试官：好的，你能具体说下Monitor 吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因</p><p>monitor内部维护了三个变量</p><ul><li><p>WaitSet：保存处于Waiting状态的线程</p></li><li><p>EntryList：保存处于Blocked状态的线程</p></li><li><p>Owner：持有锁的线程</p></li></ul><p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p><p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p></blockquote><h3 id="面试官：好的，那关于synchronized-的锁升级的情况了解吗？"><a href="#面试官：好的，那关于synchronized-的锁升级的情况了解吗？" class="headerlink" title="面试官：好的，那关于synchronized 的锁升级的情况了解吗？"></a>面试官：好的，那关于synchronized 的锁升级的情况了解吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，知道一些（要谦虚）</p><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p><p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p><p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p><p>一旦锁发生了竞争，都会升级为重量级锁</p></blockquote><h3 id="面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？"><a href="#面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？" class="headerlink" title="面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？"></a>面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，其实，在高并发下，我们可以采用ReentrantLock来加锁。</p></blockquote><h3 id="面试官：嗯，那你说下ReentrantLock的使用方式和底层原理？"><a href="#面试官：嗯，那你说下ReentrantLock的使用方式和底层原理？" class="headerlink" title="面试官：嗯，那你说下ReentrantLock的使用方式和底层原理？"></a>面试官：嗯，那你说下ReentrantLock的使用方式和底层原理？</h3><blockquote><p><strong>候选人</strong>：</p><p>好的，</p><p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p><p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p><p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p></blockquote><h3 id="面试官：好的，刚才你说了CAS和AQS，你能介绍一下吗？"><a href="#面试官：好的，刚才你说了CAS和AQS，你能介绍一下吗？" class="headerlink" title="面试官：好的，刚才你说了CAS和AQS，你能介绍一下吗？"></a>面试官：好的，刚才你说了CAS和AQS，你能介绍一下吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>好的。</p><p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p><ul><li><p>CAS使用到的地方很多：AQS框架、AtomicXXX类</p></li><li><p>在操作共享变量的时候使用的自旋锁，效率上更高一些</p></li><li><p>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</p></li></ul><p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p><p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p><p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p><ul><li><p>tail 指向队列最后一个元素</p></li><li><p>head 指向队列中最久的一个元素</p></li></ul><p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p></blockquote><h3 id="面试官：synchronized和Lock有什么区别"><a href="#面试官：synchronized和Lock有什么区别" class="headerlink" title="面试官：synchronized和Lock有什么区别 ?"></a>面试官：synchronized和Lock有什么区别 ?</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯~~，好的，主要有三个方面不太一样</p><p>第一，语法层面</p><ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li></ul><p>第二，功能层面</p><ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li></ul><p>第三，性能层面</p><ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul><p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p></blockquote><h3 id="面试官：死锁产生的条件是什么？"><a href="#面试官：死锁产生的条件是什么？" class="headerlink" title="面试官：死锁产生的条件是什么？"></a>面试官：死锁产生的条件是什么？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁</p><p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p></blockquote><h3 id="面试官：那如果产出了这样的，如何进行死锁诊断？"><a href="#面试官：那如果产出了这样的，如何进行死锁诊断？" class="headerlink" title="面试官：那如果产出了这样的，如何进行死锁诊断？"></a>面试官：那如果产出了这样的，如何进行死锁诊断？</h3><blockquote><p><strong>候选人</strong>：</p><p>这个也很容易，我们只需要通过jdk自动的工具就能搞定</p><p>我们可以先通过jps来查看当前java程序运行的进程id</p><p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p></blockquote><h3 id="面试官：请谈谈你对-volatile-的理解"><a href="#面试官：请谈谈你对-volatile-的理解" class="headerlink" title="面试官：请谈谈你对 volatile 的理解"></a>面试官：请谈谈你对 volatile 的理解</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯~~</p><p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p><p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p><p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化</p><p>–</p><p><strong>本文作者</strong>：接《集合相关面试题》</p></blockquote><h3 id="面试官：那你能聊一下ConcurrentHashMap的原理吗？"><a href="#面试官：那你能聊一下ConcurrentHashMap的原理吗？" class="headerlink" title="面试官：那你能聊一下ConcurrentHashMap的原理吗？"></a>面试官：那你能聊一下ConcurrentHashMap的原理吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯好的，</p><p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li></ul><p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p><p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p></blockquote><h3 id="面试官：线程池的种类有哪些？"><a href="#面试官：线程池的种类有哪些？" class="headerlink" title="面试官：线程池的种类有哪些？"></a>面试官：线程池的种类有哪些？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯！是这样</p><p>在jdk中默认提供了4中方式创建线程池</p><p>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。</p><p>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。</p><p>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p></blockquote><h3 id="面试官：线程池的核心参数有哪些？"><a href="#面试官：线程池的核心参数有哪些？" class="headerlink" title="面试官：线程池的核心参数有哪些？"></a>面试官：线程池的核心参数有哪些？</h3><blockquote><p><strong>候选人</strong>：</p><p>在线程池中一共有7个核心参数：</p><ol><li><p>corePoolSize 核心线程数目 - 池中会保留的最多线程数</p></li><li><p>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</p></li><li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p></li><li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p></li><li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p></li><li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p></li><li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p></li></ol><p>在拒绝策略中又有4中拒绝策略</p><p>当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p></blockquote><h3 id="面试官：如何确定核心线程池呢？"><a href="#面试官：如何确定核心线程池呢？" class="headerlink" title="面试官：如何确定核心线程池呢？"></a>面试官：如何确定核心线程池呢？</h3><blockquote><p><strong>候选人</strong>：</p><p>是这样的，我们公司当时有一些规范，为了减少线程上下文的切换，要根据当时部署的服务器的CPU核数来决定，我们规则是：CPU核数+1就是最终的核心线程数。</p></blockquote><h3 id="面试官：线程池的执行原理知道吗？"><a href="#面试官：线程池的执行原理知道吗？" class="headerlink" title="面试官：线程池的执行原理知道吗？"></a>面试官：线程池的执行原理知道吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯~，它是这样的</p><p>首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。</p></blockquote><h3 id="面试官：为什么不建议使用Executors创建线程池呢？"><a href="#面试官：为什么不建议使用Executors创建线程池呢？" class="headerlink" title="面试官：为什么不建议使用Executors创建线程池呢？"></a>面试官：为什么不建议使用Executors创建线程池呢？</h3><blockquote><p><strong>候选人</strong>：</p><p>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p><p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p><p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p></blockquote><h3 id="面试官：如果控制某一个方法允许并发访问线程的数量？"><a href="#面试官：如果控制某一个方法允许并发访问线程的数量？" class="headerlink" title="面试官：如果控制某一个方法允许并发访问线程的数量？"></a>面试官：如果控制某一个方法允许并发访问线程的数量？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯~~，我想一下</p><p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p><p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p><p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p></blockquote><h3 id="面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？"><a href="#面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？" class="headerlink" title="面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？"></a>面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：</p><ul><li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li><li>synchronized、volatile、LOCK，可以解决可见性问题</li><li>Happens-Before 规则可以解决有序性问题</li></ul><hr></blockquote><h3 id="面试官：你在项目中哪里用了多线程？"><a href="#面试官：你在项目中哪里用了多线程？" class="headerlink" title="面试官：你在项目中哪里用了多线程？"></a>面试官：你在项目中哪里用了多线程？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯~~，我想一下当时的场景[根据自己简历上的模块设计多线程场景]</p><p>参考场景一：</p><p>es数据批量导入</p><p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p><p>参考场景二：</p><p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p><p>参考场景三：</p><p>《黑马头条》项目中使用的</p><p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p></blockquote><h3 id="面试官：谈谈你对ThreadLocal的理解"><a href="#面试官：谈谈你对ThreadLocal的理解" class="headerlink" title="面试官：谈谈你对ThreadLocal的理解"></a>面试官：谈谈你对ThreadLocal的理解</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，是这样的~~</p><p>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享</p></blockquote><h3 id="面试官：好的，那你知道ThreadLocal的底层原理实现吗？"><a href="#面试官：好的，那你知道ThreadLocal的底层原理实现吗？" class="headerlink" title="面试官：好的，那你知道ThreadLocal的底层原理实现吗？"></a>面试官：好的，那你知道ThreadLocal的底层原理实现吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，知道一些~</p><p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p><p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p><p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p></blockquote><h3 id="面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？"><a href="#面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？" class="headerlink" title="面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？"></a>面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，我之前看过源码，我想一下~~</p><p>是应为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p><p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p></blockquote><ul><li>本文引自<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=">黑马程序员Java面试宝典</span></li></ul><div class="tags"><a href="/tags/JUC/" rel="tag"><i class="ic i-tag"></i> JUC</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-20 21:40:07" itemprop="dateModified" datetime="2023-08-20T21:40:07+08:00">2023-08-20</time> </span><span id="interview/多线程相关面试题/" class="item leancloud_visitors" data-flag-title="多线程相关面试题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/weipay.png" alt="anoxia 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="anoxia 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>anoxia <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://anoxiahub.github.io/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程相关面试题">https://anoxiahub.github.io/interview/多线程相关面试题/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tse4-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP-C.Sr86qaLTr6BwCzCmQNzU5AHaEJ?w&#x3D;268&amp;h&#x3D;180&amp;c&#x3D;7&amp;r&#x3D;0&amp;o&#x3D;5&amp;dpr&#x3D;1.3&amp;pid&#x3D;1.7" title="JVM相关面试题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 面经</span><h3>JVM相关面试题</h3></a></div><div class="item right"><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;static.mikechen.cc&#x2F;wp-content&#x2F;uploads&#x2F;2021&#x2F;03&#x2F;redis-interview.png" title="Redis专项题库-个人练习"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 专项练习</span><h3>Redis专项题库-个人练习</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%81%8A%E4%B8%80%E4%B8%8B%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">面试官：聊一下并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">面试官：说一下线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%9C%A8java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">面试官：如果在java中创建线程有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E7%9A%84runnable-%E5%92%8C-callable-%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">面试官：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">面试官：线程包括哪些状态，状态之间是如何变化的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%97%AF%EF%BC%8C%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84-wait-%E5%92%8C-sleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">面试官：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E6%88%91%E7%8E%B0%E5%9C%A8%E4%B8%BE%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%BD%A0%E6%9D%A5%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">面试官：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%9C%A8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E3%80%82%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">面试官：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E9%82%A3%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">面试官：那如何停止一个正在运行的线程呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">面试官：讲一下synchronized关键字的底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%8BMonitor-%E5%90%97%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">面试官：好的，你能具体说下Monitor 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E5%85%B3%E4%BA%8Esynchronized-%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">面试官：好的，那关于synchronized 的锁升级的情况了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E4%BA%86synchronized%E5%AE%83%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%80%A7%E8%83%BD%E4%B8%8D%E9%AB%98%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E4%BD%BF%E7%94%A8%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">面试官：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%97%AF%EF%BC%8C%E9%82%A3%E4%BD%A0%E8%AF%B4%E4%B8%8BReentrantLock%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">面试官：嗯，那你说下ReentrantLock的使用方式和底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E5%88%9A%E6%89%8D%E4%BD%A0%E8%AF%B4%E4%BA%86CAS%E5%92%8CAQS%EF%BC%8C%E4%BD%A0%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">面试官：好的，刚才你说了CAS和AQS，你能介绍一下吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9Asynchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">面试官：synchronized和Lock有什么区别 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">面试官：死锁产生的条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E9%82%A3%E5%A6%82%E6%9E%9C%E4%BA%A7%E5%87%BA%E4%BA%86%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%AD%BB%E9%94%81%E8%AF%8A%E6%96%AD%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">面试官：那如果产出了这样的，如何进行死锁诊断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-volatile-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">19.</span> <span class="toc-text">面试官：请谈谈你对 volatile 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E9%82%A3%E4%BD%A0%E8%83%BD%E8%81%8A%E4%B8%80%E4%B8%8BConcurrentHashMap%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">面试官：那你能聊一下ConcurrentHashMap的原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">面试官：线程池的种类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">面试官：线程池的核心参数有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%A2%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">面试官：如何确定核心线程池呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">面试官：线程池的执行原理知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%A2%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">面试官：为什么不建议使用Executors创建线程池呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">面试官：如果控制某一个方法允许并发访问线程的数量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Java%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">面试官：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">面试官：你在项目中哪里用了多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">29.</span> <span class="toc-text">面试官：谈谈你对ThreadLocal的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E4%BD%A0%E7%9F%A5%E9%81%93ThreadLocal%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">面试官：好的，那你知道ThreadLocal的底层原理实现吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A5%BD%E7%9A%84%EF%BC%8C%E9%82%A3%E5%85%B3%E4%BA%8EThreadLocal%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%BF%99%E4%B8%AA%E4%BA%8B%E6%83%85%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">面试官：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="Mysql相关面试题">Mysql相关面试题</a></li><li><a href="/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="Redis相关面试题">Redis相关面试题</a></li><li><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="Spring相关面试题">Spring相关面试题</a></li><li><a href="/interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="微服务相关面试题">微服务相关面试题</a></li><li><a href="/interview/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="消息中间件相关面试题">消息中间件相关面试题</a></li><li><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="Java集合相关面试题">Java集合相关面试题</a></li><li class="active"><a href="/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="多线程相关面试题">多线程相关面试题</a></li><li><a href="/interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="JVM相关面试题">JVM相关面试题</a></li><li><a href="/interview/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/" rel="bookmark" title="常见技术场景">常见技术场景</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="anoxia" data-src="/images/avatar.webp"><p class="name" itemprop="name">anoxia</p><div class="description" itemprop="description">anoxia的后端博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">17</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbjB5dWFu" title="https:&#x2F;&#x2F;github.com&#x2F;lin0yuan"><i class="ic i-github"></i></span> <a href="/3102691553@qq.com" title="3102691553@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/HTTP%E5%92%8CWebsocket%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="HTTP和Websocket的前世今生">HTTP和Websocket的前世今生</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/special/" title="分类于 专项练习">专项练习</a></div><span><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" title="Redis专项题库-个人练习">Redis专项题库-个人练习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题">Java集合相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="关于缓存读写一致问题">关于缓存读写一致问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="微服务相关面试题">微服务相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" title="项目常见问题">项目常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Redis相关面试题">Redis相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程相关面试题">多线程相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="消息中间件相关面试题">消息中间件相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Spring相关面试题">Spring相关面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">anoxia @ 智慧笔记</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">124k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:53</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"interview/多线程相关面试题/",favicon:{show:"智慧笔记",hide:"别走嘛QwQ"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->