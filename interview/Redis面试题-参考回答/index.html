<!-- build time: Thu Aug 24 2023 18:26:23 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://anoxiahub.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://anoxiahub.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://anoxiahub.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Redis"><link rel="canonical" href="https://anoxiahub.github.io/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/"><title>Redis相关面试题 - 面经 | 智慧笔记 = = 欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Redis相关面试题</h1><div class="meta"><span class="item" title="创建时间：2023-08-06 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-06T00:00:00+08:00">2023-08-06</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">智慧笔记</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/redis_interview.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/interview/" itemprop="item" rel="index" title="分类于 面经"><span itemprop="name">面经</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anoxiahub.github.io/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="anoxia"><meta itemprop="description" content="欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸, anoxia的后端博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h3 id="面试官什么是缓存穿透-怎么解决"><a class="anchor" href="#面试官什么是缓存穿透-怎么解决">#</a> 面试官：什么是缓存穿透？怎么解决？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯～～，我想一下</p><p>缓存穿透是指查询一个一定<strong>不存在</strong>的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。</p><p>解决方案的话，我们通常都会用布隆过滤器来解决它</p></blockquote><h3 id="面试官好的你能介绍一下布隆过滤器吗"><a class="anchor" href="#面试官好的你能介绍一下布隆过滤器吗">#</a> 面试官：好的，你能介绍一下布隆过滤器吗？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，是这样～</p><p>布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是 redisson 实现的布隆过滤器。</p><p>它的底层主要是先去初始化一个比较大数组，里面存放的二进制 0 或 1。在一开始都是 0，当一个 key 来了之后经过 3 次 hash 计算，模于数组长度找到数据的下标然后把数组中原来的 0 改为 1，这样的话，三个数组的位置就能标明一个 key 的存在。查找的过程也是一样的。</p><p>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过 5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5% 以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p></blockquote><h3 id="面试官什么是缓存击穿-怎么解决"><a class="anchor" href="#面试官什么是缓存击穿-怎么解决">#</a> 面试官：什么是缓存击穿？怎么解决？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯！！</p><p>缓存击穿的意思是对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p><p>解决方案有两种方式：</p><p>第一可以使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的方法</p><p>第二种方案可以设置当前 key 逻辑过期，大概是思路如下：</p><p>①：在设置 key 的时候，设置一个过期时间字段一块存入缓存中，不给当前 key 设置过期时间</p><p>②：当查询的时候，从 redis 取出数据后判断时间是否过期</p><p>③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</p><p>当然两种方案各有利弊：</p><p>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</p><p>如果选择 key 的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p></blockquote><h3 id="面试官什么是缓存雪崩-怎么解决"><a class="anchor" href="#面试官什么是缓存雪崩-怎么解决">#</a> 面试官：什么是缓存雪崩？怎么解决？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯！！</p><p>缓存雪崩意思是设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多 key，击穿是某一个 key 缓存。</p><p>解决方案主要是可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></blockquote><h3 id="面试官redis做为缓存mysql的数据如何与redis进行同步呢双写一致性"><a class="anchor" href="#面试官redis做为缓存mysql的数据如何与redis进行同步呢双写一致性">#</a> 面试官：redis 做为缓存，mysql 的数据如何与 redis 进行同步呢？（双写一致性）</h3><blockquote><p><strong>候选人</strong>：嗯！就说我最近做的这个项目，里面有 xxxx（<strong>根据自己的简历上写</strong>）的功能，需要让数据库与 redis 高度保持一致，因为要求时效性比较高，我们当时采用的读写锁保证的强一致性。</p><p>我们采用的是 redisson 实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。</p></blockquote><h3 id="面试官那这个排他锁是如何保证读写-读读互斥的呢"><a class="anchor" href="#面试官那这个排他锁是如何保证读写-读读互斥的呢">#</a> 面试官：那这个排他锁是如何保证读写、读读互斥的呢？</h3><blockquote><p><strong>候选人</strong>：其实排他锁底层使用也是 setnx，保证了同时只能有一个线程操作锁住的方法</p></blockquote><h3 id="面试官你听说过延时双删吗为什么不用它呢"><a class="anchor" href="#面试官你听说过延时双删吗为什么不用它呢">#</a> 面试官：你听说过延时双删吗？为什么不用它呢？</h3><blockquote><p><strong>候选人</strong>：延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。</p></blockquote><h3 id="面试官redis做为缓存数据的持久化是怎么做的"><a class="anchor" href="#面试官redis做为缓存数据的持久化是怎么做的">#</a> 面试官：redis 做为缓存，数据的持久化是怎么做的？</h3><blockquote><p><strong>候选人</strong>：在 Redis 中提供了两种数据持久化的方式：1、RDB 2、AOF</p></blockquote><h3 id="面试官这两种持久化方式有什么区别呢"><a class="anchor" href="#面试官这两种持久化方式有什么区别呢">#</a> 面试官：这两种持久化方式有什么区别呢？</h3><blockquote><p><strong>候选人</strong>：RDB 是一个快照文件，它是把 redis 内存存储的数据写到磁盘上，当 redis 实例宕机恢复数据的时候，方便从 RDB 的快照文件中恢复数据。</p><p>AOF 的含义是追加文件，当 redis 操作写命令的时候，都会存储这个文件中，当 redis 实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据</p></blockquote><h3 id="面试官这两种方式哪种恢复的比较快呢"><a class="anchor" href="#面试官这两种方式哪种恢复的比较快呢">#</a> 面试官：这两种方式，哪种恢复的比较快呢？</h3><blockquote><p><strong>候选人</strong>：RDB 因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用 AOF 来恢复数据，虽然 AOF 恢复的速度慢一些，但是它丢数据的风险要小很多，在 AOF 文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</p></blockquote><h3 id="面试官redis的数据过期策略有哪些"><a class="anchor" href="#面试官redis的数据过期策略有哪些">#</a> 面试官：Redis 的数据过期策略有哪些？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯～，在 redis 中提供了两种数据过期删除策略</p><p>第一种是惰性删除，在设置该 key 过期时间后，我们不去管它，当需要该 key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该 key。</p><p>第二种是 定期删除，就是说每隔一段时间，我们就对一些 key 进行检查，删除里面过期的 key</p><p>定期清理的两种模式：</p><ul><li>SLOW 模式是定时任务，执行频率默认为 10hz，每次不超过 25ms，以通过修改配置文件 redis.conf 的 <strong>hz</strong> 选项来调整这个次数</li><li>FAST 模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于 2ms，每次耗时不超过 1ms</li></ul><p>Redis 的过期删除策略：<strong>惰性删除 + 定期删除</strong>两种策略进行配合使用。</p></blockquote><h3 id="面试官redis的数据淘汰策略有哪些"><a class="anchor" href="#面试官redis的数据淘汰策略有哪些">#</a> 面试官：Redis 的数据淘汰策略有哪些？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，这个在 redis 中提供了很多种，默认是 noeviction，不删除任何数据，内部不足直接报错</p><p>是可以在 redis 的配置文件中进行设置的，里面有两个非常重要的概念，一个是 LRU，另外一个是 LFU</p><p>LRU 的意思就是最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>LFU 的意思是最少频率使用。会统计每个 key 的访问频率，值越小淘汰优先级越高</p><p>我们在项目设置的 allkeys-lru，挑选最近最少使用的数据淘汰，把一些经常访问的 key 留在 redis 中</p></blockquote><h3 id="面试官数据库有1000万数据-redis只能缓存20w数据-如何保证redis中的数据都是热点数据"><a class="anchor" href="#面试官数据库有1000万数据-redis只能缓存20w数据-如何保证redis中的数据都是热点数据">#</a> 面试官：数据库有 1000 万数据，Redis 只能缓存 20w 数据，如何保证 Redis 中的数据都是热点数据？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，我想一下～～</p><p>可以使用 allkeys-lru （挑选最近最少使用的数据淘汰）淘汰策略，那留下来的都是经常访问的热点数据</p></blockquote><h3 id="面试官redis的内存用完了会发生什么"><a class="anchor" href="#面试官redis的内存用完了会发生什么">#</a> 面试官：Redis 的内存用完了会发生什么？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯～，这个要看 redis 的数据淘汰策略是什么，如果是默认的配置，redis 内存用完以后则直接报错。我们当时设置的 allkeys-lru 策略。把最近最常访问的数据留在缓存中。</p></blockquote><h3 id="面试官redis分布式锁如何实现"><a class="anchor" href="#面试官redis分布式锁如何实现">#</a> 面试官：Redis 分布式锁如何实现？</h3><blockquote><p><strong>候选人</strong>：嗯，在 redis 中提供了一个命令 setnx (SET if not exists)</p><p>由于 redis 的单线程的，用了命令之后，只能有一个客户端对某一个 key 设置值，在没有过期或删除 key 的时候是其他客户端是不能设置这个 key 的</p></blockquote><h3 id="面试官好的那你如何控制redis实现分布式锁有效时长呢"><a class="anchor" href="#面试官好的那你如何控制redis实现分布式锁有效时长呢">#</a> 面试官：好的，那你如何控制 Redis 实现分布式锁有效时长呢？</h3><blockquote><p><strong>候选人</strong>：嗯，的确，redis 的 setnx 指令不好控制这个问题，我们当时采用的 redis 的一个框架 redisson 实现的。</p><p>在 redisson 中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在 redisson 中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了</p><p>还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户 1 持有锁的时候，客户 2 来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户 1 释放之后，客户 2 就可以马上持有锁，性能也得到了提升。</p></blockquote><h3 id="面试官好的redisson实现的分布式锁是可重入的吗"><a class="anchor" href="#面试官好的redisson实现的分布式锁是可重入的吗">#</a> 面试官：好的，redisson 实现的分布式锁是可重入的吗？</h3><blockquote><p><strong>候选人</strong>：嗯，是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的 hash 结构，大 key 可以按照自己的业务进行定制，其中小 key 是当前线程的唯一标识，value 是当前线程重入的次数</p></blockquote><h3 id="面试官redisson实现的分布式锁能解决主从一致性的问题吗"><a class="anchor" href="#面试官redisson实现的分布式锁能解决主从一致性的问题吗">#</a> 面试官：redisson 实现的分布式锁能解决主从一致性的问题吗</h3><blockquote><p><strong>候选人</strong>：这个是不能的，比如，当线程 1 加锁成功后，master 节点数据会异步复制到 slave 节点，此时当前持有 Redis 锁的 master 节点宕机，slave 节点被提升为新的 master 节点，假如现在来了一个线程 2，再次加锁，会在新的 master 节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。</p><p>我们可以利用 redisson 提供的红锁来解决这个问题，它的主要作用是，不能只在一个 redis 实例上创建锁，应该是在多个 redis 实例上创建锁，并且要求在大多数 redis 节点上都成功创建锁，红锁中要求是 redis 的节点数量要过半。这样就能避免线程 1 加锁成功后 master 节点宕机导致线程 2 成功加锁到新的 master 节点上的问题了。</p><p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁</p></blockquote><h3 id="面试官好的如果业务非要保证数据的强一致性这个该怎么解决呢"><a class="anchor" href="#面试官好的如果业务非要保证数据的强一致性这个该怎么解决呢">#</a> 面试官：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？</h3><blockquote><p>** 候选人：** 嗯～，redis 本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用 zookeeper 实现的分布式锁，它是可以保证强一致性的。</p></blockquote><h3 id="面试官redis集群有哪些方案-知道嘛"><a class="anchor" href="#面试官redis集群有哪些方案-知道嘛">#</a> 面试官：Redis 集群有哪些方案，知道嘛？</h3><blockquote><p><strong>候选人</strong>：嗯～～，在 Redis 中提供的集群方案总共有三种：主从复制、哨兵模式、Redis 分片集群</p></blockquote><h3 id="面试官那你来介绍一下主从同步"><a class="anchor" href="#面试官那你来介绍一下主从同步">#</a> 面试官：那你来介绍一下主从同步</h3><blockquote><p><strong>候选人</strong>：嗯，是这样的，单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中</p></blockquote><h3 id="面试官能说一下主从同步数据的流程"><a class="anchor" href="#面试官能说一下主从同步数据的流程">#</a> 面试官：能说一下，主从同步数据的流程</h3><blockquote><p><strong>候选人</strong>：嗯～～，好！主从同步分为了两个阶段，一个是全量同步，一个是增量同步</p><p>全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p><p>第一：从节点请求主节点同步数据，其中从节点会携带自己的 replication id 和 offset 偏移量。</p><p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个 replication id，如果不是，就说明是第一次同步，那主节点就会把自己的 replication id 和 offset 发送给从节点，让从节点与主节点的信息保持一致。</p><p>第三：在同时主节点会执行 bgsave，生成 rdb 文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的 rdb 文件，这样就保持了一致</p><p>当然，如果在 rdb 生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步</p><p>增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的 offset 值，然后主节点从命令日志中获取 offset 值之后的数据，发送给从节点进行数据同步</p></blockquote><h3 id="面试官怎么保证redis的高并发高可用"><a class="anchor" href="#面试官怎么保证redis的高并发高可用">#</a> 面试官：怎么保证 Redis 的高并发高可用</h3><blockquote><p><strong>候选人</strong>：首先可以搭建主从集群，再加上使用 redis 中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主；同时 Sentinel 也充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端，所以一般项目都会采用哨兵的模式来保证 redis 的高并发高可用</p></blockquote><h3 id="面试官你们使用redis是单点还是集群哪种集群"><a class="anchor" href="#面试官你们使用redis是单点还是集群哪种集群">#</a> 面试官：你们使用 redis 是单点还是集群，哪种集群</h3><blockquote><p><strong>候选人</strong>：嗯！，我们当时使用的是主从（1 主 1 从）加哨兵。一般单节点不超过 10G 内存，如果 Redis 内存不足则可以给不同服务分配独立的 Redis 主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用 lua 脚本和事务</p></blockquote><h3 id="面试官redis集群脑裂该怎么解决呢"><a class="anchor" href="#面试官redis集群脑裂该怎么解决呢">#</a> 面试官：redis 集群脑裂，该怎么解决呢？</h3><blockquote><p><strong>候选人</strong>：嗯！ 这个在项目很少见，不过脑裂的问题是这样的，我们现在用的是 redis 的哨兵模式集群的</p><p>有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于 redis master 节点和 redis salve 节点和 sentinel 处于不同的网络分区，使得 sentinel 没有能够心跳感知到 master，所以通过选举的方式提升了一个 salve 为 master，这样就存在了两个 master，就像大脑分裂了一样，这样会导致客户端还在 old master 那里写入数据，新节点无法同步数据，当网络恢复后，sentinel 会将 old master 降为 salve，这时再从新 master 同步数据，这会导致 old master 中的大量数据丢失。</p><p>关于解决的话，我记得在 redis 的配置中可以设置：第一可以设置最少的 salve 节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p></blockquote><h3 id="面试官redis的分片集群有什么作用"><a class="anchor" href="#面试官redis的分片集群有什么作用">#</a> 面试官：redis 的分片集群有什么作用</h3><blockquote><p><strong>候选人</strong>：分片集群主要解决的是，海量数据存储的问题，集群中有多个 master，每个 master 保存不同数据，并且还可以给每个 master 设置多个 slave 节点，就可以继续增大集群的高并发能力。同时每个 master 之间通过 ping 监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></blockquote><h3 id="面试官redis分片集群中数据是怎么存储和读取的"><a class="anchor" href="#面试官redis分片集群中数据是怎么存储和读取的">#</a> 面试官：Redis 分片集群中数据是怎么存储和读取的？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯～，在 redis 集群中是这样的</p><p>Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。</p><p>取值的逻辑是一样的</p></blockquote><h3 id="面试官redis是单线程的但是为什么还那么快"><a class="anchor" href="#面试官redis是单线程的但是为什么还那么快">#</a> 面试官：Redis 是单线程的，但是为什么还那么快？</h3><blockquote><p><strong>候选人</strong>：</p><p>嗯，这个有几个原因吧～～～</p><p>1、完全基于内存的，C 语言编写</p><p>2、采用单线程，避免不必要的上下文切换可竞争条件</p><p>3、使用多路 I/O 复用模型，非阻塞 IO</p><p>例如：bgsave 和 bgrewriteaof 都是在<strong>后台</strong>执行操作，不影响主线程的正常使用，不会产生阻塞</p></blockquote><h3 id="面试官能解释一下io多路复用模型"><a class="anchor" href="#面试官能解释一下io多路复用模型">#</a> 面试官：能解释一下 I/O 多路复用模型？</h3><blockquote><p><strong>候选人</strong>：嗯～～，I/O 多路复用是指利用单个线程来同时监听多个 Socket ，并在某个 Socket 可读、可写时得到通知，从而避免无效的等待，充分利用 CPU 资源。目前的 I/O 多路复用都是采用的 epoll 模式实现，它会在通知用户进程 Socket 就绪的同时，把已就绪的 Socket 写入用户空间，不需要挨个遍历 Socket 来判断是否就绪，提升了性能。</p><p>其中 Redis 的网络模型就是使用 I/O 多路复用结合事件的处理器来应对多个 Socket 请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；</p><p>在 Redis6.0 之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p></blockquote><ul><li>本文引自<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=">黑马程序员 Java 面试宝典</span></li></ul><div class="tags"><a href="/tags/Redis/" rel="tag"><i class="ic i-tag"></i> Redis</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-11 20:16:18" itemprop="dateModified" datetime="2023-08-11T20:16:18+08:00">2023-08-11</time> </span><span id="interview/Redis面试题-参考回答/" class="item leancloud_visitors" data-flag-title="Redis相关面试题" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/weipay.png" alt="anoxia 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="anoxia 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>anoxia <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://anoxiahub.github.io/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Redis相关面试题">https://anoxiahub.github.io/interview/Redis面试题-参考回答/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"></div><div class="item right"><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;mysql_interview.jpg" title="Mysql相关面试题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 面经</span><h3>Mysql相关面试题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">1.</span> <span class="toc-text">面试官：什么是缓存穿透？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A5%BD%E7%9A%84%E4%BD%A0%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%97"><span class="toc-number">2.</span> <span class="toc-text">面试官：好的，你能介绍一下布隆过滤器吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">3.</span> <span class="toc-text">面试官：什么是缓存击穿？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">4.</span> <span class="toc-text">面试官：什么是缓存雪崩？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E5%81%9A%E4%B8%BA%E7%BC%93%E5%AD%98mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%B8%8Eredis%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E5%91%A2%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">面试官：redis 做为缓存，mysql 的数据如何与 redis 进行同步呢？（双写一致性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%82%A3%E8%BF%99%E4%B8%AA%E6%8E%92%E4%BB%96%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%86%99-%E8%AF%BB%E8%AF%BB%E4%BA%92%E6%96%A5%E7%9A%84%E5%91%A2"><span class="toc-number">6.</span> <span class="toc-text">面试官：那这个排他锁是如何保证读写、读读互斥的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BD%A0%E5%90%AC%E8%AF%B4%E8%BF%87%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%AE%83%E5%91%A2"><span class="toc-number">7.</span> <span class="toc-text">面试官：你听说过延时双删吗？为什么不用它呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E5%81%9A%E4%B8%BA%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">8.</span> <span class="toc-text">面试官：redis 做为缓存，数据的持久化是怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="toc-number">9.</span> <span class="toc-text">面试官：这两种持久化方式有什么区别呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%93%AA%E7%A7%8D%E6%81%A2%E5%A4%8D%E7%9A%84%E6%AF%94%E8%BE%83%E5%BF%AB%E5%91%A2"><span class="toc-number">10.</span> <span class="toc-text">面试官：这两种方式，哪种恢复的比较快呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">11.</span> <span class="toc-text">面试官：Redis 的数据过期策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">12.</span> <span class="toc-text">面试官：Redis 的数据淘汰策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%891000%E4%B8%87%E6%95%B0%E6%8D%AE-redis%E5%8F%AA%E8%83%BD%E7%BC%93%E5%AD%9820w%E6%95%B0%E6%8D%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">13.</span> <span class="toc-text">面试官：数据库有 1000 万数据，Redis 只能缓存 20w 数据，如何保证 Redis 中的数据都是热点数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">14.</span> <span class="toc-text">面试官：Redis 的内存用完了会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.</span> <span class="toc-text">面试官：Redis 分布式锁如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A5%BD%E7%9A%84%E9%82%A3%E4%BD%A0%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E6%95%88%E6%97%B6%E9%95%BF%E5%91%A2"><span class="toc-number">16.</span> <span class="toc-text">面试官：好的，那你如何控制 Redis 实现分布式锁有效时长呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A5%BD%E7%9A%84redisson%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%90%97"><span class="toc-number">17.</span> <span class="toc-text">面试官：好的，redisson 实现的分布式锁是可重入的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redisson%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%83%BD%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">18.</span> <span class="toc-text">面试官：redisson 实现的分布式锁能解决主从一致性的问题吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A5%BD%E7%9A%84%E5%A6%82%E6%9E%9C%E4%B8%9A%E5%8A%A1%E9%9D%9E%E8%A6%81%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2"><span class="toc-number">19.</span> <span class="toc-text">面试官：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E9%9B%86%E7%BE%A4%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88-%E7%9F%A5%E9%81%93%E5%98%9B"><span class="toc-number">20.</span> <span class="toc-text">面试官：Redis 集群有哪些方案，知道嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%82%A3%E4%BD%A0%E6%9D%A5%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">21.</span> <span class="toc-text">面试官：那你来介绍一下主从同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">面试官：能说一下，主从同步数据的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">23.</span> <span class="toc-text">面试官：怎么保证 Redis 的高并发高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BD%A0%E4%BB%AC%E4%BD%BF%E7%94%A8redis%E6%98%AF%E5%8D%95%E7%82%B9%E8%BF%98%E6%98%AF%E9%9B%86%E7%BE%A4%E5%93%AA%E7%A7%8D%E9%9B%86%E7%BE%A4"><span class="toc-number">24.</span> <span class="toc-text">面试官：你们使用 redis 是单点还是集群，哪种集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2"><span class="toc-number">25.</span> <span class="toc-text">面试官：redis 集群脑裂，该怎么解决呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E7%9A%84%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">26.</span> <span class="toc-text">面试官：redis 的分片集群有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E5%92%8C%E8%AF%BB%E5%8F%96%E7%9A%84"><span class="toc-number">27.</span> <span class="toc-text">面试官：Redis 分片集群中数据是怎么存储和读取的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%86%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%82%A3%E4%B9%88%E5%BF%AB"><span class="toc-number">28.</span> <span class="toc-text">面试官：Redis 是单线程的，但是为什么还那么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">29.</span> <span class="toc-text">面试官：能解释一下 I&#x2F;O 多路复用模型？</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="Mysql相关面试题">Mysql相关面试题</a></li><li class="active"><a href="/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="Redis相关面试题">Redis相关面试题</a></li><li><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="Spring相关面试题">Spring相关面试题</a></li><li><a href="/interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="微服务相关面试题">微服务相关面试题</a></li><li><a href="/interview/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="消息中间件相关面试题">消息中间件相关面试题</a></li><li><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="Java集合相关面试题">Java集合相关面试题</a></li><li><a href="/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="多线程相关面试题">多线程相关面试题</a></li><li><a href="/interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" rel="bookmark" title="JVM相关面试题">JVM相关面试题</a></li><li><a href="/interview/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/" rel="bookmark" title="常见技术场景">常见技术场景</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="anoxia" data-src="/images/avatar.webp"><p class="name" itemprop="name">anoxia</p><div class="description" itemprop="description">anoxia的后端博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">18</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbjB5dWFu" title="https:&#x2F;&#x2F;github.com&#x2F;lin0yuan"><i class="ic i-github"></i></span> <a href="/3102691553@qq.com" title="3102691553@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Mysql相关面试题">Mysql相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程相关面试题">多线程相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" title="JVM详解">JVM详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/" title="常见技术场景">常见技术场景</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/HTTP%E5%92%8CWebsocket%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="HTTP和Websocket的前世今生">HTTP和Websocket的前世今生</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">Java集合详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="微服务相关面试题">微服务相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" title="项目常见问题">项目常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="关于缓存读写一致问题">关于缓存读写一致问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Spring相关面试题">Spring相关面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">anoxia @ 智慧笔记</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">129k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:57</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"interview/Redis面试题-参考回答/",favicon:{show:"智慧笔记",hide:"别走嘛QwQ"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->