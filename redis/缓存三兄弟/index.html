<!-- build time: Thu Aug 24 2023 18:26:23 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://anoxiahub.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://anoxiahub.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://anoxiahub.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Redis"><link rel="canonical" href="https://anoxiahub.github.io/redis/%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F/"><title>缓存三兄弟 - Redis | 智慧笔记 = = 欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">缓存三兄弟</h1><div class="meta"><span class="item" title="创建时间：2023-08-24 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-24T00:00:00+08:00">2023-08-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>4.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>4 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">智慧笔记</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/3dd7534604e07adb5c0ba98b414b19fb.webp"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/redis/" itemprop="item" rel="index" title="分类于 Redis"><span itemprop="name">Redis</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anoxiahub.github.io/redis/%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="anoxia"><meta itemprop="description" content="欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸, anoxia的后端博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一聊到redis，必不可少的就是缓存三兄弟的问题，即<code>缓存穿透、缓存击穿和缓存雪崩</code>，这三个问题在业务场景中相对来说比较常见的，也是比较基础的三种问题。那么这三种问题是如何引起的，并且应该如何解决，就是本章探讨的话题。</p><h1 id="一、问题前引"><a href="#一、问题前引" class="headerlink" title="一、问题前引"></a>一、问题前引</h1><p>大家都知道，Redis一般搭配MySQL来使用，来充当缓存处理一些业务数据。但为什么要Redis用来充当缓存呢，不能直接使用MySQL吗？</p><p>当然是可以的，但是对于一些<code>请求量大并发次数高</code>的场景就有问题了。</p><p>MySQL是基于磁盘的，请求查询速度偏慢，所以就需要一个基于内存的速度快的工具来<code>缓存</code>这些数据，Redis就应运而生了。而且当大量请求到来时，只有MySQL的话，有可能承受不住大量请求导致MySQL宕机，此时就会影响到整个服务器，所以Redis此时又充当了一个保护<code>缓冲</code>的作用。</p><h1 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>缓存穿透主要体现在<code>穿透</code>两个字上，穿透即为穿过缓存，打到数据库上。</p><p>当一个请求访问的时候，此时Redis没有缓存该数据，然后去数据库查询该数据也查询到，说明没有该数据。<br><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/e605571436af4eacaeec0823ab6a0b91.png" alt="在这里插入图片描述"></p><p>此时你或许还不以为然，不就一个空数据吗？多稀罕啊。</p><p>但如果该请求是恶意请求，此时无数条请求同时访问，缓存中没有，全部都会打在数据库上，刚好还是类似于</p><pre><code class="sql">select * from table where name = &quot;李白&quot;
</code></pre><p>表中有1000万条数据，name字段也没有创建索引。这时候问题是不是就大了？服务器稍微差一点，就会直接宕机。<br><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/ac2aefc4bdda4ef89f35fb402e4504da.png" alt="在这里插入图片描述"></p><p>这时你或许该问了，那该如何解决呢？不要急，机智的程序猿肯定有应对之法。</p><h2 id="2-问题解决"><a href="#2-问题解决" class="headerlink" title="2. 问题解决"></a>2. 问题解决</h2><h3 id="2-1-缓存空数据"><a href="#2-1-缓存空数据" class="headerlink" title="2.1 缓存空数据"></a>2.1 缓存空数据</h3><p>如果此时将请求的数据缓存起来，是不是就可以避免请求打到数据库了？</p><p>你现在或许又要问了，空数据怎么缓存呢？没错，就是<code>缓存空数据</code>。</p><p>如果请求的数据查询数据为空的话，就将该数据为空值缓存到Redis中，以后每次请求都直接访问Redis，查询到该数据，<code>直接返回空值</code>。这样就避免恶意请求全部打到数据库了。<br><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/2a19da38fbc546d5a64a1a1cca53858a.png" alt="在这里插入图片描述"></p><h3 id="2-2-布隆过滤器"><a href="#2-2-布隆过滤器" class="headerlink" title="2.2 布隆过滤器"></a>2.2 布隆过滤器</h3><blockquote><p>不了解布隆过滤器的同学可以看这篇文章<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80OTY1ODQ1NDU=">硬核 | Redis 布隆（Bloom Filter）过滤器原理与实战</span></p></blockquote><p>布隆过滤器 (Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出，它是一种 space efficient 的概率型数据结构，用于判断一个元素是否在集合中。</p><p>当布隆过滤器说，<code>某个数据存在时，这个数据可能不存在</code>；当布隆过滤器说，<code>某个数据不存在时，那么这个数据一定不存在</code>。</p><p>哈希表也能用于判断元素是否在集合中，但是布隆过滤器只需要哈希表的 1&#x2F;8 或 1&#x2F;4 的空间复杂度就能完成同样的问题。</p><p>布隆过滤器<code>可以插入元素，但不可以删除已有元素</code>。</p><p>其中的元素越多，false positive rate(误报率)越大，但是 false negative (漏报)是不可能的。<br>布隆过滤器原理</p><p>BloomFilter 的算法是，首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。</p><p>加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。</p><p>检测 key 是否存在，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在。</p><p>如下图所示：<br><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/3dd7534604e07adb5c0ba98b414b19fb.webp" alt="在这里插入图片描述"></p><h1 id="三、缓存击穿"><a href="#三、缓存击穿" class="headerlink" title="三、缓存击穿"></a>三、缓存击穿</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>缓存击穿一般常见于电商场景，在双十一和六一八这种大促活动中，缓存中会缓存一些热点数据，随时都有大量的请求访问这个数据。</p><p>当某个时刻这个数据突然过期，大量请求就会集中打到MySQL数据库中。<br><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/b4c91fbfab30451cbdfec59d4ae92d50.png" alt="在这里插入图片描述"></p><blockquote><p>如何解决这个问题呢？</p></blockquote><h2 id="2-问题解决-1"><a href="#2-问题解决-1" class="headerlink" title="2. 问题解决"></a>2. 问题解决</h2><p>该问题导致的原因是因为该缓存数据过期了，但却有大量请求访问该数据；</p><p>有两条思路去解决：</p><ul><li><code>不让该数据过期</code></li><li><code>不让大量请求访问数据库</code></li></ul><h3 id="2-1-设置逻辑过期"><a href="#2-1-设置逻辑过期" class="headerlink" title="2.1 设置逻辑过期"></a>2.1 设置逻辑过期</h3><p>热点数据随时都会有变化，不设置过期时间的话会导致更多问题，不能因此失彼。</p><p>但可以换一个思路，在数据过期时无缝衔接一个新数据，在请求看来这就是没有过期时间的一个数据。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/93ac585a9fad4a208ac19a40f434383a.png" alt="在这里插入图片描述"></p><p>此时如果大量请求访问该数据，刚好该数据缓存逻辑过期，但没有设置物理过期时间，所以数据并不会被redis清除。</p><p>此时由业务代码去判断，该缓存是否过期，如果过期则获取互斥锁<code>新建一个子线程</code>去访问数据库重新设置缓存，<code>主线程返回过期数据</code>，没有获取互斥锁的都<code>返回过期数据</code>。</p><p>完整代码如下：</p><pre><code class="java"> //逻辑过期
    public Shop queryWithLogicalExpire(Long id) &#123;
        String key = CACHE_SHOP_KEY + id;
        //1.从redis查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        //2.判断是否存在
        if (StrUtil.isBlank(shopJson)) &#123;
            //3.未命中
            return null;
        &#125;
        //4.命中，需要先把json反序列化为对象
        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
        Shop shop = (Shop) redisData.getData();
        LocalDateTime expireTime = redisData.getExpireTime();
        //5.判断是否过期
        if (expireTime.isAfter(LocalDateTime.now())) &#123;
            //5.1还未过期
            return shop;
        &#125;
        //5.2已经过期，需要缓存重建
        //6.缓存重建
        //6.1获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        //6.2判断是否获取锁成功
        if (isLock) &#123;
            // 6.3成功，开启独立线程，实现缓存重建
            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;
                try &#123;
                    //重建缓存
                    this.saveShop2Redis(id, 20L);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    //释放锁
                    unlock(lockKey);
                &#125;
            &#125;);
        &#125;
        //6.4返回过期的店铺信息
        //7.返回
        return shop;
    &#125;
</code></pre><h3 id="2-2-设置互斥锁"><a href="#2-2-设置互斥锁" class="headerlink" title="2.2 设置互斥锁"></a>2.2 设置互斥锁</h3><p>怎么才能不让大量数据去访问数据库呢？</p><p>或许大家已经想到了，上面设置逻辑过期用到过的一个功能：<code>互斥锁</code>。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/a8fe33e68ef84d18a37ed5009f5cf40b.png" alt="在这里插入图片描述"></p><p>请求首先访问缓存，如果命中的话，直接返回该数据。</p><p>如果未命中的话，则去获取互斥锁，获取成功则查询数据库重新设置缓存，获取失败，则<code>重试获取缓存数据</code>。</p><p>完整代码如下：</p><pre><code class="java">/**
     * 通过互斥锁机制查询商铺信息
     * @param key
     */
    private Shop queryShopWithMutex(String key, String cityCode) &#123;
        Shop shop = null;
        // 1.查询缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        // 2.判断缓存是否有数据
        if (StringUtils.isNotBlank(shopJson)) &#123;
            // 3.有,则返回
            shop = JSONObject.parseObject(shopJson, Shop.class);
            return shop;
        &#125;
        // 4.无,则获取互斥锁
        String lockKey = RedisConstants.LOCK_SHOP_KEY + shopCode;
        Boolean isLock = tryLock(lockKey);
        // 5.判断获取锁是否成功
        try &#123;
            if (!isLock) &#123;
                // 6.获取失败, 休眠并重试
                Thread.sleep(100);
                return queryShopWithMutex(key, shopCode);
            &#125;
            // 7.获取成功, 查询数据库
            shop = baseMapper.getByCode(shopCode);
            // 8.判断数据库是否有数据
            if (shop == null) &#123;
                // 9.无,则将空数据写入redis
                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);
                return null;
            &#125;
            // 10.有,则将数据写入redis
            stringRedisTemplate.opsForValue().set(key, JSONObject.toJSONString(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            // 11.释放锁
            unLock(lockKey);
        &#125;
        // 12.返回数据
        return shop;
    &#125;
</code></pre><blockquote><p>关于两种方案，各有各的优缺点</p><ul><li>逻辑过期： 及时性高，但数据不是最新数据，适合最终一致性的业务</li><li>互斥锁： 一致性高，但会有数据延迟，适合强一致性的业务</li></ul></blockquote><h1 id="四、缓存雪崩"><a href="#四、缓存雪崩" class="headerlink" title="四、缓存雪崩"></a>四、缓存雪崩</h1><h2 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>缓存雪崩可以简单的理解为大范围的缓存击穿。</p><p>有两个可能引起缓存雪崩问题：</p><ul><li><code>有大量的热门缓存同时失效</code>。会导致大量的请求，访问数据库。而数据库很有可能因为扛不住压力，而直接挂掉。</li><li><code>缓存服务器down机了</code>，可能是机器硬件问题，或者机房网络问题。造成了整个缓存的不可用。</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/332236c568114666ae63f7ad3e20ea9e.png" alt="在这里插入图片描述"></p><h2 id="2-问题解决-2"><a href="#2-问题解决-2" class="headerlink" title="2. 问题解决"></a>2. 问题解决</h2><h3 id="2-1-设置随机过期时间"><a href="#2-1-设置随机过期时间" class="headerlink" title="2.1 设置随机过期时间"></a>2.1 设置随机过期时间</h3><p>为了解决缓存雪崩问题，我们首先要尽量<code>避免缓存同时失效</code>的情况发生。</p><p>这就要求我们不要设置相同的过期时间。</p><p>可以在设置的过期时间基础上，再加个1~60秒的随机数。</p><p>实际过期时间 &#x3D; 过期时间 + 1~60秒的随机数</p><p>这样即使在高并发的情况下，多个请求同时设置过期时间，由于有随机数的存在，也不会出现太多相同的过期key。</p><h3 id="2-2-缓存高可用"><a href="#2-2-缓存高可用" class="headerlink" title="2.2 缓存高可用"></a>2.2 缓存高可用</h3><p>针对缓存服务器down机的情况，在前期做系统设计时，可以做一些<code>高可用架构</code>。</p><p>可以使用<code>哨兵机制或者集群模式</code>，当一个Redis宕机，随时会有一个Redis补充上来，避免一个Redis宕机而导致大量请求去访问数据库，而使数据库压力过载。</p><p>比如使用哨兵模式之后，当某个master服务下线时，自动将该master下的某个slave服务升级为master服务，替代已下线的master服务继续处理请求。<br><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/ad2175c7263d69659b48d62f89d1ab03.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>缓存穿透、缓存击穿和缓存雪崩是三种与缓存相关的常见问题，它们的概念和影响有所不同。</p><p>关于Redis缓存三兄弟的问题及解决主要就是以下几个方面：</p><p><strong>缓存穿透：</strong></p><ul><li><p>缓存穿透指的是对于一个不存在于缓存和数据库中的数据的请求，每次请求都会穿过缓存层直接访问数据库。</p></li><li><p>恶意的攻击者可以通过构造不存在的数据请求，导致大量请求直接访问数据库，增加数据库负载压力。</p></li><li><p>解决缓存穿透可以采用存储空数据和合适的校验技术，例如使用布隆过滤器等技术，在缓存层进行初步过滤，避免无效请求直接访问数据库。</p></li></ul><p><strong>缓存击穿：</strong></p><ul><li><p>缓存击穿指的是在高并发情况下，一个热点数据过期或失效时，大量请求同时涌入数据库，造成数据库压力激增。</p></li><li><p>由于热点数据没有命中缓存，而直接访问数据库，使得缓存无法发挥作用，增加了数据库的负载。</p></li><li><p>解决缓存击穿可以采取设置热点数据永不过期，或者使用互斥锁等机制来控制只有一个线程去加载数据。</p></li></ul><p><strong>缓存雪崩：</strong></p><ul><li>缓存雪崩指的是在某个时间点，缓存中的大量数据同时失效或过期或者缓存服务宕机，导致大量请求直接访问后端数据库，造成数据库压力过大。</li><li>当缓存中的数据集中过期或失效时，没有缓存可用，导致大量请求直接访问数据库，可能引起数据库负载激增甚至崩溃。</li><li>解决缓存雪崩可以采用合理的缓存失效时间设置、使用高可用架构等方式来减少缓存失效的风险。</li></ul><blockquote><p>当然能解决的方式有很多，这里只是列举出来常见的解决方法。如果有更好的建议可以发在评论区。</p></blockquote><div class="tags"><a href="/tags/Redis/" rel="tag"><i class="ic i-tag"></i> Redis</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-24 18:22:54" itemprop="dateModified" datetime="2023-08-24T18:22:54+08:00">2023-08-24</time> </span><span id="redis/缓存三兄弟/" class="item leancloud_visitors" data-flag-title="缓存三兄弟" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/weipay.png" alt="anoxia 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="anoxia 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>anoxia <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://anoxiahub.github.io/redis/%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F/" title="缓存三兄弟">https://anoxiahub.github.io/redis/缓存三兄弟/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;static.mikechen.cc&#x2F;wp-content&#x2F;uploads&#x2F;2021&#x2F;03&#x2F;redis-interview.png" title="Redis专项题库-个人练习"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 专项练习</span><h3>Redis专项题库-个人练习</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E5%89%8D%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text">一、问题前引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.</span> <span class="toc-text">二、缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">3.2.</span> <span class="toc-text">2. 问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BC%93%E5%AD%98%E7%A9%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 缓存空数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 布隆过滤器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">4.</span> <span class="toc-text">三、缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-1"><span class="toc-number">4.2.</span> <span class="toc-text">2. 问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%BE%E7%BD%AE%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 设置逻辑过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AE%BE%E7%BD%AE%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 设置互斥锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.</span> <span class="toc-text">四、缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">5.1.</span> <span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-2"><span class="toc-number">5.2.</span> <span class="toc-text">2. 问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 设置随机过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BC%93%E5%AD%98%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 缓存高可用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" rel="bookmark" title="关于缓存读写一致问题">关于缓存读写一致问题</a></li><li class="active"><a href="/redis/%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F/" rel="bookmark" title="缓存三兄弟">缓存三兄弟</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="anoxia" data-src="/images/avatar.webp"><p class="name" itemprop="name">anoxia</p><div class="description" itemprop="description">anoxia的后端博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">18</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbjB5dWFu" title="https:&#x2F;&#x2F;github.com&#x2F;lin0yuan"><i class="ic i-github"></i></span> <a href="/3102691553@qq.com" title="3102691553@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="JVM相关面试题">JVM相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/Mysql%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/" title="连接数据库遇到问题">连接数据库遇到问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Spring相关面试题">Spring相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="关于缓存读写一致问题">关于缓存读写一致问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" title="项目常见问题">项目常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/special/" title="分类于 专项练习">专项练习</a></div><span><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" title="Redis专项题库-个人练习">Redis专项题库-个人练习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题">Java集合相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/" title="常见技术场景">常见技术场景</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" title="JUC详解">JUC详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Redis相关面试题">Redis相关面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">anoxia @ 智慧笔记</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">129k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:57</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"redis/缓存三兄弟/",favicon:{show:"智慧笔记",hide:"别走嘛QwQ"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->