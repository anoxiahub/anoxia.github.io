<!-- build time: Thu Aug 24 2023 18:26:23 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://anoxiahub.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://anoxiahub.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://anoxiahub.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Java基础"><link rel="canonical" href="https://anoxiahub.github.io/java/JUC%E8%AF%A6%E8%A7%A3/"><title>JUC详解 - Java | 智慧笔记 = = 欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JUC详解</h1><div class="meta"><span class="item" title="创建时间：2023-08-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-15T00:00:00+08:00">2023-08-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>32k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>29 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">智慧笔记</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.Lmrn8WhH_ezNA9AuLvhq6QHaEL?w=291&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anoxiahub.github.io/java/JUC%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="anoxia"><meta itemprop="description" content="欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸, anoxia的后端博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><p><code>文档说明</code></p><blockquote><p>在文档中对所有的面试题都进行了<strong>难易程度</strong>和<strong>出现频率</strong>的等级说明</p><p>星数越多代表权重越大，最多五颗星（☆☆☆☆☆） 最少一颗星（☆）</p></blockquote><h2 id="线程的基础知识"><a href="#线程的基础知识" class="headerlink" title="线程的基础知识"></a>线程的基础知识</h2><h3 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</p><p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221026105350827.png" alt="image-20221026105350827"></p><p>一个进程之内可以分为一到多个线程。</p><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221026105442158.png" alt="image-20221026105442158"></p><p><strong>二者对比</strong></p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li></ul><h3 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h3><blockquote><p>难易程度：☆</p><p>出现频率：☆</p></blockquote><p>单核CPU</p><ul><li><p>单核CPU下线程实际还是串行执行的</p></li><li><p>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</p></li><li><p>总结为一句话就是： 微观串行，宏观并行</p></li></ul><p>一般会将这种线程轮流使用CPU的做法称为并发（concurrent）</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230503203246348.png" alt="image-20230503203246348"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221026105607248.png" alt="image-20221026105607248"></p><p>多核CPU</p><p>每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230503203330700.png" alt="image-20230503203330700"></p><p><strong>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</strong></p><p><strong>并行（parallel）是同一时间动手做（doing）多件事情的能力</strong></p><blockquote><p>举例：</p><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li></ul></blockquote><h3 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>参考回答：</p><p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程</p><p>详细创建方式参考下面代码：</p><p>① <strong>继承Thread类</strong></p><pre><code class="java">public class MyThread extends Thread &#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;MyThread...run...&quot;);
    &#125;

    
    public static void main(String[] args) &#123;

        // 创建MyThread对象
        MyThread t1 = new MyThread() ;
        MyThread t2 = new MyThread() ;

        // 调用start方法启动线程
        t1.start();
        t2.start();

    &#125;
    
&#125;
</code></pre><p>② <strong>实现runnable接口</strong></p><pre><code class="java">public class MyRunnable implements Runnable&#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;MyRunnable...run...&quot;);
    &#125;

    public static void main(String[] args) &#123;

        // 创建MyRunnable对象
        MyRunnable mr = new MyRunnable() ;

        // 创建Thread对象
        Thread t1 = new Thread(mr) ;
        Thread t2 = new Thread(mr) ;

        // 调用start方法启动线程
        t1.start();
        t2.start();

    &#125;

&#125;
</code></pre><p>③ <strong>实现Callable接口</strong></p><pre><code class="java">public class MyCallable implements Callable&lt;String&gt; &#123;

    @Override
    public String call() throws Exception &#123;
        System.out.println(&quot;MyCallable...call...&quot;);
        return &quot;OK&quot;;
    &#125;

    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;

        // 创建MyCallable对象
        MyCallable mc = new MyCallable() ;

        // 创建F
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(mc) ;

        // 创建Thread对象
        Thread t1 = new Thread(ft) ;
        Thread t2 = new Thread(ft) ;

        // 调用start方法启动线程
        t1.start();

        // 调用ft的get方法获取执行结果
        String result = ft.get();

        // 输出
        System.out.println(result);

    &#125;

&#125;
</code></pre><p>④ <strong>线程池创建线程</strong></p><pre><code class="java">public class MyExecutors implements Runnable&#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;MyRunnable...run...&quot;);
    &#125;

    public static void main(String[] args) &#123;

        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()) ;

        // 关闭线程池
        threadPool.shutdown();

    &#125;

&#125;
</code></pre><h3 id="runnable-和-callable-有什么区别"><a href="#runnable-和-callable-有什么区别" class="headerlink" title="runnable 和 callable 有什么区别"></a>runnable 和 callable 有什么区别</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>参考回答：</p><ol><li>Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li></ol><h3 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</p><p>run(): 封装了要被线程执行的代码，可以被调用多次。</p><h3 id="线程包括哪些状态，状态之间是如何变化的"><a href="#线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的"></a>线程包括哪些状态，状态之间是如何变化的</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程的状态可以参考JDK中的Thread类中的枚举State</p><pre><code class="java">public enum State &#123;
        /**
         * 尚未启动的线程的线程状态
         */
        NEW,

        /**
         * 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自		 * 操作系统的其他资源，例如处理器。
         */
        RUNNABLE,

        /**
         * 线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调          * 用Object.wait后重新进入同步块/方法。
         */
        BLOCKED,

        /**
         * 等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：
        * Object.wait没有超时
         * 没有超时的Thread.join
         * LockSupport.park
         * 处于等待状态的线程正在等待另一个线程执行特定操作。
         * 例如，一个对对象调用Object.wait()的线程正在等待另一个线程对该对象调用Object.notify()			* 或Object.notifyAll() 。已调用Thread.join()的线程正在等待指定线程终止。
         */
        WAITING,

        /**
         * 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定          * 时等待状态：
        * Thread.sleep
        * Object.wait超时
        * Thread.join超时
        * LockSupport.parkNanos
        * LockSupport.parkUntil
         * &lt;/ul&gt;
         */
        TIMED_WAITING,

        /**
         * 已终止线程的线程状态。线程已完成执行
         */
        TERMINATED;
    &#125;
</code></pre><p>状态之间是如何变化的</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230503203629212.png" alt="image-20230503203629212"></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><h3 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>代码举例：</p><p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成</p><pre><code class="java">public class JoinTest &#123;

    public static void main(String[] args) &#123;

        // 创建线程对象
        Thread t1 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t1&quot;);
        &#125;) ;

        Thread t2 = new Thread(() -&gt; &#123;
            try &#123;
                t1.join();                          // 加入线程t1,只有t1线程执行完毕以后，再次执行该线程
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t2&quot;);
        &#125;) ;


        Thread t3 = new Thread(() -&gt; &#123;
            try &#123;
                t2.join();                              // 加入线程t2,只有t2线程执行完毕以后，再次执行该线程
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t3&quot;);
        &#125;) ;

        // 启动线程
        t1.start();
        t2.start();
        t3.start();

    &#125;

&#125;
</code></pre><h3 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>notifyAll：唤醒所有wait的线程</p><p>notify：只随机唤醒一个 wait 线程</p><pre><code class="java">package com.itheima.basic;

public class WaitNotify &#123;

    static boolean flag = false;
    static Object lock = new Object();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (lock)&#123;
                while (!flag)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;...wating...&quot;);
                    try &#123;
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
                System.out.println(Thread.currentThread().getName()+&quot;...flag is true&quot;);
            &#125;
        &#125;);

        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (lock)&#123;
                while (!flag)&#123;
                    System.out.println(Thread.currentThread().getName()+&quot;...wating...&quot;);
                    try &#123;
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
                System.out.println(Thread.currentThread().getName()+&quot;...flag is true&quot;);
            &#125;
        &#125;);

        Thread t3 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                System.out.println(Thread.currentThread().getName() + &quot; hold lock&quot;);
                lock.notifyAll();
                flag = true;
                try &#123;
                    Thread.sleep(2000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t3.start();

    &#125;

&#125;
</code></pre><h3 id="在-java-中-wait-和-sleep-方法的不同？"><a href="#在-java-中-wait-和-sleep-方法的不同？" class="headerlink" title="在 java 中 wait 和 sleep 方法的不同？"></a>在 java 中 wait 和 sleep 方法的不同？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>参考回答：</p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><p>代码示例：</p><pre><code class="java">public class WaitSleepCase &#123;

    static final Object LOCK = new Object();

    public static void main(String[] args) throws InterruptedException &#123;
        sleeping();
    &#125;

    private static void illegalWait() throws InterruptedException &#123;
        LOCK.wait();
    &#125;

    private static void waiting() throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (LOCK) &#123;
                try &#123;
                    get(&quot;t&quot;).debug(&quot;waiting...&quot;);
                    LOCK.wait(5000L);
                &#125; catch (InterruptedException e) &#123;
                    get(&quot;t&quot;).debug(&quot;interrupted...&quot;);
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;t1&quot;);
        t1.start();

        Thread.sleep(100);
        synchronized (LOCK) &#123;
            main.debug(&quot;other...&quot;);
        &#125;

    &#125;

    private static void sleeping() throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (LOCK) &#123;
                try &#123;
                    get(&quot;t&quot;).debug(&quot;sleeping...&quot;);
                    Thread.sleep(5000L);
                &#125; catch (InterruptedException e) &#123;
                    get(&quot;t&quot;).debug(&quot;interrupted...&quot;);
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;t1&quot;);
        t1.start();

        Thread.sleep(100);
        synchronized (LOCK) &#123;
            main.debug(&quot;other...&quot;);
        &#125;
    &#125;
&#125;
</code></pre><h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>参考回答：</p><p>有三种方式可以停止线程</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程</li></ul><p>代码参考如下：</p><p>① <strong>使用退出标志，使线程正常退出</strong>。</p><pre><code class="java">public class MyInterrupt1 extends Thread &#123;

    volatile boolean flag = false ;     // 线程执行的退出标记

    @Override
    public void run() &#123;
        while(!flag) &#123;
            System.out.println(&quot;MyThread...run...&quot;);
            try &#123;
                Thread.sleep(3000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;

        // 创建MyThread对象
        MyInterrupt1 t1 = new MyInterrupt1() ;
        t1.start();

        // 主线程休眠6秒
        Thread.sleep(6000);

        // 更改标记为true
        t1.flag = true ;

    &#125;
&#125;
</code></pre><p>② <strong>使用stop方法强行终止</strong></p><pre><code class="java">public class MyInterrupt2 extends Thread &#123;

    volatile boolean flag = false ;     // 线程执行的退出标记

    @Override
    public void run() &#123;
        while(!flag) &#123;
            System.out.println(&quot;MyThread...run...&quot;);
            try &#123;
                Thread.sleep(3000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;

        // 创建MyThread对象
        MyInterrupt2 t1 = new MyInterrupt2() ;
        t1.start();

        // 主线程休眠2秒
        Thread.sleep(6000);

        // 调用stop方法
        t1.stop();

    &#125;
&#125;
</code></pre><p>③ <strong>使用interrupt方法中断线程</strong>。</p><pre><code class="java">package com.itheima.basic;

public class MyInterrupt3 &#123;

    public static void main(String[] args) throws InterruptedException &#123;

        //1.打断阻塞的线程
        /*Thread t1 = new Thread(()-&gt;&#123;
            System.out.println(&quot;t1 正在运行...&quot;);
            try &#123;
                Thread.sleep(5000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, &quot;t1&quot;);
        t1.start();
        Thread.sleep(500);
        t1.interrupt();
        System.out.println(t1.isInterrupted());*/


        //2.打断正常的线程
        Thread t2 = new Thread(()-&gt;&#123;
            while(true) &#123;
                Thread current = Thread.currentThread();
                boolean interrupted = current.isInterrupted();
                if(interrupted) &#123;
                    System.out.println(&quot;打断状态：&quot;+interrupted);
                    break;
                &#125;
            &#125;
        &#125;, &quot;t2&quot;);
        t2.start();
        Thread.sleep(500);
//        t2.interrupt();

    &#125;
&#125;
</code></pre><h2 id="线程中并发锁"><a href="#线程中并发锁" class="headerlink" title="线程中并发锁"></a>线程中并发锁</h2><h3 id="讲一下synchronized关键字的底层原理？"><a href="#讲一下synchronized关键字的底层原理？" class="headerlink" title="讲一下synchronized关键字的底层原理？"></a>讲一下synchronized关键字的底层原理？</h3><blockquote><p>难易程度：☆☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>如下抢票的代码，如果不加锁，就会出现超卖或者一张票卖给多个人</p><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p><pre><code class="java">
public class TicketDemo &#123;

    static Object lock = new Object();
    int ticketNum = 10;


    public synchronized void getTicket() &#123;
        synchronized (this) &#123;
            if (ticketNum &lt;= 0) &#123;
                return;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;抢到一张票,剩余:&quot; + ticketNum);
            // 非原子性操作
            ticketNum--;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        TicketDemo ticketDemo = new TicketDemo();
        for (int i = 0; i &lt; 20; i++) &#123;
            new Thread(() -&gt; &#123;
                ticketDemo.getTicket();
            &#125;).start();
        &#125;
    &#125;


&#125;
</code></pre><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p><p>在代码中想要体现monitor需要借助javap命令查看clsss的字节码，比如以下代码：</p><pre><code class="java">public class SyncTest &#123;

    static final Object lock = new Object();
    static int counter = 0;
    public static void main(String[] args) &#123;
        synchronized (lock) &#123;
            counter++;
        &#125;
    &#125;
&#125;
</code></pre><p>找到这个类的class文件，在class文件目录下执行<code>javap -v SyncTest.class</code>，反编译效果如下：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504165342501.png" alt="image-20230504165342501"></p><blockquote><ul><li>monitorenter 上锁开始的地方</li><li>monitorexit 解锁的地方</li><li>其中被monitorenter和monitorexit包围住的指令就是上锁的代码</li><li>有两个monitorexit的原因，第二个monitorexit是为了防止锁住的代码抛异常后不能及时释放锁</li></ul></blockquote><p>在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁</p><p>monitor主要就是跟这个对象产生关联，如下图</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504165833809.png" alt="image-20230504165833809"></p><p>Monitor内部具体的存储结构：</p><ul><li><p>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</p></li><li><p>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</p></li><li><p>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</p></li></ul><p>具体的流程：</p><ul><li>代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有</li><li>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</li><li>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）</li><li>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</li></ul><p>参考回答：</p><ul><li><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</p></li><li><p>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</p></li><li><p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p></li><li><p>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</p></li></ul><h3 id="synchronized关键字的底层原理-进阶"><a href="#synchronized关键字的底层原理-进阶" class="headerlink" title="synchronized关键字的底层原理-进阶"></a>synchronized关键字的底层原理-进阶</h3><p>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</p><ul><li><p>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p></li><li><p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p></li></ul><h4 id="对象的内存结构"><a href="#对象的内存结构" class="headerlink" title="对象的内存结构"></a>对象的内存结构</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504172253826.png" alt="image-20230504172253826"></p><p>我们需要重点分析MarkWord对象头</p><h4 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504172541922.png" alt="image-20230504172541922"></p><blockquote><ul><li><p>hashcode：25位的对象标识Hash码</p></li><li><p>age：对象分代年龄占4位</p></li><li><p>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</p></li><li><p>thread：持有偏向锁的线程ID，占23位</p></li><li><p>epoch：偏向时间戳，占2位</p></li><li><p>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</p></li><li><p>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</p></li></ul></blockquote><p>我们可以通过lock的标识，来判断是哪一种锁的等级</p><ul><li>后三位是001表示无锁</li><li>后三位是101表示偏向锁</li><li>后两位是00表示轻量级锁</li><li>后两位是10表示重量级锁</li></ul><h4 id="再说Monitor重量级锁"><a href="#再说Monitor重量级锁" class="headerlink" title="再说Monitor重量级锁"></a>再说Monitor重量级锁</h4><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，<strong>该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504172957271.png" alt="image-20230504172957271"></p><p>简单说就是：每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p><pre><code class="java">static final Object obj = new Object();

public static void method1() &#123;
    synchronized (obj) &#123;
        // 同步块 A
        method2();
    &#125;
&#125;

public static void method2() &#123;
    synchronized (obj) &#123;
        // 同步块 B
    &#125;
&#125;
</code></pre><p><strong>加锁的流程</strong></p><p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504173520412.png" alt="image-20230504173520412"></p><p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504173611219.png" alt="image-20230504173611219"></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504173922343.png" alt="image-20230504173922343"></p><p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p><p><strong>解锁过程</strong></p><p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p><p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504173955680.png" alt="image-20230504173955680"></p><p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504174045458.png" alt="image-20230504174045458"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p><p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><pre><code class="java">static final Object obj = new Object();

public static void m1() &#123;
    synchronized (obj) &#123;
        // 同步块 A
        m2();
    &#125;
&#125;

public static void m2() &#123;
    synchronized (obj) &#123;
        // 同步块 B
        m3();
    &#125;
&#125;

public static void m3() &#123;
    synchronized (obj) &#123;

    &#125;
&#125;
</code></pre><p><strong>加锁的流程</strong></p><p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504174525256.png" alt="image-20230504174525256"></p><p>2.通过CAS指令将Lock Record的<strong>线程id</strong>存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504174505031.png" alt="image-20230504174505031"></p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504174736226.png" alt="image-20230504174736226"></p><p>解锁流程参考轻量级锁</p><h4 id="参考回答"><a href="#参考回答" class="headerlink" title="参考回答"></a>参考回答</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><table><thead><tr><th></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>重量级锁</td><td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td></tr><tr><td>轻量级锁</td><td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td></tr><tr><td>偏向锁</td><td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td></tr></tbody></table><p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p><h3 id="谈谈-JMM（Java-内存模型）"><a href="#谈谈-JMM（Java-内存模型）" class="headerlink" title="谈谈 JMM（Java 内存模型）"></a>谈谈 JMM（Java 内存模型）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。</p><p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504181638237.png" alt="image-20230504181638237"></p><p>特点：</p><ol><li><p>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</p></li></ol><h3 id="CAS-你知道吗？"><a href="#CAS-你知道吗？" class="headerlink" title="CAS 你知道吗？"></a>CAS 你知道吗？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><h4 id="概述及基本工作流程"><a href="#概述及基本工作流程" class="headerlink" title="概述及基本工作流程"></a>概述及基本工作流程</h4><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p><p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p><ul><li><p>AbstractQueuedSynchronizer（AQS框架）</p></li><li><p>AtomicXXX类</p></li></ul><p>例子：</p><p>我们还是基于刚才学习过的JMM内存模型进行说明</p><ul><li>线程1与线程2都从主内存中获取变量int a &#x3D; 100,同时放到各个线程的工作内存中</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504181947319.png" alt="image-20230504181947319"></p><blockquote><p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p></blockquote><ul><li>线程1操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 101 (a++)<ul><li>线程1拿A的值与主内存V的值进行比较，判断是否相等</li><li>如果相等，则把B的值101更新到主内存中</li></ul></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504182129820.png" alt="image-20230504182129820"></p><ul><li>线程2操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 99(a–)<ul><li>线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值99)</li><li>不相等，则线程2更新失败</li></ul></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504181827330.png" alt="image-20230504181827330"></p><ul><li><p>自旋锁操作</p><ul><li><p>因为没有加锁，所以线程不会陷入阻塞，效率较高</p></li><li><p>如果竞争激烈，重试频繁发生，效率会受影响</p></li></ul></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504182447552.png" alt="image-20230504182447552"></p><p>需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功</p><h4 id="CAS-底层实现"><a href="#CAS-底层实现" class="headerlink" title="CAS 底层实现"></a>CAS 底层实现</h4><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504182737931.png" alt="image-20230504182737931"></p><p>都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504182838426.png" alt="image-20230504182838426"></p><p>在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法</p><ul><li>ReentrantLock中的一段CAS代码</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230504182958703.png" alt="image-20230504182958703"></p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul><li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p></li><li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p></li></ul><h3 id="请谈谈你对-volatile-的理解"><a href="#请谈谈你对-volatile-的理解" class="headerlink" title="请谈谈你对 volatile 的理解"></a>请谈谈你对 volatile 的理解</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><h4 id="保证线程间的可见性"><a href="#保证线程间的可见性" class="headerlink" title="保证线程间的可见性"></a>保证线程间的可见性</h4><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p><p>一个典型的例子：永不停止的循环</p><pre><code class="java">package com.itheima.basic;


// 可见性例子
// -Xint
public class ForeverLoop &#123;
    static boolean stop = false;

    public static void main(String[] args) &#123;
        new Thread(() -&gt; &#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            stop = true;
            System.out.println(&quot;modify stop to true...&quot;);
        &#125;).start();
        foo();
    &#125;

    static void foo() &#123;
        int i = 0;
        while (!stop) &#123;
            i++;
        &#125;
        System.out.println(&quot;stopped... c:&quot;+ i);
    &#125;
&#125;
</code></pre><p>当执行上述代码的时候，发现foo()方法中的循环是结束不了的，也就说读取不到共享变量的值结束循环。</p><p>主要是因为在JVM虚拟机中有一个JIT（即时编辑器）给代码做了优化。</p><blockquote><p>上述代码</p><pre><code class="java">while (!stop) &#123;
i++;
&#125;
</code></pre><p>在很短的时间内，这个代码执行的次数太多了，当达到了一个阈值，JIT就会优化此代码，如下：</p><pre><code class="java">while (true) &#123;
i++;
&#125;
</code></pre><p>当把代码优化成这样子以后，及时<code>stop</code>变量改变为了<code>false</code>也依然停止不了循环</p></blockquote><p>解决方案：</p><p>第一：</p><p>在程序运行的时候加入vm参数<code>-Xint</code>表示禁用即时编辑器，不推荐，得不偿失（其他程序还要使用）</p><p>第二：</p><p>在修饰<code>stop</code>变量的时候加上<code>volatile</code>,表示当前代码禁用了即时编辑器，问题就可以解决，代码如下：</p><pre><code class="java">static volatile boolean stop = false;
</code></pre><h4 id="禁止进行指令重排序"><a href="#禁止进行指令重排序" class="headerlink" title="禁止进行指令重排序"></a>禁止进行指令重排序</h4><p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505082441116.png" alt="image-20230505082441116"></p><p>在去获取上面的结果的时候，有可能会出现4种情况</p><p>情况一：先执行actor2获取结果—&gt;0,0(正常)</p><p>情况二：先执行actor1中的第一行代码，然后执行actor2获取结果—&gt;0,1(正常)</p><p>情况三：先执行actor1中所有代码，然后执行actor2获取结果—&gt;1,1(正常)</p><p>情况四：先执行actor1中第二行代码，然后执行actor2获取结果—&gt;1,0(发生了指令重排序，影响结果)</p><p><strong>解决方案</strong></p><p>在变量上添加volatile，禁止指令重排序，则可以解决问题</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505082835588.png" alt="image-20230505082835588"></p><p>屏障添加的示意图</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505082923729.png" alt="image-20230505082923729"></p><ul><li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li><li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li></ul><p><strong>其他补充</strong></p><p>我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？</p><p>下面代码使用volatile修饰了x变量</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505083124159.png" alt="image-20230505083124159"></p><p>屏障添加的示意图</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505083217904.png" alt="image-20230505083217904"></p><p>这样显然是不行的，主要是因为下面两个原则：</p><ul><li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li><li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li></ul><p>所以，现在我们就可以总结一个volatile使用的小妙招：</p><ul><li>写变量让volatile修饰的变量的在代码最后位置</li><li>读变量让volatile修饰的变量的在代码最开始位置</li></ul><h3 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p><p>AQS与Synchronized的区别</p><table><thead><tr><th><strong>synchronized</strong></th><th><strong>AQS</strong></th></tr></thead><tbody><tr><td>关键字，c++ 语言实现</td><td>java 语言实现</td></tr><tr><td>悲观锁，自动释放锁</td><td>悲观锁，手动开启和关闭</td></tr><tr><td>锁竞争激烈都是重量级锁，性能差</td><td>锁竞争激烈的情况下，提供了多种解决方案</td></tr></tbody></table><p>AQS常见的实现类</p><ul><li><p>ReentrantLock 阻塞式锁</p></li><li><p>Semaphore 信号量</p></li><li><p>CountDownLatch 倒计时锁</p></li></ul><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ul><li>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505083840046.png" alt="image-20230505083840046"></p><blockquote><ul><li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功</li><li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待，</li><li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li></ul></blockquote><p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505084451193.png" alt="image-20230505084451193"></p><p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p><p><strong>AQS是公平锁吗，还是非公平锁？</strong></p><ul><li><p>新的线程与队列中的线程共同来抢资源，是非公平锁</p></li><li><p>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</p></li></ul><blockquote><p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p></blockquote><h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p><ul><li><p>可中断</p></li><li><p>可以设置超时时间</p></li><li><p>可以设置公平锁</p></li><li><p>支持多个条件变量</p></li><li><p>与synchronized一样，都支持重入</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505091736569.png" alt="image-20230505091736569"></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p><p>查看ReentrantLock源码中的构造方法：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505091827720.png" alt="image-20230505091827720"></p><p>提供了两个构造方法，不带参数的默认为非公平</p><p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p><p>其中NonfairSync和FairSync这两个类父类都是Sync</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505092151244.png" alt="image-20230505092151244"></p><p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505091833629.png" alt="image-20230505091833629"></p><p><strong>工作流程</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505092340431.png" alt="image-20230505092340431"></p><ul><li><p>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</p></li><li><p>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</p></li><li><p>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</p></li><li><p>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</p></li></ul><h3 id="synchronized和Lock有什么区别"><a href="#synchronized和Lock有什么区别" class="headerlink" title="synchronized和Lock有什么区别 ?"></a>synchronized和Lock有什么区别 ?</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>参考回答</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><h3 id="死锁产生的条件是什么？"><a href="#死锁产生的条件是什么？" class="headerlink" title="死锁产生的条件是什么？"></a>死锁产生的条件是什么？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p><blockquote><p>例如：</p><p>t1 线程获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程获得B对象锁，接下来想获取A对象的锁</p></blockquote><p>代码如下：</p><pre><code class="java">package com.itheima.basic;

import static java.lang.Thread.sleep;

public class Deadlock &#123;

    public static void main(String[] args) &#123;
        Object A = new Object();
        Object B = new Object();
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (A) &#123;
                System.out.println(&quot;lock A&quot;);
                try &#123;
                    sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                synchronized (B) &#123;
                    System.out.println(&quot;lock B&quot;);
                    System.out.println(&quot;操作...&quot;);
                &#125;
            &#125;
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (B) &#123;
                System.out.println(&quot;lock B&quot;);
                try &#123;
                    sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                synchronized (A) &#123;
                    System.out.println(&quot;lock A&quot;);
                    System.out.println(&quot;操作...&quot;);
                &#125;
            &#125;
        &#125;, &quot;t2&quot;);
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre><p>控制台输出结果</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220902171032898.png" alt="image-20220902171032898"></p><p>此时程序并没有结束，这种现象就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p><h3 id="如何进行死锁诊断？"><a href="#如何进行死锁诊断？" class="headerlink" title="如何进行死锁诊断？"></a>如何进行死锁诊断？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p><p>步骤如下：</p><p>第一：查看运行的线程</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220902171426738.png" alt="image-20220902171426738"></p><p>第二：使用jstack查看线程运行的情况，下图是截图的关键信息</p><p>运行命令：<code>jstack -l 46032</code></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220902172229567.png" alt="image-20220902172229567"></p><p><strong>其他解决工具，可视化工具</strong></p><ul><li>jconsole</li></ul><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><ul><li>VisualVM：故障处理工具</li></ul><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>ConcurrentHashMap 是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li><p>JDK1.7底层采用分段的数组+链表实现</p></li><li><p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</p></li></ul><h4 id="（1）-JDK1-7中concurrentHashMap"><a href="#（1）-JDK1-7中concurrentHashMap" class="headerlink" title="（1） JDK1.7中concurrentHashMap"></a>（1） JDK1.7中concurrentHashMap</h4><p>数据结构</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505092654811.png" alt="image-20230505092654811"></p><blockquote><ul><li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li><li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li><li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li></ul></blockquote><p>存储流程</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505093055382.png" alt="image-20230505093055382"></p><ul><li>先去计算key的hash值，然后确定segment数组下标</li><li>再通过hash值确定hashEntry数组中的下标存储数据</li><li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li></ul><h4 id="（2）-JDK1-8中concurrentHashMap"><a href="#（2）-JDK1-8中concurrentHashMap" class="headerlink" title="（2） JDK1.8中concurrentHashMap"></a>（2） JDK1.8中concurrentHashMap</h4><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p><p>采用 CAS + Synchronized来保证并发安全进行实现</p><ul><li><p>CAS控制数组节点的添加</p></li><li><p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505093507265.png" alt="image-20230505093507265"></p><h3 id="导致并发程序出现问题的根本原因是什么"><a href="#导致并发程序出现问题的根本原因是什么" class="headerlink" title="导致并发程序出现问题的根本原因是什么"></a>导致并发程序出现问题的根本原因是什么</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>Java并发编程三大特性</p><ul><li><p>原子性</p></li><li><p>可见性</p></li><li><p>有序性</p></li></ul><h4 id="（1）原子性"><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h4><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p><p>比如，如下代码能保证原子性吗？</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505205200628.png" alt="image-20230505205200628"></p><p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p><p>解决方案：</p><p>1.synchronized：同步加锁</p><p>2.JUC里面的lock：加锁</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505210853493.png" alt="image-20230505210853493"></p><h4 id="（3）内存可见性"><a href="#（3）内存可见性" class="headerlink" title="（3）内存可见性"></a>（3）内存可见性</h4><p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p><p>比如，以下代码不能保证内存可见性</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505211002252.png" alt="image-20230505211002252"></p><p>解决方案：</p><ul><li><p>synchronized</p></li><li><p>volatile（推荐）</p></li><li><p>LOCK</p></li></ul><h4 id="（3）有序性"><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h4><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p><p>还是之前的例子，如下代码：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505211209336.png" alt="image-20230505211209336"></p><p>解决方案：</p><ul><li>volatile</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="说一下线程池的核心参数（线程池的执行原理知道嘛）"><a href="#说一下线程池的核心参数（线程池的执行原理知道嘛）" class="headerlink" title="说一下线程池的核心参数（线程池的执行原理知道嘛）"></a>说一下线程池的核心参数（线程池的执行原理知道嘛）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505220514872.png" alt="image-20230505220514872"></p><ul><li><p>corePoolSize 核心线程数目</p></li><li><p>maximumPoolSize 最大线程数目 &#x3D; (核心线程+救急线程的最大数目)</p></li><li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p></li><li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p></li><li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p></li><li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p></li><li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p></li></ul><p><strong>工作流程</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505220701835.png" alt="image-20230505220701835"></p><blockquote><p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p><p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p><p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p><p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p><p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p></blockquote><p>拒绝策略：</p><p>1.AbortPolicy：直接抛出异常，默认策略；</p><p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p><p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p><p>4.DiscardPolicy：直接丢弃任务；</p><p>参考代码：</p><pre><code class="java">public class TestThreadPoolExecutor &#123;

    static class MyTask implements Runnable &#123;
        private final String name;
        private final long duration;

        public MyTask(String name) &#123;
            this(name, 0);
        &#125;

        public MyTask(String name, long duration) &#123;
            this.name = name;
            this.duration = duration;
        &#125;

        @Override
        public void run() &#123;
            try &#123;
                LoggerUtils.get(&quot;myThread&quot;).debug(&quot;running...&quot; + this);
                Thread.sleep(duration);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;MyTask(&quot; + name + &quot;)&quot;;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        AtomicInteger c = new AtomicInteger(1);
        ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(2);
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
                2,
                3,
                0,
                TimeUnit.MILLISECONDS,
                queue,
                r -&gt; new Thread(r, &quot;myThread&quot; + c.getAndIncrement()),
                new ThreadPoolExecutor.AbortPolicy());
        showState(queue, threadPool);
        threadPool.submit(new MyTask(&quot;1&quot;, 3600000));
        showState(queue, threadPool);
        threadPool.submit(new MyTask(&quot;2&quot;, 3600000));
        showState(queue, threadPool);
        threadPool.submit(new MyTask(&quot;3&quot;));
        showState(queue, threadPool);
        threadPool.submit(new MyTask(&quot;4&quot;));
        showState(queue, threadPool);
        threadPool.submit(new MyTask(&quot;5&quot;,3600000));
        showState(queue, threadPool);
        threadPool.submit(new MyTask(&quot;6&quot;));
        showState(queue, threadPool);
    &#125;

    private static void showState(ArrayBlockingQueue&lt;Runnable&gt; queue, ThreadPoolExecutor threadPool) &#123;
        try &#123;
            Thread.sleep(300);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        List&lt;Object&gt; tasks = new ArrayList&lt;&gt;();
        for (Runnable runnable : queue) &#123;
            try &#123;
                Field callable = FutureTask.class.getDeclaredField(&quot;callable&quot;);
                callable.setAccessible(true);
                Object adapter = callable.get(runnable);
                Class&lt;?&gt; clazz = Class.forName(&quot;java.util.concurrent.Executors$RunnableAdapter&quot;);
                Field task = clazz.getDeclaredField(&quot;task&quot;);
                task.setAccessible(true);
                Object o = task.get(adapter);
                tasks.add(o);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        LoggerUtils.main.debug(&quot;pool size: &#123;&#125;, queue: &#123;&#125;&quot;, threadPool.getPoolSize(), tasks);
    &#125;

&#125;
</code></pre><h3 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p><p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p><p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p><p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p><p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p><p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p><p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p><table><thead><tr><th><strong>LinkedBlockingQueue</strong></th><th><strong>ArrayBlockingQueue</strong></th></tr></thead><tbody><tr><td>默认无界，支持有界</td><td>强制有界</td></tr><tr><td>底层是链表</td><td>底层是数组</td></tr><tr><td>是懒惰的，创建节点的时候添加数据</td><td>提前初始化 Node 数组</td></tr><tr><td>入队会生成新 Node</td><td>Node需要是提前创建好的</td></tr><tr><td>两把锁（头尾）</td><td>一把锁</td></tr></tbody></table><p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p><ul><li>LinkedBlockingQueue读和写各有一把锁，性能相对较好</li><li>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505221424359.png" alt="image-20230505221424359"></p><h3 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p><ul><li>IO密集型任务</li></ul><p>一般来说：文件读写、DB读写、网络请求等</p><p>推荐：核心线程数大小设置为2N+1 （N为计算机的CPU核数）</p><ul><li>CPU密集型任务</li></ul><p>一般来说：计算型代码、Bitmap转换、Gson转换等</p><p>推荐：核心线程数大小设置为N+1 （N为计算机的CPU核数）</p><p>java代码查看CPU核数</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505221837189.png" alt="image-20230505221837189"></p><p><strong>参考回答：</strong></p><p>① 高并发、任务执行时间短 –&gt;（ CPU核数+1 ），减少线程上下文的切换</p><p>② 并发不高、任务执行时间长</p><ul><li><p>IO密集型的任务 –&gt; (CPU核数 * 2 + 1)</p></li><li><p>计算密集型任务 –&gt; （ CPU核数+1 ）</p></li></ul><p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）</p><h3 id="线程池的种类有哪些"><a href="#线程池的种类有哪些" class="headerlink" title="线程池的种类有哪些"></a>线程池的种类有哪些</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p><ol><li><p>创建使用固定线程数的线程池</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505221959259.png" alt="image-20230505221959259"></p><ul><li><p>核心线程数与最大线程数一样，没有救急线程</p></li><li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li><p>适用场景：适用于任务量已知，相对耗时的任务</p></li><li><p>案例：</p><pre><code class="java">public class FixedThreadPoolCase &#123;

    static class FixedThreadDemo implements Runnable&#123;
        @Override
        public void run() &#123;
            String name = Thread.currentThread().getName();
            for (int i = 0; i &lt; 2; i++) &#123;
                System.out.println(name + &quot;:&quot; + i);
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个固定大小的线程池，核心线程数和最大线程数都是3
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        for (int i = 0; i &lt; 5; i++) &#123;
            executorService.submit(new FixedThreadDemo());
            Thread.sleep(10);
        &#125;

        executorService.shutdown();
    &#125;

&#125;
</code></pre></li></ul></li><li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505222050294.png" alt="image-20230505222050294"></p><ul><li><p>核心线程数和最大线程数都是1</p></li><li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li><p>适用场景：适用于按照顺序执行的任务</p></li><li><p>案例：</p><pre><code class="java">public class NewSingleThreadCase &#123;

    static int count = 0;

    static class Demo implements Runnable &#123;
        @Override
        public void run() &#123;
            count++;
            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + count);
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        //单个线程池，核心线程数和最大线程数都是1
        ExecutorService exec = Executors.newSingleThreadExecutor();

        for (int i = 0; i &lt; 10; i++) &#123;
            exec.execute(new Demo());
            Thread.sleep(5);
        &#125;
        exec.shutdown();
    &#125;

&#125;
</code></pre></li></ul></li><li><p>可缓存线程池</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505222126391.png" alt="image-20230505222126391"></p><ul><li><p>核心线程数为0</p></li><li><p>最大线程数是Integer.MAX_VALUE</p></li><li><p>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p></li><li><p>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</p></li><li><p>案例：</p><pre><code class="java">public class CachedThreadPoolCase &#123;

    static class Demo implements Runnable &#123;
        @Override
        public void run() &#123;
            String name = Thread.currentThread().getName();
            try &#123;
                //修改睡眠时间，模拟线程执行需要花费的时间
                Thread.sleep(100);

                System.out.println(name + &quot;执行完了&quot;);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE
        ExecutorService exec = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 10; i++) &#123;
            exec.execute(new Demo());
            Thread.sleep(1);
        &#125;
        exec.shutdown();
    &#125;

&#125;
</code></pre></li></ul></li><li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505222203615.png" alt="image-20230505222203615"></p><ul><li><p>适用场景：有定时和延迟执行的任务</p></li><li><p>案例：</p><pre><code class="java">public class ScheduledThreadPoolCase &#123;

    static class Task implements Runnable &#123;
        @Override
        public void run() &#123;
            try &#123;
                String name = Thread.currentThread().getName();

                System.out.println(name + &quot;, 开始：&quot; + new Date());
                Thread.sleep(1000);
                System.out.println(name + &quot;, 结束：&quot; + new Date());

            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        //按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2);
        System.out.println(&quot;程序开始：&quot; + new Date());

        /**
         * schedule 提交任务到线程池中
         * 第一个参数：提交的任务
         * 第二个参数：任务执行的延迟时间
         * 第三个参数：时间单位
         */
        scheduledThreadPool.schedule(new Task(), 0, TimeUnit.SECONDS);
        scheduledThreadPool.schedule(new Task(), 1, TimeUnit.SECONDS);
        scheduledThreadPool.schedule(new Task(), 5, TimeUnit.SECONDS);

        Thread.sleep(5000);

        // 关闭线程池
        scheduledThreadPool.shutdown();

    &#125;

&#125;
</code></pre></li></ul></li></ol><h3 id="为什么不建议用Executors创建线程池"><a href="#为什么不建议用Executors创建线程池" class="headerlink" title="为什么不建议用Executors创建线程池"></a>为什么不建议用Executors创建线程池</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>参考阿里开发手册《Java开发手册-嵩山版》</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220821003816845.png" alt="image-20220821003816845"></p><h2 id="线程使用场景问题"><a href="#线程使用场景问题" class="headerlink" title="线程使用场景问题"></a>线程使用场景问题</h2><h3 id="线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"><a href="#线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）" class="headerlink" title="线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"></a>线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p><ul><li><p>其中构造参数用来初始化等待计数值</p></li><li><p>await() 用来等待计数归零</p></li><li><p>countDown() 用来让计数减一</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505223014946.png" alt="image-20230505223014946"></p><p>案例代码：</p><pre><code class="java">public class CountDownLatchDemo &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        //初始化了一个倒计时锁 参数为 3
        CountDownLatch latch = new CountDownLatch(3);

        new Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName()+&quot;-begin...&quot;);
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //count--
            latch.countDown();
            System.out.println(Thread.currentThread().getName()+&quot;-end...&quot; +latch.getCount());
        &#125;).start();
        new Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName()+&quot;-begin...&quot;);
            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //count--
            latch.countDown();
            System.out.println(Thread.currentThread().getName()+&quot;-end...&quot; +latch.getCount());
        &#125;).start();
        new Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName()+&quot;-begin...&quot;);
            try &#123;
                Thread.sleep(1500);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            //count--
            latch.countDown();
            System.out.println(Thread.currentThread().getName()+&quot;-end...&quot; +latch.getCount());
        &#125;).start();
        String name = Thread.currentThread().getName();
        System.out.println(name + &quot;-waiting...&quot;);
        //等待其他线程完成
        latch.await();
        System.out.println(name + &quot;-wait end...&quot;);
    &#125;
    
&#125;
</code></pre><h4 id="案例一（es数据批量导入）"><a href="#案例一（es数据批量导入）" class="headerlink" title="案例一（es数据批量导入）"></a>案例一（es数据批量导入）</h4><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p><p>整体流程就是通过CountDownLatch+线程池配合去执行</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505223219951.png" alt="image-20230505223219951"></p><p>详细实现流程：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505223246059.png" alt="image-20230505223246059"></p><blockquote><p>详细实现代码，请查看当天代码</p></blockquote><h4 id="案例二（数据汇总）"><a href="#案例二（数据汇总）" class="headerlink" title="案例二（数据汇总）"></a>案例二（数据汇总）</h4><p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505223442924.png" alt="image-20230505223442924"></p><blockquote><p>详细实现代码，请查看当天代码</p></blockquote><ul><li><p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p></li><li><p>报表汇总</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505223536657.png" alt="image-20230505223536657"></p></li></ul><h4 id="案例二（异步调用）"><a href="#案例二（异步调用）" class="headerlink" title="案例二（异步调用）"></a>案例二（异步调用）</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505223640038.png" alt="image-20230505223640038"></p><p>在进行搜索的时候，需要保存用户的搜索记录，而搜索记录不能影响用户的正常搜索，我们通常会开启一个线程去执行历史记录的保存，在新开启的线程在执行的过程中，可以利用线程提交任务</p><h3 id="如何控制某个方法允许并发访问线程的数量？"><a href="#如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="如何控制某个方法允许并发访问线程的数量？"></a>如何控制某个方法允许并发访问线程的数量？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制执行的线程数量，达到限流的效果</p><p>当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。</p><p>Semaphore两个重要的方法</p><p>lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p><p>lsemaphore.release()：释放一个信号量，此时信号量个数+1</p><p>线程任务类：</p><pre><code class="java">public class SemaphoreCase &#123;
    public static void main(String[] args) &#123;
        // 1. 创建 semaphore 对象
        Semaphore semaphore = new Semaphore(3);
        // 2. 10个线程同时运行
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(() -&gt; &#123;

                try &#123;
                    // 3. 获取许可
                    semaphore.acquire();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                try &#123;
                    System.out.println(&quot;running...&quot;);
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    System.out.println(&quot;end...&quot;);
                &#125; finally &#123;
                    // 4. 释放许可
                    semaphore.release();
                &#125;
            &#125;).start();
        &#125;
    &#125;

&#125;
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="谈谈你对ThreadLocal的理解"><a href="#谈谈你对ThreadLocal的理解" class="headerlink" title="谈谈你对ThreadLocal的理解"></a>谈谈你对ThreadLocal的理解</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p><p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224057228.png" alt="image-20230505224057228"></p><h4 id="ThreadLocal基本使用"><a href="#ThreadLocal基本使用" class="headerlink" title="ThreadLocal基本使用"></a>ThreadLocal基本使用</h4><p>三个主要方法：</p><ul><li><p>set(value) 设置值</p></li><li><p>get() 获取值</p></li><li><p>remove() 清除值</p></li></ul><pre><code class="java">public class ThreadLocalTest &#123;
    static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void main(String[] args) &#123;
        new Thread(() -&gt; &#123;
            String name = Thread.currentThread().getName();
            threadLocal.set(&quot;itcast&quot;);
            print(name);
            System.out.println(name + &quot;-after remove : &quot; + threadLocal.get());
        &#125;, &quot;t1&quot;).start();
        new Thread(() -&gt; &#123;
            String name = Thread.currentThread().getName();
            threadLocal.set(&quot;itheima&quot;);
            print(name);
            System.out.println(name + &quot;-after remove : &quot; + threadLocal.get());
        &#125;, &quot;t2&quot;).start();
    &#125;

    static void print(String str) &#123;
        //打印当前线程中本地内存中本地变量的值
        System.out.println(str + &quot; :&quot; + threadLocal.get());
        //清除本地内存中的本地变量
        threadLocal.remove();
    &#125;

&#125;
</code></pre><h4 id="ThreadLocal的实现原理-源码解析"><a href="#ThreadLocal的实现原理-源码解析" class="headerlink" title="ThreadLocal的实现原理&amp;源码解析"></a>ThreadLocal的实现原理&amp;源码解析</h4><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224341410.png" alt="image-20230505224341410"></p><p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p><p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p><p><strong>set方法</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224626253.png" alt="image-20230505224626253"></p><p><strong>get方法&#x2F;remove方法</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224715087.png" alt="image-20230505224715087"></p><h4 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal-内存泄露问题"></a>ThreadLocal-内存泄露问题</h4><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p><ul><li>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224755797.png" alt="image-20230505224755797"></p><ul><li>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224812015.png" alt="image-20230505224812015"></p><p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230505224857538.png" alt="image-20230505224857538"></p><p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p><blockquote><p>看完此文章可以看<a href="interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98">多线程相关面试题</a>测试一下自己掌握情况</p></blockquote><ul><li>本文引自<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=">黑马程序员Java面试宝典</span></li></ul><div class="tags"><a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="ic i-tag"></i> Java基础</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-15 19:49:30" itemprop="dateModified" datetime="2023-08-15T19:49:30+08:00">2023-08-15</time> </span><span id="java/JUC详解/" class="item leancloud_visitors" data-flag-title="JUC详解" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/weipay.png" alt="anoxia 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="anoxia 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>anoxia <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://anoxiahub.github.io/java/JUC%E8%AF%A6%E8%A7%A3/" title="JUC详解">https://anoxiahub.github.io/java/JUC详解/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.educba.com&#x2F;academy&#x2F;wp-content&#x2F;uploads&#x2F;2019&#x2F;04&#x2F;What-is-JVM.jpg" title="JVM详解"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>JVM详解</h3></a></div><div class="item right"><a href="/interview/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;pic2.zhimg.com&#x2F;v2-40c195cc69b70c40abcaf4b51aee22ac_720w.jpg?source&#x3D;172ae18b" title="常见技术场景"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 面经</span><h3>常见技术场景</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">线程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">创建线程的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">runnable 和 callable 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">线程的 run()和 start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">1.6.</span> <span class="toc-text">线程包括哪些状态，状态之间是如何变化的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">notify()和 notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-java-%E4%B8%AD-wait-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">在 java 中 wait 和 sleep 方法的不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">如何停止一个正在运行的线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">线程中并发锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">讲一下synchronized关键字的底层原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monitor"><span class="toc-number">2.1.2.</span> <span class="toc-text">Monitor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E8%BF%9B%E9%98%B6"><span class="toc-number">2.2.</span> <span class="toc-text">synchronized关键字的底层原理-进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">对象的内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MarkWord"><span class="toc-number">2.2.2.</span> <span class="toc-text">MarkWord</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E8%AF%B4Monitor%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">再说Monitor重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.2.5.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94"><span class="toc-number">2.2.6.</span> <span class="toc-text">参考回答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-JMM%EF%BC%88Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">谈谈 JMM（Java 内存模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">CAS 你知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">概述及基本工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">CAS 底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.4.3.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-volatile-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.</span> <span class="toc-text">请谈谈你对 volatile 的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.5.1.</span> <span class="toc-text">保证线程间的可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E8%BF%9B%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">禁止进行指令重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">什么是AQS？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.2.</span> <span class="toc-text">工作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">ReentrantLock的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">synchronized和Lock有什么区别 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">死锁产生的条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%AD%BB%E9%94%81%E8%AF%8A%E6%96%AD%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">如何进行死锁诊断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">2.11.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-JDK1-7%E4%B8%ADconcurrentHashMap"><span class="toc-number">2.11.1.</span> <span class="toc-text">（1） JDK1.7中concurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-JDK1-8%E4%B8%ADconcurrentHashMap"><span class="toc-number">2.11.2.</span> <span class="toc-text">（2） JDK1.8中concurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.12.</span> <span class="toc-text">导致并发程序出现问题的根本原因是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">2.12.1.</span> <span class="toc-text">（1）原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.12.2.</span> <span class="toc-text">（3）内存可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">2.12.3.</span> <span class="toc-text">（3）有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%98%9B%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">说一下线程池的核心参数（线程池的执行原理知道嘛）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">线程池中有哪些常见的阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">如何确定核心线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.4.</span> <span class="toc-text">线程池的种类有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.5.</span> <span class="toc-text">为什么不建议用Executors创建线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">线程使用场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AFCountDownLatch%E3%80%81Future%EF%BC%88%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">4.1.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%88es%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">案例一（es数据批量导入）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%88%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB%EF%BC%89"><span class="toc-number">4.1.3.</span> <span class="toc-text">案例二（数据汇总）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%88%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">4.1.4.</span> <span class="toc-text">案例二（异步调用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">如何控制某个方法允许并发访问线程的数量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">谈谈你对ThreadLocal的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">ThreadLocal基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.3.</span> <span class="toc-text">ThreadLocal的实现原理&amp;源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.4.</span> <span class="toc-text">ThreadLocal-内存泄露问题</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="JUC详解">JUC详解</a></li><li><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="JVM详解">JVM详解</a></li><li><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="Java集合详解">Java集合详解</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="anoxia" data-src="/images/avatar.webp"><p class="name" itemprop="name">anoxia</p><div class="description" itemprop="description">anoxia的后端博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">18</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbjB5dWFu" title="https:&#x2F;&#x2F;github.com&#x2F;lin0yuan"><i class="ic i-github"></i></span> <a href="/3102691553@qq.com" title="3102691553@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/interview/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="关于缓存读写一致问题">关于缓存读写一致问题</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/HTTP%E5%92%8CWebsocket%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" title="HTTP和Websocket的前世今生">HTTP和Websocket的前世今生</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" title="项目常见问题">项目常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Spring相关面试题">Spring相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程相关面试题">多线程相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Mysql相关面试题">Mysql相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/special/" title="分类于 专项练习">专项练习</a></div><span><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" title="Redis专项题库-个人练习">Redis专项题库-个人练习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F/" title="缓存三兄弟">缓存三兄弟</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" title="JVM详解">JVM详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题">Java集合相关面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">anoxia @ 智慧笔记</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">129k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:57</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/JUC详解/",favicon:{show:"智慧笔记",hide:"别走嘛QwQ"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->