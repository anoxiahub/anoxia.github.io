<!-- build time: Thu Aug 24 2023 18:26:23 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://anoxiahub.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://anoxiahub.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://anoxiahub.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Java基础"><link rel="canonical" href="https://anoxiahub.github.io/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"><title>Java集合详解 - Java | 智慧笔记 = = 欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java集合详解</h1><div class="meta"><span class="item" title="创建时间：2023-08-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-15T00:00:00+08:00">2023-08-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>16k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">智慧笔记</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://tse2-mm.cn.bing.net/th?id=OIF-C.pQC%2f%2bz1xUb68eiBudruUWA&w=327&h=161&c=7&r=0&o=5&dpr=1.3&pid=1.7"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anoxiahub.github.io/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="anoxia"><meta itemprop="description" content="欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸, anoxia的后端博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次课程主要涉及到的是List和Map相关的面试题，比较高频就是</p><ul><li><p>ArrayList</p></li><li><p>LinkedList</p></li><li><p>HashMap</p></li><li><p>ConcurrentHashMap</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427162524322.png"></p><ul><li>ArrayList底层实现是数组</li><li>LinkedList底层实现是双向链表</li><li>HashMap的底层实现使用了众多数据结构，包含了数组、链表、散列表、红黑树等</li></ul><p>在讲解这些集合之后，我们会讲解数据结构，知道了数据结构的特点之后，熟悉集合就更加简单了。在讲解数据结构之前，我们也会简单普及一下算法复杂度分析，让大家能够评判代码的好坏，也能更加深入去理解数据结构和集合。</p><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h3><p>我们先来看下面这个代码，你能评判这个代码的好坏吗？</p><pre><code class="java">/**
 ** *求**1~n**的累加和
 ** @param* *n
 ** @return
*/
public int sum(int n) &#123;
   int sum = 0;
   for ( int i = 1; i &lt;= n; i++) &#123;
     sum = sum + i;
   &#125;
   return sum;
&#125;
</code></pre><p>其实学习算法复杂度的好处就是：</p><ul><li><p>指导你编写出性能更优的代码</p></li><li><p>评判别人写的代码的好坏</p></li></ul><blockquote><p>相信你学完了算法复杂度分析，就有能力评判上面代码的好坏了</p></blockquote><p>关于算法复杂度分析，包含了两个内容，一个是时间复杂度，一个是空间复杂度，通常情况下说复杂度，都是指时间复杂度，我们也会重点讲解时间复杂度</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>时间复杂度分析：简单来说就是评估代码的执行耗时的，大家还是看刚才的代码：</p><pre><code class="java">/**
 ** *求**1~n**的累加和
 ** @param* *n
 ** @return
*/
public int sum(int n) &#123;
   int sum = 0;
   for ( int i = 1; i &lt;= n; i++) &#123;
     sum = sum + i;
   &#125;
   return sum;
&#125;
</code></pre><p>分析这个代码的时间复杂度，分析过程如下：</p><p>1.假如每行代码的执行耗时一样：1ms</p><p>2.分析这段代码总执行多少行？3n+3</p><p>3.代码耗时总时间： T(n) &#x3D; (3n + 3) * 1ms</p><blockquote><p>T(n):就是代码总耗时</p></blockquote><p>我们现在有了总耗时，需要借助大O表示法来计算这个代码的时间复杂度</p><h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p><strong>大O表示法</strong>：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>。</p><p>刚才的代码示例总耗时公式为：T(n) &#x3D; (3n + 3) * 1ms</p><blockquote><p>其中 (3n + 3) 是代码的总行数，每行执行的时间都一样，所以得出结论：</p><p><strong>T(n)与代码的执行次数成正比(代码行数越多，执行时间越长)</strong></p></blockquote><p>不过，大O表示法只需要代码执行时间与数据规模的增长趋势，公式可以简化如下：</p><p>T(n) &#x3D;O(3n + 3)————&gt; T(n) &#x3D; O(n)</p><blockquote><p>当n很大时，公式中的低阶，常量，系数三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</p></blockquote><p>下图也能表明数据的趋势</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427173120668.png" alt="image-20230427173120668"></p><h4 id="常见复杂度表示形式"><a href="#常见复杂度表示形式" class="headerlink" title="常见复杂度表示形式"></a>常见复杂度表示形式</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427173742389.png" alt="image-20230427173742389"></p><p>速记口诀：<strong>常对幂指阶</strong></p><p>越在上面的性能就越高，越往下性能就越低</p><p>下图是一些比较常见时间复杂度的时间与数据规模的趋势：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427173937663.png" alt="image-20230427173937663"></p><h4 id="时间复杂度O-1"><a href="#时间复杂度O-1" class="headerlink" title="时间复杂度O(1)"></a>时间复杂度O(1)</h4><p>实例代码：</p><pre><code class="java">public int test01(int n)&#123;
    int i=0;
    int j = 1;
    return i+j;
&#125;
</code></pre><p>代码只有三行，它的复杂度也是O(1)，而不是O(3)</p><p>再看如下代码：</p><pre><code class="java">public void test02(int n)&#123;
    int i=0;
    int sum=0;
    for(;i&lt;100;i++)&#123;
        sum = sum+i;
    &#125;
    System.out.println(sum);
&#125;
</code></pre><p>整个代码中因为循环次数是固定的就是100次，这样的代码复杂度我们认为也是O(1)</p><p>一句话总结：<strong>只要代码的执行时间不随着n的增大而增大，这样的代码复杂度都是O(1)</strong></p><h4 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h4><p>实例代码1：</p><pre><code class="java">/**
 * 求1~n的累加和
 * @param n
 * @return
 */
public int sum(int n) &#123;
    int sum = 0;
    for ( int i = 1; i &lt;= n; i++) &#123;
        sum = sum + i;
    &#125;
    return sum;
&#125;
</code></pre><p>一层for循序时间复杂度就是O(n)</p><p>实例代码2：</p><pre><code class="java">public static int sum2(int n)&#123;
    int sum = 0;
    for (int i = 1; i &lt; n; ++i) &#123;
        for (int j = 1; j &lt; n; ++j) &#123;
            sum = sum + i * j;
        &#125;
    &#125;
    return sum;
&#125;
</code></pre><p>这个代码的执行行数为：O( 3n^2 + 3n + 3 )，不过，依据大O表示的规则：<strong>常量、系数、低阶，可以忽略</strong></p><p>所以这个代码最终的时间复杂度为：O(n^2)</p><h4 id="时间复杂度O-logn"><a href="#时间复杂度O-logn" class="headerlink" title="时间复杂度O(logn)"></a>时间复杂度O(logn)</h4><p>对数复杂度非常的常见，但相对比较难以分析，实例代码：</p><pre><code class="java">public void test04(int n)&#123;
    int i=1;
    while(i&lt;=n)&#123;
        i = i * 2;
    &#125;
&#125;
</code></pre><p>分析这个代码的复杂度，我们必须要再强调一个前提：<strong>复杂度分析就是要弄清楚代码的执行次数和数据规模n之间的关系</strong></p><p>以上代码最关键的一行是：<code>i = i * 2</code>，这行代码可以决定这个while循环执行代码的行数，<code>i</code>的值是可以无限接近<code>n</code>的值的。如果<code>i</code> 一旦大于等于了<code>n</code>则循环条件就不满足了。也就说达到了最大的行数。我们可以分析一下<code>i</code>这个值变化的过程</p><p>分析过程如下：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427174832858.png" alt="image-20230427174832858"></p><p>由此可知，代码的时间复杂度表示为O(log n)</p><h4 id="时间复杂度O-n-log-n"><a href="#时间复杂度O-n-log-n" class="headerlink" title="时间复杂度O(n * log n)"></a>时间复杂度O(n * log n)</h4><p>分析完O( log n )，那O( n * log n )就很容易理解了，比如下列代码：</p><pre><code class="java">public void test05(int n)&#123;
    int i=0;
    for(;i&lt;=n;i++)&#123;
        test04(n);
    &#125;
&#125;

public void test04(int n)&#123;
    int i=1;
    while(i&lt;=n)&#123;
        i = i * 2;
    &#125;
&#125;
</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度全称是渐进空间复杂度，表示算法占用的额外<strong>存储空间</strong>与<strong>数据规模</strong>之间的增长关系</p><p>看下面代码</p><pre><code class="java">public void test(int n)&#123;
    int i=0;
    int sum=0;
    for(;i&lt;n;i++)&#123;
        sum = sum+i;
    &#125;
    System.out.println(sum);
&#125;
</code></pre><p>代码执行并不需要占用额外的存储空间，只需要常量级的内存空间大小，因此空间复杂度是O(1)</p><p>再来看一个其他例子：</p><pre><code class="java">void print(int n) &#123;
    int i = 0;
    int[] a = new int[n];
    for (i; i &lt;n; ++i) &#123;
        a[i] = i * i;
    &#125;
    for (i = n-1; i &gt;= 0; --i) &#123;
        System.out.println(a[i]);
    &#125;
&#125;
</code></pre><p>传入一个变量n，决定申请多少的int数组空间内存，此段代码的空间复杂度为O(n)</p><p>我们常见的空间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p><h2 id="List相关面试题"><a href="#List相关面试题" class="headerlink" title="List相关面试题"></a>List相关面试题</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h4><p>数组（Array）是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数据的线性数据结构。</p><pre><code class="java">int[] array = &#123;22,33,88,66,55,25&#125;;
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427175545402.png" alt="image-20230427175545402"></p><p>我们定义了这么一个数组之后，在内存的表示是这样的：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427175633253.png" alt="image-20230427175633253"></p><p>现在假如，我们通过<code>arrar[1]</code>，想要获得下标为1这个元素，但是现在栈内存中指向的堆内存数组的首地址，它是如何获取下标为1这个数据的？</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427175849493.png" alt="image-20230427175849493"></p><h4 id="寻址公式"><a href="#寻址公式" class="headerlink" title="寻址公式"></a>寻址公式</h4><p>为了方便大家理解，我们把数组的内存地址稍微改了一下，都改成了数字，如下图</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427180056509.png" alt="image-20230427180056509"></p><p>在数组在内存中查找元素的时候，是有一个寻址公式的，如下：</p><pre><code class="java">arr[i] = baseAddress + i * dataTypeSize
</code></pre><blockquote><p>baseAddress：数组的首地址，目前是10</p><p>dataTypeSize：代表数组中元素类型的大小，目前数组重存储的是int型的数据，dataTypeSize&#x3D;4个字节</p><p>arr：指的是数组</p><p>i：指的是数组的下标</p></blockquote><p>有了寻址公式以后，我们再来获取一下下标为1的元素，这个是原来的数组</p><pre><code class="java">int[] array = &#123;22,33,88,66,55,25&#125;;
</code></pre><p>套入公式：</p><pre><code class="java">array[1] =10 + i * 4 = 14
</code></pre><p>获取到14这个地址，就能获取到下标为1的这个元素了。</p><h4 id="操作数组的时间复杂度"><a href="#操作数组的时间复杂度" class="headerlink" title="操作数组的时间复杂度"></a>操作数组的时间复杂度</h4><p><strong>1.随机查询(根据索引查询)</strong></p><p>数组元素的访问是通过下标来访问的，计算机通过数组的<strong>首地址</strong>和<strong>寻址公式</strong>能够很快速的找到想要访问的元素</p><pre><code class="java">public int test01(int[] a,int i)&#123;
   return a[i];
   // a[i] = baseAddress + i \* dataSize
&#125;
</code></pre><p>代码的执行次数并不会随着数组的数据规模大小变化而变化，是常数级的，所以查询数据操作的时间复杂度是O(1)</p><p><strong>2. 未知索引查询O(n)或O(log2n)</strong></p><p>情况一：查找数组内的元素，查找55号数据，遍历数组时间复杂度为O(n)</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221007101831281.png" alt="image-20221007101831281"></p><p>情况二：查找排序后数组内的元素，通过二分查找算法查找55号数据时间复杂度为O(logn)</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221007101811885.png" alt="image-20221007101811885"></p><p><strong>3.插入O(n)</strong></p><p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。</p><p>假设数组的长度为 n，现在如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。如下图所示：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220820104903422.png" alt="image-20220820104903422"></p><p>新增之后的数据变化，如下</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220820104950846.png" alt="image-20220820104950846"></p><p>所以：</p><p>插入操作，最好情况下是O(1)的，最坏情况下是O(n)的，**平均情况下的时间复杂度是O(n)**。</p><p><strong>4.删除O(n)</strong></p><p>同理可得：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，时间复杂度仍然是O(n)。</p><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><p>分析ArrayList源码主要从三个方面去翻阅：成员变量，构造函数，关键方法</p><blockquote><p>以下源码都来源于jdk1.8</p></blockquote><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192118259.png" alt="image-20230427192118259"></p><blockquote><p><em>DEFAULT_CAPACITY</em> &#x3D; 10; 默认初始的容量**(CAPACITY)</p><p><em>EMPTY_ELEMENTDATA</em> &#x3D; {}; 用于空实例的共享空数组实例</p><p><em>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</em> &#x3D; {};用于默认大小的空实例的共享空数组实例</p><p>Object[] elementData; 存储元素的数组缓冲区</p><p>int size; ArrayList的大小（它包含的元素数量）</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192154014.png" alt="image-20230427192154014"></p><blockquote><ul><li><p>第一个构造是带初始化容量的构造函数，可以按照指定的容量初始化数组</p></li><li><p>第二个是无参构造函数，默认创建一个空集合</p></li></ul></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192200918.png" alt="image-20230427192200918"></p><blockquote><p>将collection对象转换成数组，然后将数组的地址的赋给elementData</p></blockquote><h4 id="ArrayList源码分析-1"><a href="#ArrayList源码分析-1" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h4><p>添加数据的流程</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192644244.png" alt="image-20230427192644244"></p><p><strong>结论：</strong></p><ul><li>底层数据结构</li></ul><p>ArrayList底层是用动态的数组实现的</p><ul><li>初始容量</li></ul><p>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</p><ul><li>扩容逻辑</li></ul><p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p><ul><li><p>添加逻辑</p><ul><li><p>确保数组已使用长度（size）加1之后足够存下下一个数据</p></li><li><p>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p></li><li><p>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</p></li><li><p>返回添加成功布尔值。</p></li></ul></li></ul><h4 id="面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a>面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h4><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185505677.png" alt="image-20230428185505677"></p><p>参考回答：</p><p>该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容</p><h4 id="面试题-如何实现数组和List之间的转换"><a href="#面试题-如何实现数组和List之间的转换" class="headerlink" title="面试题-如何实现数组和List之间的转换"></a>面试题-如何实现数组和List之间的转换</h4><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆</p></blockquote><p>如下代码：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185600918.png" alt="image-20230428185600918"></p><p>参考回答：</p><ul><li><p>数组转List ，使用JDK中java.util.Arrays工具类的asList方法</p></li><li><p>List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p></li></ul><p>面试官再问：</p><p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p><p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185657791.png" alt="image-20230428185657791"></p><blockquote><p>数组转List受影响</p><p>List转数组不受影响</p></blockquote><p>再答：</p><p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p><p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p><p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p><p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><ul><li><p>链表中的每一个元素称之为结点（Node）</p></li><li><p>物理存储单元上，非连续、非顺序的存储结构</p></li><li><p>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185922776.png" alt="image-20230428185922776"></p><p>代码实现参考：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185945929.png" alt="image-20230428185945929"></p><p>链表中的某个节点为B，B的下一个节点为C 表示： B.next&#x3D;&#x3D;C</p><h4 id="单向链表时间复杂度分析"><a href="#单向链表时间复杂度分析" class="headerlink" title="单向链表时间复杂度分析"></a>单向链表时间复杂度分析</h4><p>（1）查询操作</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190130901.png" alt="image-20230428190130901"></p><ul><li><p>只有在查询头节点的时候不需要遍历链表，时间复杂度是O(1)</p></li><li><p>查询其他结点需要遍历链表，时间复杂度是O(n)</p></li></ul><p>（2）插入和删除操作</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190210915.png" alt="image-20230428190210915"></p><ul><li>只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是O(1)</li><li>添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是O(n)</li></ul><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>而双向链表，顾名思义，它支持两个方向</p><ul><li><p>每个结点不止有一个后继指针 next 指向后面的结点</p></li><li><p>有一个前驱指针 prev 指向前面的结点</p></li></ul><p>参考代码</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190324752.png" alt="image-20230428190324752"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190353286.png" alt="image-20230428190353286"></p><p>对比单链表：</p><ul><li><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</p></li><li><p>支持双向遍历，这样也带来了双向链表操作的灵活性</p></li></ul><h4 id="双向链表时间复杂度分析"><a href="#双向链表时间复杂度分析" class="headerlink" title="双向链表时间复杂度分析"></a>双向链表时间复杂度分析</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190450517.png" alt="image-20230428190450517"></p><p>（1）查询操作</p><ul><li><p>查询头尾结点的时间复杂度是O(1)</p></li><li><p>平均的查询时间复杂度是O(n)</p></li><li><p>给定节点找前驱节点的时间复杂度为O(1)</p></li></ul><p>（2）增删操作</p><ul><li><p>头尾结点增删的时间复杂度为O(1)</p></li><li><p>其他部分结点增删的时间复杂度是 O(n)</p></li><li><p>给定节点增删的时间复杂度为O(1)</p></li></ul><h4 id="面试题-ArrayList和LinkedList的区别是什么？"><a href="#面试题-ArrayList和LinkedList的区别是什么？" class="headerlink" title="面试题-ArrayList和LinkedList的区别是什么？"></a>面试题-ArrayList和LinkedList的区别是什么？</h4><ul><li><p>底层数据结构</p><ul><li><p>ArrayList 是动态数组的数据结构实现</p></li><li><p>LinkedList 是双向链表的数据结构实现</p></li></ul></li><li><p>操作数据效率</p><ul><li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li><li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li><li>新增和删除<ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul></li></ul></li><li><p>内存空间占用</p><ul><li><p>ArrayList底层是数组，内存连续，节省内存</p></li><li><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p></li></ul></li><li><p>线程安全</p><ul><li>ArrayList和LinkedList都不是线程安全的</li><li>如果需要保证线程安全，有两种方案：<ul><li>在方法内使用，局部变量则是线程安全的</li><li>使用线程安全的ArrayList和LinkedList</li></ul></li></ul></li></ul><h2 id="HashMap相关面试题"><a href="#HashMap相关面试题" class="headerlink" title="HashMap相关面试题"></a>HashMap相关面试题</h2><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194715016.png" alt="image-20230428194715016"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树概述"><a href="#二叉树概述" class="headerlink" title="二叉树概述"></a>二叉树概述</h4><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p><p>二叉树每个节点的左子树和右子树也分别满足二叉树的定义。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194831426.png" alt="image-20230428194831426"></p><p>Java中有两个方式实现二叉树：数组存储，链式存储。</p><p>基于链式存储的树的节点可定义如下：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194904383.png" alt="image-20230428194904383"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194931132.png" alt="image-20230428194931132"></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>在二叉树中，比较常见的二叉树有：</p><ul><li><p>满二叉树</p></li><li><p>完全二叉树</p></li><li><p><strong>二叉搜索树</strong></p></li><li><p><strong>红黑树</strong></p></li></ul><p>我们重点讲解二叉搜索树和红黑树</p><p>（1）二叉搜索树概述</p><p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195206422.png" alt="image-20230428195206422"></p><p>（2）二叉搜索树-时间复杂度分析</p><p>实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195341917.png" alt="image-20230428195341917"></p><p>插入，查找，删除的时间复杂度<strong>O(logn)</strong></p><p>极端情况下二叉搜索的时间复杂度</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195449799.png" alt="image-20230428195449799"></p><p>对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是O(n)。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>（1）概述</p><p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195832724.png" alt="image-20230428195832724"></p><p>（2）红黑树的特质</p><p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p><p>性质2：根节点是<strong>黑色</strong></p><p>性质3：叶子节点都是黑色的空节点</p><p>性质4：红黑树中红色节点的子节点都是黑色</p><p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p><p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong></p><p>（3）红黑树的复杂度</p><ul><li><p>查找：</p><ul><li>红黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</li></ul></li><li><p>添加：</p><ul><li>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)</li><li>添加完成后涉及到复杂度为O(1)的旋转调整操作</li><li>故整体复杂度为：O(log n)</li></ul></li><li><p>删除：</p><ul><li>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)</li><li>删除完成后涉及到复杂度为O(1)的旋转调整操作</li><li>故整体复杂度为：O(log n)</li></ul></li></ul><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p><h4 id="散列表（Hash-Table）概述"><a href="#散列表（Hash-Table）概述" class="headerlink" title="散列表（Hash Table）概述"></a>散列表（Hash Table）概述</h4><p>散列表(Hash Table)又名哈希表&#x2F;Hash表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p><p>举个例子：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428200919454.png" alt="image-20230428200919454"></p><p>假设有100个人参加马拉松，编号是1-100，如果要编程实现根据选手的编号迅速找到选手信息？</p><p>可以把选手信息存入数组中，选手编号就是数组的下标，数组的元素就是选手的信息。</p><p>当我们查询选手信息的时候，只需要根据选手的编号到数组中查询对应的元素就可以快速找到选手的信息，如下图：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428201000814.png" alt="image-20230428201000814"></p><p>现在需求升级了：</p><p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428201321607.png" alt="image-20230428201321607"></p><p>我们目前是把选手的信息存入到数组中，不过选手的编号不能直接作为数组的下标，不过，可以把选手的选号进行转换，转换为数值就可以继续作为数组的下标了？</p><p>转换可以使用散列函数进行转换</p><h4 id="散列函数和散列冲突"><a href="#散列函数和散列冲突" class="headerlink" title="散列函数和散列冲突"></a>散列函数和散列冲突</h4><p>将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue &#x3D; hash(key)</p><p>散列函数的基本要求：</p><ul><li><p>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</p></li><li><p>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2）</p></li><li><p><strong>如果key1 !&#x3D; key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></p></li></ul><p>实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突(或者哈希冲突，哈希碰撞，<strong>就是指多个key映射到同一个数组下标位置</strong>)</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203219225.png" alt="image-20230428203219225"></p><h4 id="散列冲突-链表法（拉链）"><a href="#散列冲突-链表法（拉链）" class="headerlink" title="散列冲突-链表法（拉链）"></a>散列冲突-链表法（拉链）</h4><p>在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203437910.png" alt="image-20230428203437910"></p><p>简单就是，如果有多个key最终的hash值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据</p><h4 id="时间复杂度-散列表"><a href="#时间复杂度-散列表" class="headerlink" title="时间复杂度-散列表"></a>时间复杂度-散列表</h4><p>1，插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203711269.png" alt="image-20230428203711269"></p><blockquote><p>通过计算就可以找到元素</p></blockquote><p>2，当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p><ul><li><p>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</p></li><li><p>散列表可能会退化为链表,查询的时间复杂度就从 O(1) 退化为 O(n)</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203858903.png" alt="image-20230428203858903"></p><ul><li>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O(logn)</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203924816.png" alt="image-20230428203924816"></p><p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击</p><blockquote><p>DDos 攻击:</p><p>分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p><p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个</p></blockquote><h3 id="面试题-说一下HashMap的实现原理？"><a href="#面试题-说一下HashMap的实现原理？" class="headerlink" title="面试题-说一下HashMap的实现原理？"></a>面试题-说一下HashMap的实现原理？</h3><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p></li></ol><p>a. 如果key相同，则覆盖原始值；</p><p>b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中</p><ol start="3"><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428204902016.png" alt="image-20230428204902016"></p><p>面试官追问：HashMap的jdk1.7和jdk1.8有什么区别</p><ul><li><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></li><li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</p></li></ul><h3 id="面试题-HashMap的put方法的具体流程"><a href="#面试题-HashMap的put方法的具体流程" class="headerlink" title="面试题-HashMap的put方法的具体流程"></a>面试题-HashMap的put方法的具体流程</h3><h4 id="hashMap常见属性"><a href="#hashMap常见属性" class="headerlink" title="hashMap常见属性"></a>hashMap常见属性</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210404117.png" alt="image-20230428210404117"></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210450744.png" alt="image-20230428210450744"></p><ul><li><p>HashMap是懒惰加载，在创建对象时并没有初始化数组</p></li><li><p>在无参的构造函数中，设置了默认的加载因子是0.75</p></li></ul><p>添加数据流程图</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210624847.png" alt="image-20230428210624847"></p><p>具体的源码：</p><pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    //判断数组是否未初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        //如果未初始化，调用resize方法 进行初始化
        n = (tab = resize()).length;
    //通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        //如果没有，直接将数据放在该下标位置
        tab[i] = newNode(hash, key, value, null);
    //该数组下标有数据的情况
    else &#123;
        Node&lt;K,V&gt; e; K k;
        //判断该位置数据的key和新来的数据是否一样
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            //如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到
            e = p;
        //判断是不是红黑树
        else if (p instanceof TreeNode)
            //如果是红黑树的话，进行红黑树的操作
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        //新数据和当前数组既不相同，也不是红黑树节点，证明是链表
        else &#123;
            //遍历链表
            for (int binCount = 0; ; ++binCount) &#123;
                //判断next节点，如果为空的话，证明遍历到链表尾部了
                if ((e = p.next) == null) &#123;
                    //把新值放入链表尾部
                    p.next = newNode(hash, key, value, null);
                    //因为新插入了一条数据，所以判断链表长度是不是大于等于8
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        //如果是，进行转换红黑树操作
                        treeifyBin(tab, hash);
                    break;
                &#125;
                //判断链表当中有数据相同的值，如果一样，证明为修改操作
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                //把下一个节点赋值为当前节点
                p = e;
            &#125;
        &#125;
        //判断e是否为空（e值为修改操作存放原数据的变量）
        if (e != null) &#123; // existing mapping for key
            //不为空的话证明是修改操作，取出老值
            V oldValue = e.value;
            //一定会执行  onlyIfAbsent传进来的是false
            if (!onlyIfAbsent || oldValue == null)
                //将新值赋值当前节点
                e.value = value;
            afterNodeAccess(e);
            //返回老值
            return oldValue;
        &#125;
    &#125;
    //计数器，计算当前节点的修改次数
    ++modCount;
    //当前数组中的数据数量如果大于扩容阈值
    if (++size &gt; threshold)
        //进行扩容操作
        resize();
    //空方法
    afterNodeInsertion(evict);
    //添加操作时 返回空值
    return null;
&#125;
</code></pre><ol><li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p></li><li><p>根据键值key计算hash值得到数组索引</p></li><li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p></li><li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p><p>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p><p>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p><p>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</p></li></ol><h3 id="面试题-讲一讲HashMap的扩容机制"><a href="#面试题-讲一讲HashMap的扩容机制" class="headerlink" title="面试题-讲一讲HashMap的扩容机制"></a>面试题-讲一讲HashMap的扩容机制</h3><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210844694.png" alt="image-20230428210844694"></p><p>扩容的流程：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428211031968.png" alt="image-20230428211031968"></p><p>源码：</p><pre><code class="java">//扩容、初始化数组
final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        //如果当前数组为null的时候，把oldCap老数组容量设置为0
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //老的扩容阈值
        int oldThr = threshold;
        int newCap, newThr = 0;
        //判断数组容量是否大于0，大于0说明数组已经初始化
        if (oldCap &gt; 0) &#123;
            //判断当前数组长度是否大于最大数组长度
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                //如果是，将扩容阈值直接设置为int类型的最大数值并直接返回
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            //如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2
            //运算过后判断是不是最大值并且oldCap需要大于16
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold  等价于oldThr*2
        &#125;
        //如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       			如果是首次初始化，它的临界值则为0
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        //数组未初始化的情况，将阈值和扩容因子都设置为默认值
        else &#123;               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        //初始化容量小于16的时候，扩容阈值是没有赋值的
        if (newThr == 0) &#123;
            //创建阈值
            float ft = (float)newCap * loadFactor;
            //判断新容量和新阈值是否大于最大容量
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        //计算出来的阈值赋值
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        //根据上边计算得出的容量 创建新的数组       
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        //赋值
        table = newTab;
        //扩容操作，判断不为空证明不是初始化数组
        if (oldTab != null) &#123;
            //遍历数组
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                //判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作
                if ((e = oldTab[j]) != null) &#123;
                    //将数组位置置空
                    oldTab[j] = null;
                    //判断是否有下个节点
                    if (e.next == null)
                        //如果没有，就重新计算在新数组中的下标并放进去
                        newTab[e.hash &amp; (newCap - 1)] = e;
                       //有下个节点的情况，并且判断是否已经树化
                    else if (e instanceof TreeNode)
                        //进行红黑树的操作
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    //有下个节点的情况，并且没有树化（链表形式）
                    else &#123;
                        //比如老数组容量是16，那下标就为0-15
                        //扩容操作*2，容量就变为32，下标为0-31
                        //低位：0-15，高位16-31
                        //定义了四个变量
                        //        低位头          低位尾
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        //        高位头		   高位尾
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        //下个节点
                        Node&lt;K,V&gt; next;
                        //循环遍历
                        do &#123;
                            //取出next节点
                            next = e.next;
                            //通过 与操作 计算得出结果为0
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                //如果低位尾为null，证明当前数组位置为空，没有任何数据
                                if (loTail == null)
                                    //将e值放入低位头
                                    loHead = e;
                                //低位尾不为null，证明已经有数据了
                                else
                                    //将数据放入next节点
                                    loTail.next = e;
                                //记录低位尾数据
                                loTail = e;
                            &#125;
                            //通过 与操作 计算得出结果不为0
                            else &#123;
                                 //如果高位尾为null，证明当前数组位置为空，没有任何数据
                                if (hiTail == null)
                                    //将e值放入高位头
                                    hiHead = e;
                                //高位尾不为null，证明已经有数据了
                                else
                                    //将数据放入next节点
                                    hiTail.next = e;
                               //记录高位尾数据
                                   hiTail = e;
                            &#125;
                            
                        &#125; 
                        //如果e不为空，证明没有到链表尾部，继续执行循环
                        while ((e = next) != null);
                        //低位尾如果记录的有数据，是链表
                        if (loTail != null) &#123;
                            //将下一个元素置空
                            loTail.next = null;
                            //将低位头放入新数组的原下标位置
                            newTab[j] = loHead;
                        &#125;
                        //高位尾如果记录的有数据，是链表
                        if (hiTail != null) &#123;
                            //将下一个元素置空
                            hiTail.next = null;
                            //将高位头放入新数组的(原下标+原数组容量)位置
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        //返回新的数组对象
        return newTab;
    &#125;
</code></pre><ul><li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p></li><li><p>每次扩容的时候，都是扩容之前容量的2倍；</p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p><ul><li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul></li></ul><h3 id="面试题-hashMap的寻址算法"><a href="#面试题-hashMap的寻址算法" class="headerlink" title="面试题-hashMap的寻址算法"></a>面试题-hashMap的寻址算法</h3><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428212501408.png" alt="image-20230428212501408"></p><p>在putVal方法中，有一个hash(key)方法，这个方法就是来去计算key的hash值的，看下面的代码</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428212601977.png" alt="image-20230428212601977"></p><p>首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突</p><p>有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，看下面的代码：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428212729580.png" alt="image-20230428212729580"></p><p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂</p><p><strong>关于hash值的其他面试题：为何HashMap的数组长度一定是2的次幂？</strong></p><ol><li><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p></li><li><p>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</p></li></ol><h3 id="面试题-hashmap在1-7情况下的多线程死循环问题"><a href="#面试题-hashmap在1-7情况下的多线程死循环问题" class="headerlink" title="面试题-hashmap在1.7情况下的多线程死循环问题"></a>面试题-hashmap在1.7情况下的多线程死循环问题</h3><p>jdk7的的数据结构是：数组+链表</p><p>在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428213115071.png" alt="image-20230428213115071"></p><ul><li><p>变量e指向的是需要迁移的对象</p></li><li><p>变量next指向的是下一个需要迁移的对象</p></li><li><p>Jdk1.7中的链表采用的头插法</p></li><li><p>在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用</p></li></ul><p>产生死循环的过程：</p><p>线程1和线程2的变量e和next都引用了这个两个节点</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428213533483.png" alt="image-20230428213533483"></p><p>线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214732877.png" alt="image-20230428214732877"></p><p>第一次循环</p><p>由于线程2迁移的时候，已经把B的next执行了A</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214806072.png" alt="image-20230428214806072"></p><p>第二次循环</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214908652.png" alt="image-20230428214908652"></p><p>第三次循环</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214937231.png" alt="image-20230428214937231"></p><p>参考回答：</p><p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p><p>线程一：继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，</p><p>所以B-&gt;A-&gt;B,形成循环。</p><p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p><h3 id="面试题-HashSet与HashMap的区别"><a href="#面试题-HashSet与HashMap的区别" class="headerlink" title="面试题-HashSet与HashMap的区别"></a>面试题-HashSet与HashMap的区别</h3><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p><p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221007110404375.png" alt="image-20221007110404375"></p><h3 id="面试题-HashTable与HashMap的区别"><a href="#面试题-HashTable与HashMap的区别" class="headerlink" title="面试题-HashTable与HashMap的区别"></a>面试题-HashTable与HashMap的区别</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆</p></blockquote><p>主要区别：</p><table><thead><tr><th><strong>区别</strong></th><th><strong>HashTable</strong></th><th><strong>HashMap</strong></th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>是否可以为null</td><td>Key和value都不能为null</td><td>可以为null</td></tr><tr><td>hash算法</td><td>key的hashCode()</td><td>二次hash</td></tr><tr><td>扩容方式</td><td>当前容量翻倍 +1</td><td>当前容量翻倍</td></tr><tr><td>线程安全</td><td>同步(synchronized)的，线程安全</td><td>非线程安全</td></tr></tbody></table><p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p><blockquote><p>看完此文章可以看<a href="interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98">Java集合相关面试题</a>测试一下自己掌握情况</p></blockquote><ul><li>本文引自<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=">黑马程序员Java面试宝典</span></li></ul><div class="tags"><a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="ic i-tag"></i> Java基础</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-20 21:42:27" itemprop="dateModified" datetime="2023-08-20T21:42:27+08:00">2023-08-20</time> </span><span id="java/Java集合详解/" class="item leancloud_visitors" data-flag-title="Java集合详解" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/weipay.png" alt="anoxia 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="anoxia 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>anoxia <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://anoxiahub.github.io/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">https://anoxiahub.github.io/java/Java集合详解/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic1.zhimg.com&#x2F;v2-c88021da41f8459522d4a4539a0ce1c0_720w.jpg?source&#x3D;172ae18b" title="Java集合相关面试题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 面经</span><h3>Java集合相关面试题</h3></a></div><div class="item right"><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.educba.com&#x2F;academy&#x2F;wp-content&#x2F;uploads&#x2F;2019&#x2F;04&#x2F;What-is-JVM.jpg" title="JVM详解"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>JVM详解</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">算法复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">为什么要进行复杂度分析？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">大O表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">常见复杂度表示形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">时间复杂度O(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n"><span class="toc-number">2.2.5.</span> <span class="toc-text">时间复杂度O(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-logn"><span class="toc-number">2.2.6.</span> <span class="toc-text">时间复杂度O(logn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n-log-n"><span class="toc-number">2.2.7.</span> <span class="toc-text">时间复杂度O(n * log n)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">List相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">数组概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E5%85%AC%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">寻址公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.1.3.</span> <span class="toc-text">操作数组的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">ArrayList源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">ArrayList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-ArrayList-list-new-ArrayList-10-%E4%B8%AD%E7%9A%84list%E6%89%A9%E5%AE%B9%E5%87%A0%E6%AC%A1"><span class="toc-number">3.2.4.</span> <span class="toc-text">面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8CList%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.5.</span> <span class="toc-text">面试题-如何实现数组和List之间的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.3.2.</span> <span class="toc-text">单向链表时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.3.4.</span> <span class="toc-text">双向链表时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">面试题-ArrayList和LinkedList的区别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">HashMap相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">二叉树概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">4.1.2.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">4.1.3.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.</span> <span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash-Table%EF%BC%89%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">散列表（Hash Table）概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">散列函数和散列冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81-%E9%93%BE%E8%A1%A8%E6%B3%95%EF%BC%88%E6%8B%89%E9%93%BE%EF%BC%89"><span class="toc-number">4.2.3.</span> <span class="toc-text">散列冲突-链表法（拉链）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">时间复杂度-散列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AF%B4%E4%B8%80%E4%B8%8BHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">面试题-说一下HashMap的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">面试题-HashMap的put方法的具体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashMap%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.1.</span> <span class="toc-text">hashMap常见属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.4.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">4.5.</span> <span class="toc-text">面试题-讲一讲HashMap的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-hashMap%E7%9A%84%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">面试题-hashMap的寻址算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-hashmap%E5%9C%A81-7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">面试题-hashmap在1.7情况下的多线程死循环问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-HashSet%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">面试题-HashSet与HashMap的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-HashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">面试题-HashTable与HashMap的区别</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="JUC详解">JUC详解</a></li><li><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="JVM详解">JVM详解</a></li><li class="active"><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="Java集合详解">Java集合详解</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="anoxia" data-src="/images/avatar.webp"><p class="name" itemprop="name">anoxia</p><div class="description" itemprop="description">anoxia的后端博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">18</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbjB5dWFu" title="https:&#x2F;&#x2F;github.com&#x2F;lin0yuan"><i class="ic i-github"></i></span> <a href="/3102691553@qq.com" title="3102691553@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Mysql相关面试题">Mysql相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">Java集合详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Redis相关面试题">Redis相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/special/" title="分类于 专项练习">专项练习</a></div><span><a href="/special/Redis%E4%B8%93%E9%A1%B9%E9%A2%98%E5%BA%93/" title="Redis专项题库-个人练习">Redis专项题库-个人练习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题">Java集合相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" title="项目常见问题">项目常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Spring相关面试题">Spring相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" title="JUC详解">JUC详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/Mysql%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/" title="连接数据库遇到问题">连接数据库遇到问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="关于缓存读写一致问题">关于缓存读写一致问题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">anoxia @ 智慧笔记</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">129k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:57</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/Java集合详解/",favicon:{show:"智慧笔记",hide:"别走嘛QwQ"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->