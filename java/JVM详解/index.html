<!-- build time: Wed Aug 16 2023 10:04:15 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://anoxiahub.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://anoxiahub.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://anoxiahub.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="JVM"><link rel="canonical" href="https://anoxiahub.github.io/java/JVM%E8%AF%A6%E8%A7%A3/"><title>JVM详解 - Java | 智慧笔记 = = 欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JVM详解</h1><div class="meta"><span class="item" title="创建时间：2023-08-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-15T00:00:00+08:00">2023-08-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">智慧笔记</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/04/What-is-JVM.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anoxiahub.github.io/java/JVM%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="anoxia"><meta itemprop="description" content="欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸, anoxia的后端博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="JVM由那些部分组成，运行流程是什么？"><a href="#JVM由那些部分组成，运行流程是什么？" class="headerlink" title="JVM由那些部分组成，运行流程是什么？"></a>JVM由那些部分组成，运行流程是什么？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p><strong>JVM是什么</strong></p><p>Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）</p><p>好处：</p><ul><li><p>一次编写，到处运行</p></li><li><p>自动内存管理，垃圾回收机制</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506094254360.png" alt="image-20230506094254360"></p><p><strong>JVM由哪些部分组成，运行流程是什么？</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506094411247.png" alt="image-20230506094411247"></p><p>从图中可以看出 JVM 的主要组成部分</p><ul><li>ClassLoader（类加载器）</li><li>Runtime Data Area（运行时数据区，内存分区）</li><li>Execution Engine（执行引擎）</li><li>Native Method Library（本地库接口）</li></ul><p>运行流程：</p><p>（1）类加载器（ClassLoader）把Java代码转换为字节码</p><p>（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p><p>（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p><h3 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p><blockquote><p>javap -verbose xx.class 打印堆栈大小，局部变量的数量和方法的参数。</p></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506094602329.png" alt="image-20230506094602329"></p><p>​	java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。</p><p>​	那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。</p><p>​	程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。</p><h3 id="你能给我详细的介绍Java堆吗"><a href="#你能给我详细的介绍Java堆吗" class="headerlink" title="你能给我详细的介绍Java堆吗?"></a>你能给我详细的介绍Java堆吗?</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>线程共享的区域：主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506094803545.png" alt="image-20230506094803545"></p><ul><li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li><li>老年代主要保存生命周期长的对象，一般是一些老的对象</li><li>元空间保存的类信息、静态变量、常量、编译后的代码</li></ul><p>​</p><p>为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<strong>元空间</strong>。那么现在就可以避免掉OOM的出现了。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506094938843.png" alt="image-20230506094938843"></p><h3 id="元空间-MetaSpace-介绍"><a href="#元空间-MetaSpace-介绍" class="headerlink" title="元空间(MetaSpace)介绍"></a>元空间(MetaSpace)介绍</h3><p>​	在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>​	永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。</p><p>​	那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p><p>官网给出了解释：<span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8xMjI=">http://openjdk.java.net/jeps/122</span></p><pre><code>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.

移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。
</code></pre><p>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</p><p>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p><p>​	准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java&#x2F;lang&#x2F;Object 类元信息、静态属性 System.out、整型常量等。</p><p>​	元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h3 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>Java Virtual machine Stacks (java 虚拟机栈)</p><ul><li><p>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</p></li><li><p>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506095140595.png" alt="image-20230506095140595"></p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放</p></li><li><p>栈内存分配越大越好吗？</p><p>未必，默认的栈内存通常为1024k</p><p>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p></li><li><p>比如以下代码：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506095306061.png" alt="image-20230506095306061"></p></li></ul></li></ol><p><strong>栈内存溢出情况</strong></p><ul><li><p>栈帧过多导致栈内存溢出，典型问题：递归调用</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506095401637.png" alt="image-20230506095401637"></p></li><li><p>栈帧过大导致栈内存溢出</p></li></ul><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>组成部分：堆、方法区、栈、本地方法栈、程序计数器</p><p>1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。<br>2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。<br>3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。<br>4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。<br>5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p><h3 id="能不能解释一下方法区？"><a href="#能不能解释一下方法区？" class="headerlink" title="能不能解释一下方法区？"></a>能不能解释一下方法区？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><p>方法区(Method Area)是各个线程共享的内存区域</p></li><li><p>主要存储类的信息、运行时常量池</p></li><li><p>虚拟机启动的时候创建，关闭虚拟机时释放</p></li><li><p>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506095504213.png" alt="image-20230506095504213"></p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p><p>比如下面是一个Application类的main方法执行，源码如下：</p><pre><code class="java">public class Application &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;hello world&quot;);
    &#125;
&#125;
</code></pre><p>找到类对应的class文件存放目录，执行命令：<code>javap -v Application.class</code> 查看字节码结构</p><pre><code class="java">D:\code\jvm-demo\target\classes\com\heima\jvm&gt;javap -v Application.class
Classfile /D:/code/jvm-demo/target/classes/com/heima/jvm/Application.class
  Last modified 2023-05-07; size 564 bytes    //最后修改的时间
  MD5 checksum c1b64ed6491b9a16c2baab5061c64f88   //签名
  Compiled from &quot;Application.java&quot;   //从哪个源码编译
public class com.heima.jvm.Application   //包名，类名
  minor version: 0
  major version: 52     //jdk版本
  flags: ACC_PUBLIC, ACC_SUPER  //修饰符
Constant pool:   //常量池
   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #23            // hello world
   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #26            // com/heima/jvm/Application
   #6 = Class              #27            // java/lang/Object
   #7 = Utf8               &lt;init&gt;
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/heima/jvm/Application;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
  #16 = Utf8               args
  #17 = Utf8               [Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               Application.java
  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V
  #21 = Class              #28            // java/lang/System
  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
  #23 = Utf8               hello world
  #24 = Class              #31            // java/io/PrintStream
  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
  #26 = Utf8               com/heima/jvm/Application
  #27 = Utf8               java/lang/Object
  #28 = Utf8               java/lang/System
  #29 = Utf8               out
  #30 = Utf8               Ljava/io/PrintStream;
  #31 = Utf8               java/io/PrintStream
  #32 = Utf8               println
  #33 = Utf8               (Ljava/lang/String;)V
&#123;
  public com.heima.jvm.Application();  //构造方法
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/heima/jvm/Application;

  public static void main(java.lang.String[]);  //main方法
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String hello world
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 7: 0
        line 8: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
&#125;
SourceFile: &quot;Application.java&quot;
</code></pre><p>下图，左侧是main方法的指令信息，右侧constant pool 是常量池</p><p>main方法按照指令执行的时候，需要到常量池中查表翻译找到具体的类和方法地址去执行</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506095634842.png" alt="image-20230506095634842"></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506100142724.png" alt="image-20230506100142724"></p><h3 id="你听过直接内存吗？"><a href="#你听过直接内存吗？" class="headerlink" title="你听过直接内存吗？"></a>你听过直接内存吗？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p><p>举例：</p><p>需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506100501905.png" alt="image-20230506100501905"></p><p>代码如下：</p><pre><code class="java">/**
 * 演示 ByteBuffer 作用
 */
public class Demo1_9 &#123;
    static final String FROM = &quot;E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&quot;;
    static final String TO = &quot;E:\\a.mp4&quot;;
    static final int _1Mb = 1024 * 1024;

    public static void main(String[] args) &#123;
        io(); // io 用时：1535.586957 1766.963399 1359.240226
        directBuffer(); // directBuffer 用时：479.295165 702.291454 562.56592
    &#125;

    private static void directBuffer() &#123;
        long start = System.nanoTime();
        try (FileChannel from = new FileInputStream(FROM).getChannel();
             FileChannel to = new FileOutputStream(TO).getChannel();
        ) &#123;
            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);
            while (true) &#123;
                int len = from.read(bb);
                if (len == -1) &#123;
                    break;
                &#125;
                bb.flip();
                to.write(bb);
                bb.clear();
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        long end = System.nanoTime();
        System.out.println(&quot;directBuffer 用时：&quot; + (end - start) / 1000_000.0);
    &#125;

    private static void io() &#123;
        long start = System.nanoTime();
        try (FileInputStream from = new FileInputStream(FROM);
             FileOutputStream to = new FileOutputStream(TO);
        ) &#123;
            byte[] buf = new byte[_1Mb];
            while (true) &#123;
                int len = from.read(buf);
                if (len == -1) &#123;
                    break;
                &#125;
                to.write(buf, 0, len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        long end = System.nanoTime();
        System.out.println(&quot;io 用时：&quot; + (end - start) / 1000_000.0);
    &#125;
&#125;
</code></pre><p>可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。</p><p>这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506100548455.png" alt="image-20230506100548455"></p><p>下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506100621146.png" alt="image-20230506100621146"></p><h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p><p>2、栈内存是线程私有的，而堆内存是线程共有的。</p><p>3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>栈空间不足：java.lang.StackOverFlowError。</p><p>堆空间不足：java.lang.OutOfMemoryError。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220903233627146.png"></p><ul><li>类加载器：用于装载字节码文件(.class文件)</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对JVM中的垃圾内容进行回收</li></ul><p><strong>类加载器</strong></p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源</p><p><strong>类加载器种类</strong></p><p>类加载器根据各自加载范围的不同，划分为四种类加载器：</p><ul><li><p><strong>启动类加载器(BootStrap ClassLoader)：</strong></p><p>该类并不继承ClassLoader类，其是由C++编写实现。用于加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib</strong>目录下的类库。</p></li><li><p><strong>扩展类加载器(ExtClassLoader)：</strong></p><p>该类是ClassLoader的子类，主要加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong>目录中的类库。</p></li><li><p><strong>应用类加载器(AppClassLoader)：</strong></p><p>该类是ClassLoader的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。</p></li><li><p><strong>自定义类加载器：</strong></p><p>开发者自定义类继承ClassLoader，实现自定义类加载规则。</p></li></ul><p>上述三种类加载器的层次结构如下如下：</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506100746624.png" alt="image-20230506100746624"></p><p>类加载器的体系并不是“继承”体系，而是<strong>委派体系</strong>，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p><h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506100920042.png" alt="image-20230506100920042"></p><h3 id="JVM为什么采用双亲委派机制"><a href="#JVM为什么采用双亲委派机制" class="headerlink" title="JVM为什么采用双亲委派机制"></a>JVM为什么采用双亲委派机制</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p><p>（2）为了安全，保证类库API不会被修改</p><p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p><pre><code class="java">public class String &#123;

    public static void main(String[] args) &#123;

        System.out.println(&quot;demo info&quot;);
    &#125;
&#125;
</code></pre><p>​	此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220903144547378.png" alt="image-20220903144547378"></p><p>​	出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。</p><h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3><blockquote><p>难易程度：☆☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101032605.png" alt="image-20230506101032605"></p><p><strong>类加载过程详解</strong></p><p>1.加载</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101115674.png" alt="image-20230506101115674"></p><ul><li><p>通过类的全名，获取类的二进制数据流。</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java类模型）</p></li><li><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101213373.png" alt="image-20230506101213373"></p><p>2.验证</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101420202.png" alt="image-20230506101420202"></p><p><strong>验证类是否符合JVM规范，安全性检查</strong></p><p>(1)文件格式验证:是否符合Class文件的规范<br>(2)元数据验证<br>这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）<br>这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）<br>类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）<br>(3)字节码验证<br>主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。<br>(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p><blockquote><p>比如：int i &#x3D; 3;<br>字面量：3<br>符号引用：i</p></blockquote><p>3.准备</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101445898.png" alt="image-20230506101445898"></p><p><strong>为类变量分配内存并设置类变量初始值</strong></p><ul><li><p>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</p></li><li><p>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成</p></li><li><p>static变量是final的引用类型，那么赋值也会在初始化阶段完成</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101824622.png" alt="image-20230506101824622"></p><p>4.解析</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101504632.png" alt="image-20230506101504632"></p><p><strong>把类中的符号引用转换为直接引用</strong></p><p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506102311951.png" alt="image-20230506102311951"></p><p>5.初始化</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101625087.png" alt="image-20230506101625087"></p><p><strong>对类的静态变量，静态代码块执行初始化操作</strong></p><ul><li><p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p></li><li><p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p></li></ul><p>6.使用</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506101641837.png" alt="image-20230506101641837"></p><p>JVM 开始从入口方法开始执行用户的程序代码</p><ul><li><p>调用静态类成员信息（比如：静态字段、静态方法）</p></li><li><p>使用new关键字为其创建对象实例</p></li></ul><p>7.卸载</p><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p><h2 id="垃圾收回"><a href="#垃圾收回" class="headerlink" title="垃圾收回"></a>垃圾收回</h2><h3 id="简述Java垃圾回收机制？（GC是什么？为什么要GC）"><a href="#简述Java垃圾回收机制？（GC是什么？为什么要GC）" class="headerlink" title="简述Java垃圾回收机制？（GC是什么？为什么要GC）"></a>简述Java垃圾回收机制？（GC是什么？为什么要GC）</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p><p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p><p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p><h3 id="对象什么时候可以被垃圾器回收"><a href="#对象什么时候可以被垃圾器回收" class="headerlink" title="对象什么时候可以被垃圾器回收"></a>对象什么时候可以被垃圾器回收</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506104954777.png" alt="image-20230506104954777"></p><p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p><pre><code class="java">String demo = new String(&quot;123&quot;);
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111102825.png" alt="image-20230506111102825"></p><pre><code class="java">String demo = null;
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111136231.png" alt="image-20230506111136231"></p><p>当对象间出现了循环引用的话，则引用计数法就会失效</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111255401.png" alt="image-20230506111255401"></p><p>先执行右侧代码的前4行代码</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111327590.png" alt="image-20230506111327590"></p><p>目前上方的引用关系和计数都是没问题的，但是，如果代码继续往下执行，如下图</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111512450.png" alt="image-20230506111512450"></p><p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p><p>优点：</p><ul><li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li><li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li></ul><p>缺点：</p><ul><li>每次对象被引用时，都需要去更新计数器，有一点时间开销。</li><li><strong>浪费CPU资源</strong>，即使内存够用，仍然在运行时进行计数器的统计。</li><li><strong>无法解决循环引用问题，会引发内存泄露</strong>。（最大的缺点）</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>​	现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。</p><p>​	会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。</p><blockquote><p>根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象</p><p>局部变量，静态方法，静态变量，类信息</p><p>核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收</p></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904010634153.png" alt="image-20220904010634153"></p><p>​	X,Y这两个节点是可回收的，但是<strong>并不会马上的被回收！！</strong> 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先<strong>会判断这个对象是否执行了finalize方法</strong>，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。</p><p>​	finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。</p><p><strong>GC ROOTS：</strong></p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li></ul><pre><code class="java">/**
 * demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。
 */
public class Demo &#123;
    public static  void main(String[] args) &#123;
        Demo demo = new Demo();
        demo = null;
    &#125;
&#125;
</code></pre><ul><li>方法区中类静态属性引用的对象</li></ul><pre><code class="java">/**
 * 当栈帧中的本地变量 b = null 时，由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接，所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用，a在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!
 */
public class Demo &#123;
    public static Demo a;
    public static  void main(String[] args) &#123;
        Demo b = new Demo();
        b.a = new Demo();
        b = null;
    &#125;
&#125;
</code></pre><ul><li>方法区中常量引用的对象</li></ul><pre><code class="java">/**
 * 常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收
 */
public class Demo &#123;
    
    public static final Demo a = new Demo();
    
    public static  void main(String[] args) &#123;
        Demo demo = new Demo();
        demo = null;
    &#125;
&#125;
</code></pre><ul><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h3 id="JVM-垃圾回收算法有哪些？"><a href="#JVM-垃圾回收算法有哪些？" class="headerlink" title="JVM 垃圾回收算法有哪些？"></a>JVM 垃圾回收算法有哪些？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是<strong>标记和清除</strong>。</p><p>1.根据可达性分析算法得出的垃圾进行标记</p><p>2.对这些标记为可回收的内容进行垃圾回收</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506112047190.png" alt="image-20230506112047190"></p><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p><p>同样，标记清除算法也是有缺点的：</p><ul><li>效率较低，<strong>标记和清除两个动作都需要遍历所有的对象</strong>，并且在GC时，<strong>需要停止应用程序</strong>，对于交互性要求比较高的应用而言这个体验是非常差的。</li><li>（<strong>重要</strong>）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>​	复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p><p>​	如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111919008.png" alt="image-20230506111919008"></p><p>1）将内存区域分成两部分，每次操作其中一个。</p><p>2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。</p><p>3）周而复始。</p><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul><p>缺点：</p><ul><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li></ul><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>​	标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506111957793.png" alt="image-20230506111957793"></p><p>1）标记垃圾。</p><p>2）需要清除向右边走，不需要清除的向左边走。</p><p>3）清除边界以外的垃圾。</p><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p><p>与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>在java8时，堆被分为了两份：<strong>新生代和老年代【1：2】</strong>，在java7时，还存在一个永久代。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131229649.png" alt="image-20230506131229649"></p><p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】</p><p>当对新生代产生GC：MinorGC【young GC】</p><p>当对老年代代产生GC：Major GC</p><p>当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p><h4 id="作机制"><a href="#作机制" class="headerlink" title="作机制"></a>作机制</h4><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131308654.png" alt="image-20230506131308654"></p><ul><li>新创建的对象，都会先分配到eden区</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131415418.png" alt="image-20230506131415418"></p><ul><li><p>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</p></li><li><p>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131442503.png" alt="image-20230506131442503"></p><ul><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区</li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131544447.png" alt="image-20230506131544447"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131607645.png" alt="image-20230506131607645"></p><ul><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul><p><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么</strong></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506131640893.png" alt="image-20230506131640893"></p><ul><li><p>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？</p></li></ul><blockquote><p>名词解释：</p><p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p></blockquote><h3 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>在jvm中，实现了多种垃圾收集器，包括：</p><ul><li><p>串行垃圾收集器</p></li><li><p>并行垃圾收集器</p></li><li><p>CMS（并发）垃圾收集器</p></li><li><p>G1垃圾收集器</p></li></ul><h4 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h4><p>Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p><ul><li><p>Serial 作用于新生代，采用复制算法</p></li><li><p>Serial Old 作用于老年代，采用标记-整理算法</p></li></ul><p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154006266.png" alt="image-20230506154006266"></p><h4 id="并行垃圾收集器"><a href="#并行垃圾收集器" class="headerlink" title="并行垃圾收集器"></a>并行垃圾收集器</h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p><ul><li><p>Parallel New作用于新生代，采用复制算法</p></li><li><p>Parallel Old作用于老年代，采用标记-整理算法</p></li></ul><p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154042673.png" alt="image-20230506154042673"></p><h4 id="CMS（并发）垃圾收集器"><a href="#CMS（并发）垃圾收集器" class="headerlink" title="CMS（并发）垃圾收集器"></a>CMS（并发）垃圾收集器</h4><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154117857.png" alt="image-20230506154117857"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154107944.png" alt="image-20230506154107944"></p><h3 id="详细聊一下G1垃圾回收器"><a href="#详细聊一下G1垃圾回收器" class="headerlink" title="详细聊一下G1垃圾回收器"></a>详细聊一下G1垃圾回收器</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li><p>应用于新生代和老年代，<strong>在<strong><strong>JDK9</strong></strong>之后默认使用****G1</strong></p></li><li><p>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</p></li><li><p>采用复制算法</p></li><li><p>响应时间与吞吐量兼顾</p></li><li><p>分成三个阶段：新生代回收、并发标记、混合收集</p></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li></ul><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154323950.png" alt="image-20230506154323950"></p><h4 id="Young-Collection-年轻代垃圾回收"><a href="#Young-Collection-年轻代垃圾回收" class="headerlink" title="Young Collection(年轻代垃圾回收)"></a>Young Collection(年轻代垃圾回收)</h4><ul><li><p>初始时，所有区域都处于空闲状态</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154542687.png" alt="image-20230506154542687"></p></li><li><p>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154607558.png" alt="image-20230506154607558"></p></li><li><p>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154633118.png" alt="image-20230506154633118"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154705088.png" alt="image-20230506154705088"></p></li><li><p>随着时间流逝，伊甸园的内存又有不足</p></li><li><p>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154759809.png" alt="image-20230506154759809"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154826981.png" alt="image-20230506154826981"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506154859985.png" alt="image-20230506154859985"></p></li></ul><h4 id="Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记"><a href="#Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记" class="headerlink" title="Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)"></a>Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)</h4><p>当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155000503.png" alt="image-20230506155000503"></p><ul><li><p>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。</p></li><li><p>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155047765.png" alt="image-20230506155047765"></p></li></ul><h4 id="Mixed-Collection-混合垃圾回收"><a href="#Mixed-Collection-混合垃圾回收" class="headerlink" title="Mixed Collection (混合垃圾回收)"></a>Mixed Collection (混合垃圾回收)</h4><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155116267.png" alt="image-20230506155116267"></p><p>其中H叫做巨型对象，如果对象非常大，会开辟一块连续的空间存储巨型对象</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155146370.png" alt="image-20230506155146370"></p><h3 id="强引用、软引用、弱引用、虚引用的区别？"><a href="#强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别？"></a>强引用、软引用、弱引用、虚引用的区别？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><pre><code class="java">User user = new User();
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155341703.png" alt="image-20230506155341703"></p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收</p><pre><code class="java">User user = new User();
SoftReference softReference = new SoftReference(user);
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155416293.png" alt="image-20230506155416293"></p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><pre><code class="java">User user = new User();
WeakReference weakReference = new WeakReference(user);
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155501557.png" alt="image-20230506155501557"></p><blockquote><p>延伸话题：ThreadLocal内存泄漏问题</p></blockquote><p>ThreadLocal用的就是弱引用，看以下源码：</p><pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;
    Object value;

    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
         super(k);
         value = v; //强引用，不会被回收
     &#125;
&#125;
</code></pre><p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p><p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是<code>value</code>是强引用，它不会被回收掉。</p><blockquote><p>ThreadLocal使用建议：使用完毕后注意调用清理方法。</p></blockquote><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155518510.png" alt="image-20230506155518510"></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155552693.png" alt="image-20230506155552693"></p><h2 id="JVM实践（调优）"><a href="#JVM实践（调优）" class="headerlink" title="JVM实践（调优）"></a>JVM实践（调优）</h2><h3 id="JVM-调优的参数可以在哪里设置参数值？"><a href="#JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM 调优的参数可以在哪里设置参数值？"></a>JVM 调优的参数可以在哪里设置参数值？</h3><blockquote><p>难易程度：☆☆</p><p>出现频率：☆☆☆</p></blockquote><h4 id="tomcat的设置vm参数"><a href="#tomcat的设置vm参数" class="headerlink" title="tomcat的设置vm参数"></a>tomcat的设置vm参数</h4><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件，如下图</p><p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;</code></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904151948778.png" alt="image-20220904151948778"></p><h4 id="springboot项目jar文件启动"><a href="#springboot项目jar文件启动" class="headerlink" title="springboot项目jar文件启动"></a>springboot项目jar文件启动</h4><p>通常在linux系统下直接加参数启动springboot项目</p><pre><code class="sh">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;
</code></pre><blockquote><p>nohup : 用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p><p>参数 <strong>&amp;</strong> ：让命令在后台执行，终端退出后命令仍旧执行。</p></blockquote><h3 id="用的-JVM-调优的参数都有哪些？"><a href="#用的-JVM-调优的参数都有哪些？" class="headerlink" title="用的 JVM 调优的参数都有哪些？"></a>用的 JVM 调优的参数都有哪些？</h3><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>​	对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2Uvdm1vcHRpb25zLWpzcC5odG1s">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</span></p><p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p><pre><code>-Xms：设置堆的初始化大小

-Xmx：设置堆的最大大小
</code></pre><p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p><p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p><pre><code>-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3
</code></pre><p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p><pre><code>-XX:newSize   设置年轻代的初始大小
-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同
</code></pre><p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><pre><code>-Xss   对每个线程stack大小的调整,-Xss128k
</code></pre><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p><p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p><p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold&#x3D;1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><pre><code>（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。

（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。
</code></pre><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p><pre><code>-XX:+LargePageSizeInBytes 设置内存页的大小
</code></pre><p>10）使用非占用的垃圾收集器。</p><pre><code>-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。
</code></pre><h3 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><h4 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h4><h5 id="jps（Java-Process-Status）"><a href="#jps（Java-Process-Status）" class="headerlink" title="jps（Java Process Status）"></a>jps（Java Process Status）</h5><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904104739581.png" alt="image-20220904104739581"></p><h5 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h5><p>查看java进程内<strong>线程的堆栈</strong>信息。</p><pre><code class="sh">jstack [option] &lt;pid&gt;  
</code></pre><p>java案例</p><pre><code class="java">package com.heima.jvm;

public class Application &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        while (true)&#123;
            Thread.sleep(1000);
            System.out.println(&quot;哈哈哈&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>使用jstack查看进行堆栈运行信息</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904111059602.png" alt="image-20220904111059602"></p><h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h5><p>用于生成堆转存快照</p><blockquote><p>jmap [options] pid 内存映像信息</p><p>jmap -heap pid 显示Java堆的信息</p><p>jmap -dump:format&#x3D;b,file&#x3D;heap.hprof pid</p><p>​ format&#x3D;b表示以hprof二进制格式转储Java堆的内存<br>​ file&#x3D;<filename>用于指定快照dump文件的文件名。</filename></p></blockquote><p>例：显示了某一个java运行的堆信息</p><pre><code class="java">C:\Users\yuhon&gt;jmap -heap 53280
Attaching to process ID 53280, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.321-b07

using thread-local object allocation.
Parallel GC with 8 thread(s)   //并行的垃圾回收器

Heap Configuration:  //堆配置
   MinHeapFreeRatio         = 0   //空闲堆空间的最小百分比
   MaxHeapFreeRatio         = 100  //空闲堆空间的最大百分比
   MaxHeapSize              = 8524922880 (8130.0MB) //堆空间允许的最大值
   NewSize                  = 178257920 (170.0MB) //新生代堆空间的默认值
   MaxNewSize               = 2841640960 (2710.0MB) //新生代堆空间允许的最大值
   OldSize                  = 356515840 (340.0MB) //老年代堆空间的默认值
   NewRatio                 = 2 //新生代与老年代的堆空间比值，表示新生代：老年代=1：2
   SurvivorRatio            = 8 //两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8
   MetaspaceSize            = 21807104 (20.796875MB) //元空间的默认值
   CompressedClassSpaceSize = 1073741824 (1024.0MB) //压缩类使用空间大小
   MaxMetaspaceSize         = 17592186044415 MB //元空间允许的最大值
   G1HeapRegionSize         = 0 (0.0MB)//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。

Heap Usage:
PS Young Generation
Eden Space: //Eden使用情况
   capacity = 134217728 (128.0MB)
   used     = 10737496 (10.240074157714844MB)
   free     = 123480232 (117.75992584228516MB)
   8.000057935714722% used
From Space: //Survivor-From 使用情况
   capacity = 22020096 (21.0MB)
   used     = 0 (0.0MB)
   free     = 22020096 (21.0MB)
   0.0% used
To Space: //Survivor-To 使用情况
   capacity = 22020096 (21.0MB)
   used     = 0 (0.0MB)
   free     = 22020096 (21.0MB)
   0.0% used
PS Old Generation  //老年代 使用情况
   capacity = 356515840 (340.0MB)
   used     = 0 (0.0MB)
   free     = 356515840 (340.0MB)
   0.0% used

3185 interned Strings occupying 261264 bytes.
</code></pre><h5 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h5><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p><h5 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h5><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</p><p><strong>常见参数</strong>：</p><p>①总结垃圾回收统计</p><pre><code class="sh">jstat -gcutil pid
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904114511854.png" alt="image-20220904114511854"></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存1区当前使用比例</td></tr><tr><td>S1</td><td>幸存2区当前使用比例</td></tr><tr><td>E</td><td>伊甸园区使用比例</td></tr><tr><td>O</td><td>老年代使用比例</td></tr><tr><td>M</td><td>元数据区使用比例</td></tr><tr><td>CCS</td><td>压缩使用比例</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><p>②垃圾回收统计</p><pre><code class="sh">jstat -gc pid
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904115157363.png" alt="image-20220904115157363"></p><h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><h5 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h5><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904115936095.png" alt="image-20220904115936095"></p><p>可以内存、线程、类等信息</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904120057211.png" alt="image-20220904120057211"></p><h5 id="VisualVM：故障处理工具"><a href="#VisualVM：故障处理工具" class="headerlink" title="VisualVM：故障处理工具"></a>VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904120356174.png" alt="image-20220904120356174"></p><p>监控程序运行情况</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904132011289.png" alt="image-20220904132011289"></p><p>查看运行中的dump</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904132134095.png" alt="image-20220904132134095"></p><p>查看堆中的信息</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904132346495.png" alt="image-20220904132346495"></p><h3 id="java内存泄露的排查思路？"><a href="#java内存泄露的排查思路？" class="headerlink" title="java内存泄露的排查思路？"></a>java内存泄露的排查思路？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>原因：</p><p>如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常</p><p>如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常</p><p>如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError: Metaspace</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230506155704119.png" alt="image-20230506155704119"></p><p>1、通过jmap指定打印他的内存快照 dump</p><blockquote><p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p><p>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;app&#x2F;dumps&#x2F; 指定生成后文件的保存目录</p></blockquote><p>2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件</p><p>VisualVM可以加载离线的dump文件，如下图</p><p>文件–&gt;装入—&gt;选择dump文件即可查看堆快照信息</p><blockquote><p>如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化</p></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904132925812.png" alt="image-20220904132925812"></p><p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904133722905.png" alt="image-20220904133722905"></p><p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p><h3 id="CPU飙高排查方案与思路？"><a href="#CPU飙高排查方案与思路？" class="headerlink" title="CPU飙高排查方案与思路？"></a>CPU飙高排查方案与思路？</h3><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>1.使用top命令查看占用cpu的情况</p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904161818255.png" alt="image-20220904161818255"></p><p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978</p><p>3.查看当前线程中的进程信息</p><pre><code class="sh">ps H -eo pid,tid,%cpu | grep 40940
</code></pre><blockquote><p>pid 进行id</p><p>tid 进程中的线程id</p><p>% cpu使用率</p></blockquote><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904162117022.png" alt="image-20220904162117022"></p><p>4.通过上图分析，在进程30978中的线程30979占用cpu较高</p><blockquote><p>注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称</p><p>转换方式：</p><p>在linux中执行命令</p><p><code>printf &quot;%x\n&quot; 30979</code></p><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904162654928.png" alt="image-20220904162654928"></p></blockquote><p>5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号</p><p>执行命令</p><pre><code class="sh">jstack 30978   此处是进程id
</code></pre><p><img data-src="https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220904162941977.png" alt="image-20220904162941977"></p><blockquote><p>看完此文章可以看<a href="interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98">JVM相关面试题</a>测试一下自己掌握情况</p></blockquote><ul><li>本文引自<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=">黑马程序员Java面试宝典</span></li></ul><div class="tags"><a href="/tags/JVM/" rel="tag"><i class="ic i-tag"></i> JVM</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-15 19:49:22" itemprop="dateModified" datetime="2023-08-15T19:49:22+08:00">2023-08-15</time> </span><span id="java/JVM详解/" class="item leancloud_visitors" data-flag-title="JVM详解" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/weipay.png" alt="anoxia 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="anoxia 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>anoxia <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://anoxiahub.github.io/java/JVM%E8%AF%A6%E8%A7%A3/" title="JVM详解">https://anoxiahub.github.io/java/JVM详解/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tse3-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP-C.9zMXk851MunYv8lnOOF8jgHaDz?w&#x3D;307&amp;h&#x3D;179&amp;c&#x3D;7&amp;r&#x3D;0&amp;o&#x3D;5&amp;dpr&#x3D;1.3&amp;pid&#x3D;1.7" title="Java集合详解"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java集合详解</h3></a></div><div class="item right"><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tse1-mm.cn.bing.net&#x2F;th&#x2F;id&#x2F;OIP-C.Lmrn8WhH_ezNA9AuLvhq6QHaEL?w&#x3D;291&amp;h&#x3D;180&amp;c&#x3D;7&amp;r&#x3D;0&amp;o&#x3D;5&amp;dpr&#x3D;1.3&amp;pid&#x3D;1.7" title="JUC详解"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>JUC详解</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%BB%84%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%94%B1%E9%82%A3%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">JVM由那些部分组成，运行流程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">什么是程序计数器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E7%BB%99%E6%88%91%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8DJava%E5%A0%86%E5%90%97"><span class="toc-number">1.3.</span> <span class="toc-text">你能给我详细的介绍Java堆吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4-MetaSpace-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.</span> <span class="toc-text">元空间(MetaSpace)介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.5.</span> <span class="toc-text">什么是虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">能不能解释一下方法区？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%90%AC%E8%BF%87%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">你听过直接内存吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">堆栈的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.1.</span> <span class="toc-text">什么是类加载器，类加载器有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">JVM为什么采用双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">说一下类装载的执行过程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E5%9B%9E"><span class="toc-number">3.</span> <span class="toc-text">垃圾收回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%EF%BC%88GC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81GC%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">简述Java垃圾回收机制？（GC是什么？为什么要GC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6"><span class="toc-number">3.2.</span> <span class="toc-text">对象什么时候可以被垃圾器回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">JVM 垃圾回收算法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">标记整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">说一下 JVM 有哪些垃圾回收器？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.5.1.</span> <span class="toc-text">串行垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">并行垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%88%E5%B9%B6%E5%8F%91%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.5.3.</span> <span class="toc-text">CMS（并发）垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">详细聊一下G1垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.2.</span> <span class="toc-text">Young Collection(年轻代垃圾回收)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-Concurrent-Mark-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">3.6.3.</span> <span class="toc-text">Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixed-Collection-%E6%B7%B7%E5%90%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.4.</span> <span class="toc-text">Mixed Collection (混合垃圾回收)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">强引用、软引用、弱引用、虚引用的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">3.7.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">3.7.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%AE%9E%E8%B7%B5%EF%BC%88%E8%B0%83%E4%BC%98%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">JVM实践（调优）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E5%80%BC%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">JVM 调优的参数可以在哪里设置参数值？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tomcat%E7%9A%84%E8%AE%BE%E7%BD%AEvm%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">tomcat的设置vm参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springboot%E9%A1%B9%E7%9B%AEjar%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">springboot项目jar文件启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">用的 JVM 调优的参数都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">说一下 JVM 调优的工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7"><span class="toc-number">4.3.1.</span> <span class="toc-text">命令工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jps%EF%BC%88Java-Process-Status%EF%BC%89"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">jps（Java Process Status）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jstack"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">jstack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jmap"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">jmap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jhat"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">jhat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jstat"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">jstat</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">4.3.2.</span> <span class="toc-text">可视化工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jconsole"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">jconsole</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VisualVM%EF%BC%9A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">VisualVM：故障处理工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">java内存泄露的排查思路？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E9%A3%99%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">CPU飙高排查方案与思路？</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="JUC详解">JUC详解</a></li><li class="active"><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="JVM详解">JVM详解</a></li><li><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="Java集合详解">Java集合详解</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="anoxia" data-src="/images/avatar.webp"><p class="name" itemprop="name">anoxia</p><div class="description" itemprop="description">anoxia的后端博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbjB5dWFu" title="https:&#x2F;&#x2F;github.com&#x2F;lin0yuan"><i class="ic i-github"></i></span> <a href="/3102691553@qq.com" title="3102691553@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/JVM%E8%AF%A6%E8%A7%A3/" title="JVM详解">JVM详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Redis相关面试题">Redis相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/" title="项目常见问题">项目常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目总结">项目总结</a></div><span><a href="/project/Mysql%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/" title="连接数据库遇到问题">连接数据库遇到问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/JUC%E8%AF%A6%E8%A7%A3/" title="JUC详解">JUC详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于 Java">Java</a></div><span><a href="/java/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">Java集合详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="JVM相关面试题">JVM相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis">Redis</a></div><span><a href="/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" title="关于缓存读写一致问题">关于缓存读写一致问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Mysql相关面试题">Mysql相关面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/interview/" title="分类于 面经">面经</a></div><span><a href="/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/" title="Spring相关面试题">Spring相关面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">anoxia @ 智慧笔记</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">121k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:50</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"java/JVM详解/",favicon:{show:"智慧笔记",hide:"别走嘛QwQ"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->