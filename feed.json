{
    "version": "https://jsonfeed.org/version/1",
    "title": null,
    "subtitle": "欢迎来到智慧笔记~这里主要会记录编程学习笔记🌸",
    "icon": "http://zero-yuan.gitee.io/images/favicon.ico",
    "description": "anoxia的后端博客",
    "home_page_url": "http://zero-yuan.gitee.io",
    "items": [
        {
            "id": "http://zero-yuan.gitee.io/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "http://zero-yuan.gitee.io/interview/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "Java集合相关面试题",
            "date_published": "2023-08-12T16:00:00.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>这次课程主要涉及到的是 List 和 Map 相关的面试题，比较高频就是</p>\n<ul>\n<li>\n<p>ArrayList</p>\n</li>\n<li>\n<p>LinkedList</p>\n</li>\n<li>\n<p>HashMap</p>\n</li>\n<li>\n<p>ConcurrentHashMap</p>\n</li>\n</ul>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427162524322.png\" alt=\"\" /></p>\n<ul>\n<li>ArrayList 底层实现是数组</li>\n<li>LinkedList 底层实现是双向链表</li>\n<li>HashMap 的底层实现使用了众多数据结构，包含了数组、链表、散列表、红黑树等</li>\n</ul>\n<p>在讲解这些集合之后，我们会讲解数据结构，知道了数据结构的特点之后，熟悉集合就更加简单了。在讲解数据结构之前，我们也会简单普及一下算法复杂度分析，让大家能够评判代码的好坏，也能更加深入去理解数据结构和集合。</p>\n<h2 id=\"1-算法复杂度分析\"><a class=\"anchor\" href=\"#1-算法复杂度分析\">#</a> 1 算法复杂度分析</h2>\n<h3 id=\"11-为什么要进行复杂度分析\"><a class=\"anchor\" href=\"#11-为什么要进行复杂度分析\">#</a> 1.1 为什么要进行复杂度分析？</h3>\n<p>我们先来看下面这个代码，你能评判这个代码的好坏吗？</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> ** * 求 **1~n** 的累加和</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> ** @param* *n</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> ** @return</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     sum <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其实学习算法复杂度的好处就是：</p>\n<ul>\n<li>\n<p>指导你编写出性能更优的代码</p>\n</li>\n<li>\n<p>评判别人写的代码的好坏</p>\n</li>\n</ul>\n<blockquote>\n<p>相信你学完了算法复杂度分析，就有能力评判上面代码的好坏了</p>\n</blockquote>\n<p>关于算法复杂度分析，包含了两个内容，一个是时间复杂度，一个是空间复杂度，通常情况下说复杂度，都是指时间复杂度，我们也会重点讲解时间复杂度</p>\n<h3 id=\"12-时间复杂度\"><a class=\"anchor\" href=\"#12-时间复杂度\">#</a> 1.2 时间复杂度</h3>\n<h4 id=\"121-案例\"><a class=\"anchor\" href=\"#121-案例\">#</a> 1.2.1 案例</h4>\n<p>时间复杂度分析：简单来说就是评估代码的执行耗时的，大家还是看刚才的代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> ** * 求 **1~n** 的累加和</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> ** @param* *n</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> ** @return</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     sum <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>分析这个代码的时间复杂度，分析过程如下：</p>\n<p>1. 假如每行代码的执行耗时一样：1ms</p>\n<p>2. 分析这段代码总执行多少行？3n+3</p>\n<p>3. 代码耗时总时间： T (n) = (3n + 3) * 1ms</p>\n<blockquote>\n<p>T (n): 就是代码总耗时</p>\n</blockquote>\n<p>我们现在有了总耗时，需要借助大 O 表示法来计算这个代码的时间复杂度</p>\n<h4 id=\"122-大o表示法\"><a class=\"anchor\" href=\"#122-大o表示法\">#</a> 1.2.2 大 O 表示法</h4>\n<p><strong>大 O 表示法</strong>：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>。</p>\n<p>刚才的代码示例总耗时公式为：T (n) = (3n + 3) * 1ms</p>\n<blockquote>\n<p>其中 (3n + 3) 是代码的总行数，每行执行的时间都一样，所以得出结论：</p>\n<p><strong>T (n) 与代码的执行次数成正比 (代码行数越多，执行时间越长)</strong></p>\n</blockquote>\n<p>不过，大 O 表示法只需要代码执行时间与数据规模的增长趋势，公式可以简化如下：</p>\n<p>T(n) =O(3n + 3)------------&gt; T(n) = O(n)</p>\n<blockquote>\n<p>当 n 很大时，公式中的低阶，常量，系数三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</p>\n</blockquote>\n<p>下图也能表明数据的趋势</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427173120668.png\" alt=\"image-20230427173120668\" /></p>\n<h4 id=\"123-常见复杂度表示形式\"><a class=\"anchor\" href=\"#123-常见复杂度表示形式\">#</a> 1.2.3 常见复杂度表示形式</h4>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427173742389.png\" alt=\"image-20230427173742389\" /></p>\n<p>速记口诀：<strong>常对幂指阶</strong></p>\n<p>越在上面的性能就越高，越往下性能就越低</p>\n<p>下图是一些比较常见时间复杂度的时间与数据规模的趋势：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427173937663.png\" alt=\"image-20230427173937663\" /></p>\n<h4 id=\"124-时间复杂度o1\"><a class=\"anchor\" href=\"#124-时间复杂度o1\">#</a> 1.2.4 时间复杂度 O (1)</h4>\n<p>实例代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token operator\">+</span>j<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>代码只有三行，它的复杂度也是 O (1)，而不是 O (3)</p>\n<p>再看如下代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> sum<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        sum <span class=\"token operator\">=</span> sum<span class=\"token operator\">+</span>i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>整个代码中因为循环次数是固定的就是 100 次，这样的代码复杂度我们认为也是 O (1)</p>\n<p>一句话总结：<strong>只要代码的执行时间不随着 n 的增大而增大，这样的代码复杂度都是 O (1)</strong></p>\n<h4 id=\"125-时间复杂度on\"><a class=\"anchor\" href=\"#125-时间复杂度on\">#</a> 1.2.5 时间复杂度 O (n)</h4>\n<p>实例代码 1：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> * 求 1~n 的累加和</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> * @param n</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> * @return</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        sum <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>一层 for 循序时间复杂度就是 O (n)</p>\n<p>实例代码 2：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sum2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            sum <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> i <span class=\"token operator\">*</span> j<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个代码的执行行数为：O (3n^2  + 3n + 3)，不过，依据大 O 表示的规则：<strong>常量、系数、低阶，可以忽略</strong></p>\n<p>所以这个代码最终的时间复杂度为：O (n^2)</p>\n<h4 id=\"126-时间复杂度ologn\"><a class=\"anchor\" href=\"#126-时间复杂度ologn\">#</a> 1.2.6 时间复杂度 O (logn)</h4>\n<p>对数复杂度非常的常见，但相对比较难以分析，实例代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test04</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        i <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>分析这个代码的复杂度，我们必须要再强调一个前提：<strong>复杂度分析就是要弄清楚代码的执行次数和数据规模 n 之间的关系</strong></p>\n<p>以上代码最关键的一行是： <code>i = i * 2</code> ，这行代码可以决定这个 while 循环执行代码的行数， <code>i</code>  的值是可以无限接近 <code>n</code>  的值的。如果 <code>i</code>  一旦大于等于了 <code>n</code>  则循环条件就不满足了。也就说达到了最大的行数。我们可以分析一下 <code>i</code>  这个值变化的过程</p>\n<p>分析过程如下：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427174832858.png\" alt=\"image-20230427174832858\" /></p>\n<p>由此可知，代码的时间复杂度表示为 O (log n)</p>\n<h4 id=\"127-时间复杂度on-log-n\"><a class=\"anchor\" href=\"#127-时间复杂度on-log-n\">#</a> 1.2.7 时间复杂度 O (n * log n)</h4>\n<p>分析完 O (log n)，那 O ( n * log n ) 就很容易理解了，比如下列代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test05</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">test04</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test04</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        i <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"13-空间复杂度\"><a class=\"anchor\" href=\"#13-空间复杂度\">#</a> 1.3 空间复杂度</h3>\n<p>空间复杂度全称是渐进空间复杂度，表示算法占用的额外<strong>存储空间</strong>与<strong>数据规模</strong>之间的增长关系</p>\n<p>看下面代码</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> sum<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        sum <span class=\"token operator\">=</span> sum<span class=\"token operator\">+</span>i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>代码执行并不需要占用额外的存储空间，只需要常量级的内存空间大小，因此空间复杂度是 O (1)</p>\n<p>再来看一个其他例子：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>传入一个变量 n，决定申请多少的 int 数组空间内存，此段代码的空间复杂度为 O (n)</p>\n<p>我们常见的空间复杂度就是 O (1),O (n),O (n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p>\n<h2 id=\"2-list相关面试题\"><a class=\"anchor\" href=\"#2-list相关面试题\">#</a> 2 List 相关面试题</h2>\n<h3 id=\"21-数组\"><a class=\"anchor\" href=\"#21-数组\">#</a> 2.1 数组</h3>\n<h4 id=\"211-数组概述\"><a class=\"anchor\" href=\"#211-数组概述\">#</a> 2.1.1 数组概述</h4>\n<p>数组（Array）是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数据的线性数据结构。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">22</span><span class=\"token punctuation\">,</span><span class=\"token number\">33</span><span class=\"token punctuation\">,</span><span class=\"token number\">88</span><span class=\"token punctuation\">,</span><span class=\"token number\">66</span><span class=\"token punctuation\">,</span><span class=\"token number\">55</span><span class=\"token punctuation\">,</span><span class=\"token number\">25</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427175545402.png\" alt=\"image-20230427175545402\" /></p>\n<p>我们定义了这么一个数组之后，在内存的表示是这样的：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427175633253.png\" alt=\"image-20230427175633253\" /></p>\n<p>现在假如，我们通过 <code>arrar[1]</code> ，想要获得下标为 1 这个元素，但是现在栈内存中指向的堆内存数组的首地址，它是如何获取下标为 1 这个数据的？</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427175849493.png\" alt=\"image-20230427175849493\" /></p>\n<h4 id=\"212-寻址公式\"><a class=\"anchor\" href=\"#212-寻址公式\">#</a> 2.1.2 寻址公式</h4>\n<p>为了方便大家理解，我们把数组的内存地址稍微改了一下，都改成了数字，如下图</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427180056509.png\" alt=\"image-20230427180056509\" /></p>\n<p>在数组在内存中查找元素的时候，是有一个寻址公式的，如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> baseAddress <span class=\"token operator\">+</span> i <span class=\"token operator\">*</span> dataTypeSize</pre></td></tr></table></figure><blockquote>\n<p>baseAddress：数组的首地址，目前是 10</p>\n<p>dataTypeSize：代表数组中元素类型的大小，目前数组重存储的是 int 型的数据，dataTypeSize=4 个字节</p>\n<p>arr：指的是数组</p>\n<p>i：指的是数组的下标</p>\n</blockquote>\n<p>有了寻址公式以后，我们再来获取一下下标为 1 的元素，这个是原来的数组</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">22</span><span class=\"token punctuation\">,</span><span class=\"token number\">33</span><span class=\"token punctuation\">,</span><span class=\"token number\">88</span><span class=\"token punctuation\">,</span><span class=\"token number\">66</span><span class=\"token punctuation\">,</span><span class=\"token number\">55</span><span class=\"token punctuation\">,</span><span class=\"token number\">25</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>套入公式：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>array<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token number\">10</span> <span class=\"token operator\">+</span> i <span class=\"token operator\">*</span> <span class=\"token number\">4</span> <span class=\"token operator\">=</span> <span class=\"token number\">14</span></pre></td></tr></table></figure><p>获取到 14 这个地址，就能获取到下标为 1 的这个元素了。</p>\n<h4 id=\"213-操作数组的时间复杂度\"><a class=\"anchor\" href=\"#213-操作数组的时间复杂度\">#</a> 2.1.3 操作数组的时间复杂度</h4>\n<p><strong>1. 随机查询 (根据索引查询)</strong></p>\n<p>数组元素的访问是通过下标来访问的，计算机通过数组的<strong>首地址</strong>和<strong>寻址公式</strong>能够很快速的找到想要访问的元素</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">test01</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token comment\">// a[i] = baseAddress + i \\* dataSize</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>代码的执行次数并不会随着数组的数据规模大小变化而变化，是常数级的，所以查询数据操作的时间复杂度是 O (1)</p>\n<p><strong>2. 未知索引查询 O (n) 或 O (log2n)</strong></p>\n<p>情况一：查找数组内的元素，查找 55 号数据，遍历数组时间复杂度为 O (n)</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221007101831281.png\" alt=\"image-20221007101831281\" /></p>\n<p>情况二：查找排序后数组内的元素，通过二分查找算法查找 55 号数据时间复杂度为 O (logn)</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221007101811885.png\" alt=\"image-20221007101811885\" /></p>\n<p><strong>3. 插入 O (n)</strong></p>\n<p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。</p>\n<p>假设数组的长度为 n，现在如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。如下图所示：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220820104903422.png\" alt=\"image-20220820104903422\" /></p>\n<p>新增之后的数据变化，如下</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20220820104950846.png\" alt=\"image-20220820104950846\" /></p>\n<p>所以：</p>\n<p>插入操作，最好情况下是 O (1) 的，最坏情况下是 O (n) 的，<strong>平均情况下的时间复杂度是 O (n)</strong>。</p>\n<p><strong>4. 删除 O (n)</strong></p>\n<p>同理可得：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，时间复杂度仍然是 O (n)。</p>\n<h3 id=\"22-arraylist源码分析\"><a class=\"anchor\" href=\"#22-arraylist源码分析\">#</a> 2.2 ArrayList 源码分析</h3>\n<p>分析 ArrayList 源码主要从三个方面去翻阅：成员变量，构造函数，关键方法</p>\n<blockquote>\n<p>以下源码都来源于 jdk1.8</p>\n</blockquote>\n<h4 id=\"221-成员变量\"><a class=\"anchor\" href=\"#221-成员变量\">#</a> 2.2.1 成员变量</h4>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192118259.png\" alt=\"image-20230427192118259\" /></p>\n<blockquote>\n<p><em>DEFAULT_CAPACITY</em> = 10;  默认初始的容量 **(CAPACITY)</p>\n<p><em>EMPTY_ELEMENTDATA</em> = {}; 用于空实例的共享空数组实例</p>\n<p><em>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</em> = {}; 用于默认大小的空实例的共享空数组实例</p>\n<p>Object [] elementData;  存储元素的数组缓冲区</p>\n<p>int size;     ArrayList 的大小（它包含的元素数量）</p>\n</blockquote>\n<h4 id=\"222-构造方法\"><a class=\"anchor\" href=\"#222-构造方法\">#</a> 2.2.2 构造方法</h4>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192154014.png\" alt=\"image-20230427192154014\" /></p>\n<blockquote>\n<ul>\n<li>\n<p>第一个构造是带初始化容量的构造函数，可以按照指定的容量初始化数组</p>\n</li>\n<li>\n<p>第二个是无参构造函数，默认创建一个空集合</p>\n</li>\n</ul>\n</blockquote>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192200918.png\" alt=\"image-20230427192200918\" /></p>\n<blockquote>\n<p>将 collection 对象转换成数组，然后将数组的地址的赋给 elementData</p>\n</blockquote>\n<h4 id=\"223-arraylist源码分析\"><a class=\"anchor\" href=\"#223-arraylist源码分析\">#</a> 2.2.3 ArrayList 源码分析</h4>\n<p>添加数据的流程</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230427192644244.png\" alt=\"image-20230427192644244\" /></p>\n<p><strong>结论：</strong></p>\n<ul>\n<li>底层数据结构</li>\n</ul>\n<p>ArrayList 底层是用动态的数组实现的</p>\n<ul>\n<li>初始容量</li>\n</ul>\n<p>ArrayList 初始容量为 0，当第一次添加数据的时候才会初始化容量为 10</p>\n<ul>\n<li>扩容逻辑</li>\n</ul>\n<p>ArrayList 在进行扩容的时候是原来容量的 1.5 倍，每次扩容都需要拷贝数组</p>\n<ul>\n<li>\n<p>添加逻辑</p>\n<ul>\n<li>\n<p>确保数组已使用长度（size）加 1 之后足够存下下一个数据</p>\n</li>\n<li>\n<p>计算数组的容量，如果当前数组已使用长度 + 1 后的大于当前的数组长度，则调用 grow 方法扩容（原来的 1.5 倍）</p>\n</li>\n<li>\n<p>确保新增的数据有地方存储之后，则将新元素添加到位于 size 的位置上。</p>\n</li>\n<li>\n<p>返回添加成功布尔值。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"224-面试题-arraylist-listnew-arraylist10中的list扩容几次\"><a class=\"anchor\" href=\"#224-面试题-arraylist-listnew-arraylist10中的list扩容几次\">#</a> 2.2.4 面试题 - ArrayList list=new ArrayList (10) 中的 list 扩容几次</h4>\n<blockquote>\n<p>难易程度：☆☆☆</p>\n<p>出现频率：☆☆</p>\n</blockquote>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185505677.png\" alt=\"image-20230428185505677\" /></p>\n<p>参考回答：</p>\n<p>该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容</p>\n<h4 id=\"224-面试题-如何实现数组和list之间的转换\"><a class=\"anchor\" href=\"#224-面试题-如何实现数组和list之间的转换\">#</a> 2.2.4 面试题 - 如何实现数组和 List 之间的转换</h4>\n<blockquote>\n<p>难易程度：☆☆☆</p>\n<p>出现频率：☆☆</p>\n</blockquote>\n<p>如下代码：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185600918.png\" alt=\"image-20230428185600918\" /></p>\n<p>参考回答：</p>\n<ul>\n<li>\n<p>数组转 List ，使用 JDK 中 java.util.Arrays 工具类的 asList 方法</p>\n</li>\n<li>\n<p>List 转数组，使用 List 的 toArray 方法。无参 toArray 方法返回 Object 数组，传入初始化长度的数组对象，返回该对象数组</p>\n</li>\n</ul>\n<p>面试官再问：</p>\n<p>1，用 Arrays.asList 转 List 后，如果修改了数组内容，list 受影响吗</p>\n<p>2，List 用 toArray 转数组后，如果修改了 List 内容，数组受影响吗</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185657791.png\" alt=\"image-20230428185657791\" /></p>\n<blockquote>\n<p>数组转 List 受影响</p>\n<p>List 转数组不受影响</p>\n</blockquote>\n<p>再答：</p>\n<p>1，用 Arrays.asList 转 List 后，如果修改了数组内容，list 受影响吗</p>\n<p>Arrays.asList 转换 list 之后，如果修改了数组的内容，list 会受影响，因为它的底层使用的 Arrays 类中的一个内部类 ArrayList 来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>\n<p>2，List 用 toArray 转数组后，如果修改了 List 内容，数组受影响吗</p>\n<p>list 用了 toArray 转数组后，如果修改了 list 内容，数组不会影响，当调用了 toArray 以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使 list 修改了以后，数组也不受影响</p>\n<h3 id=\"23-链表\"><a class=\"anchor\" href=\"#23-链表\">#</a> 2.3 链表</h3>\n<h4 id=\"231-单向链表\"><a class=\"anchor\" href=\"#231-单向链表\">#</a> 2.3.1 单向链表</h4>\n<ul>\n<li>\n<p>链表中的每一个元素称之为结点（Node）</p>\n</li>\n<li>\n<p>物理存储单元上，非连续、非顺序的存储结构</p>\n</li>\n<li>\n<p>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</p>\n</li>\n</ul>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185922776.png\" alt=\"image-20230428185922776\" /></p>\n<p>代码实现参考：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428185945929.png\" alt=\"image-20230428185945929\" /></p>\n<p>链表中的某个节点为 B，B 的下一个节点为 C         表示： B.next==C</p>\n<h4 id=\"232-单向链表时间复杂度分析\"><a class=\"anchor\" href=\"#232-单向链表时间复杂度分析\">#</a> 2.3.2 单向链表时间复杂度分析</h4>\n<p>（1）查询操作</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190130901.png\" alt=\"image-20230428190130901\" /></p>\n<ul>\n<li>\n<p>只有在查询头节点的时候不需要遍历链表，时间复杂度是 O (1)</p>\n</li>\n<li>\n<p>查询其他结点需要遍历链表，时间复杂度是 O (n)</p>\n</li>\n</ul>\n<p>（2）插入和删除操作</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190210915.png\" alt=\"image-20230428190210915\" /></p>\n<ul>\n<li>只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是 O (1)</li>\n<li>添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是 O (n)</li>\n</ul>\n<h4 id=\"233-双向链表\"><a class=\"anchor\" href=\"#233-双向链表\">#</a> 2.3.3 双向链表</h4>\n<p>而双向链表，顾名思义，它支持两个方向</p>\n<ul>\n<li>\n<p>每个结点不止有一个后继指针 next 指向后面的结点</p>\n</li>\n<li>\n<p>有一个前驱指针 prev 指向前面的结点</p>\n</li>\n</ul>\n<p>参考代码</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190324752.png\" alt=\"image-20230428190324752\" /></p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190353286.png\" alt=\"image-20230428190353286\" /></p>\n<p>对比单链表：</p>\n<ul>\n<li>\n<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</p>\n</li>\n<li>\n<p>支持双向遍历，这样也带来了双向链表操作的灵活性</p>\n</li>\n</ul>\n<h4 id=\"234-双向链表时间复杂度分析\"><a class=\"anchor\" href=\"#234-双向链表时间复杂度分析\">#</a> 2.3.4 双向链表时间复杂度分析</h4>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428190450517.png\" alt=\"image-20230428190450517\" /></p>\n<p>（1）查询操作</p>\n<ul>\n<li>\n<p>查询头尾结点的时间复杂度是 O (1)</p>\n</li>\n<li>\n<p>平均的查询时间复杂度是 O (n)</p>\n</li>\n<li>\n<p>给定节点找前驱节点的时间复杂度为 O (1)</p>\n</li>\n</ul>\n<p>（2）增删操作</p>\n<ul>\n<li>\n<p>头尾结点增删的时间复杂度为 O (1)</p>\n</li>\n<li>\n<p>其他部分结点增删的时间复杂度是 O (n)</p>\n</li>\n<li>\n<p>给定节点增删的时间复杂度为 O (1)</p>\n</li>\n</ul>\n<h4 id=\"235-面试题-arraylist和linkedlist的区别是什么\"><a class=\"anchor\" href=\"#235-面试题-arraylist和linkedlist的区别是什么\">#</a> 2.3.5 面试题 - ArrayList 和 LinkedList 的区别是什么？</h4>\n<ul>\n<li>\n<p>底层数据结构</p>\n<ul>\n<li>\n<p>ArrayList 是动态数组的数据结构实现</p>\n</li>\n<li>\n<p>LinkedList 是双向链表的数据结构实现</p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作数据效率</p>\n<ul>\n<li>ArrayList 按照下标查询的时间复杂度 O (1)【内存是连续的，根据寻址公式】， LinkedList 不支持下标查询</li>\n<li>查找（未知索引）： ArrayList 需要遍历，链表也需要链表，时间复杂度都是 O (n)</li>\n<li>新增和删除\n<ul>\n<li>ArrayList 尾部插入和删除，时间复杂度是 O (1)；其他部分增删需要挪动数组，时间复杂度是 O (n)</li>\n<li>LinkedList 头尾节点增删时间复杂度是 O (1)，其他都需要遍历链表，时间复杂度是 O (n)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>内存空间占用</p>\n<ul>\n<li>\n<p>ArrayList 底层是数组，内存连续，节省内存</p>\n</li>\n<li>\n<p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p>\n</li>\n</ul>\n</li>\n<li>\n<p>线程安全</p>\n<ul>\n<li>ArrayList 和 LinkedList 都不是线程安全的</li>\n<li>如果需要保证线程安全，有两种方案：\n<ul>\n<li>在方法内使用，局部变量则是线程安全的</li>\n<li>使用线程安全的 ArrayList 和 LinkedList</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-hashmap相关面试题\"><a class=\"anchor\" href=\"#3-hashmap相关面试题\">#</a> 3 HashMap 相关面试题</h2>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194715016.png\" alt=\"image-20230428194715016\" /></p>\n<h3 id=\"31-二叉树\"><a class=\"anchor\" href=\"#31-二叉树\">#</a> 3.1 二叉树</h3>\n<h4 id=\"311-二叉树概述\"><a class=\"anchor\" href=\"#311-二叉树概述\">#</a> 3.1.1 二叉树概述</h4>\n<p>二叉树，顾名思义，每个节点最多有两个 “叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>\n<p>二叉树每个节点的左子树和右子树也分别满足二叉树的定义。</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194831426.png\" alt=\"image-20230428194831426\" /></p>\n<p>Java 中有两个方式实现二叉树：数组存储，链式存储。</p>\n<p>基于链式存储的树的节点可定义如下：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194904383.png\" alt=\"image-20230428194904383\" /></p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428194931132.png\" alt=\"image-20230428194931132\" /></p>\n<h4 id=\"312-二叉搜索树\"><a class=\"anchor\" href=\"#312-二叉搜索树\">#</a> 3.1.2 二叉搜索树</h4>\n<p>在二叉树中，比较常见的二叉树有：</p>\n<ul>\n<li>\n<p>满二叉树</p>\n</li>\n<li>\n<p>完全二叉树</p>\n</li>\n<li>\n<p><strong>二叉搜索树</strong></p>\n</li>\n<li>\n<p><strong>红黑树</strong></p>\n</li>\n</ul>\n<p>我们重点讲解二叉搜索树和红黑树</p>\n<p>（1）二叉搜索树概述</p>\n<p>二叉搜索树 (Binary Search Tree,BST) 又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p>\n<p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195206422.png\" alt=\"image-20230428195206422\" /></p>\n<p>（2）二叉搜索树 - 时间复杂度分析</p>\n<p>实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195341917.png\" alt=\"image-20230428195341917\" /></p>\n<p>插入，查找，删除的时间复杂度<strong> O (logn)</strong></p>\n<p>极端情况下二叉搜索的时间复杂度</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195449799.png\" alt=\"image-20230428195449799\" /></p>\n<p>对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是 O (n)。</p>\n<h4 id=\"313-红黑树\"><a class=\"anchor\" href=\"#313-红黑树\">#</a> 3.1.3 红黑树</h4>\n<p>（1）概述</p>\n<p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树 (BST)，之前叫做平衡二叉 B 树（Symmetric Binary B-Tree）</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428195832724.png\" alt=\"image-20230428195832724\" /></p>\n<p>（2）红黑树的特质</p>\n<p>性质 1：节点要么是<strong>红色</strong>，要么是<strong>黑色</strong></p>\n<p>性质 2：根节点是<strong>黑色</strong></p>\n<p>性质 3：叶子节点都是黑色的空节点</p>\n<p>性质 4：红黑树中红色节点的子节点都是黑色</p>\n<p>性质 5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p>\n<p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong></p>\n<p>（3）红黑树的复杂度</p>\n<ul>\n<li>\n<p>查找：</p>\n<ul>\n<li>红黑树也是一棵 BST（二叉搜索树）树，查找操作的时间复杂度为：O (log n)</li>\n</ul>\n</li>\n<li>\n<p>添加：</p>\n<ul>\n<li>添加先要从根节点开始找到元素添加的位置，时间复杂度 O (log n)</li>\n<li>添加完成后涉及到复杂度为 O (1) 的旋转调整操作</li>\n<li>故整体复杂度为：O (log n)</li>\n</ul>\n</li>\n<li>\n<p>删除：</p>\n<ul>\n<li>首先从根节点开始找到被删除元素的位置，时间复杂度 O (log n)</li>\n<li>删除完成后涉及到复杂度为 O (1) 的旋转调整操作</li>\n<li>故整体复杂度为：O (log n)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"32-散列表\"><a class=\"anchor\" href=\"#32-散列表\">#</a> 3.2 散列表</h3>\n<p>在 HashMap 中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p>\n<h4 id=\"321-散列表hash-table概述\"><a class=\"anchor\" href=\"#321-散列表hash-table概述\">#</a> 3.2.1 散列表（Hash Table）概述</h4>\n<p>散列表 (Hash Table) 又名哈希表 / Hash 表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p>\n<p>举个例子：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428200919454.png\" alt=\"image-20230428200919454\" /></p>\n<p>假设有 100 个人参加马拉松，编号是 1-100，如果要编程实现根据选手的编号迅速找到选手信息？</p>\n<p>可以把选手信息存入数组中，选手编号就是数组的下标，数组的元素就是选手的信息。</p>\n<p>当我们查询选手信息的时候，只需要根据选手的编号到数组中查询对应的元素就可以快速找到选手的信息，如下图：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428201000814.png\" alt=\"image-20230428201000814\" /></p>\n<p>现在需求升级了：</p>\n<p>假设有 100 个人参加马拉松，不采用 1-100 的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中 2023 代表年份，ZH 代表中国，BJ 代表北京，001 代表原来的编号，那此时的编号 2023ZHBJ001 不能直接作为数组的下标，此时应该如何实现呢？</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428201321607.png\" alt=\"image-20230428201321607\" /></p>\n<p>我们目前是把选手的信息存入到数组中，不过选手的编号不能直接作为数组的下标，不过，可以把选手的选号进行转换，转换为数值就可以继续作为数组的下标了？</p>\n<p>转换可以使用散列函数进行转换</p>\n<h4 id=\"322-散列函数和散列冲突\"><a class=\"anchor\" href=\"#322-散列函数和散列冲突\">#</a> 3.2.2 散列函数和散列冲突</h4>\n<p>将键 (key) 映射为数组下标的函数叫做散列函数。可以表示为：hashValue = hash (key)</p>\n<p>散列函数的基本要求：</p>\n<ul>\n<li>\n<p>散列函数计算得到的散列值必须是大于等于 0 的正整数，因为 hashValue 需要作为数组的下标。</p>\n</li>\n<li>\n<p>如果 key1==key2，那么经过 hash 后得到的哈希值也必相同即：hash (key1) == hash (key2）</p>\n</li>\n<li>\n<p><strong>如果 key1 != key2，那么经过 hash 后得到的哈希值也必不相同即：hash (key1) != hash (key2)</strong></p>\n</li>\n</ul>\n<p>实际的情况下想找一个散列函数能够做到对于不同的 key 计算得到的散列值都不同几乎是不可能的，即便像著名的 MD5,SHA 等哈希算法也无法避免这一情况，这就是散列冲突 (或者哈希冲突，哈希碰撞，<strong>就是指多个 key 映射到同一个数组下标位置</strong>)</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203219225.png\" alt=\"image-20230428203219225\" /></p>\n<h4 id=\"323-散列冲突-链表法拉链\"><a class=\"anchor\" href=\"#323-散列冲突-链表法拉链\">#</a> 3.2.3 散列冲突 - 链表法（拉链）</h4>\n<p>在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶 (槽) 会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203437910.png\" alt=\"image-20230428203437910\" /></p>\n<p>简单就是，如果有多个 key 最终的 hash 值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据</p>\n<h4 id=\"324-时间复杂度-散列表\"><a class=\"anchor\" href=\"#324-时间复杂度-散列表\">#</a> 3.2.4 时间复杂度 - 散列表</h4>\n<p>1，插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O (1)</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203711269.png\" alt=\"image-20230428203711269\" /></p>\n<blockquote>\n<p>通过计算就可以找到元素</p>\n</blockquote>\n<p>2，当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p>\n<ul>\n<li>\n<p>平均情况下基于链表法解决冲突时查询的时间复杂度是 O (1)</p>\n</li>\n<li>\n<p>散列表可能会退化为链表，查询的时间复杂度就从 O (1) 退化为 O (n)</p>\n</li>\n</ul>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203858903.png\" alt=\"image-20230428203858903\" /></p>\n<ul>\n<li>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O (logn)</li>\n</ul>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428203924816.png\" alt=\"image-20230428203924816\" /></p>\n<p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止 DDos 攻击</p>\n<blockquote>\n<p>DDos 攻击:</p>\n<p>分布式拒绝服务攻击 (英文意思是 Distributed Denial of Service，简称 DDoS）</p>\n<p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个</p>\n</blockquote>\n<h3 id=\"33-面试题-说一下hashmap的实现原理\"><a class=\"anchor\" href=\"#33-面试题-说一下hashmap的实现原理\">#</a> 3.3 面试题 - 说一下 HashMap 的实现原理？</h3>\n<p>HashMap 的数据结构： 底层使用 hash 表数据结构，即数组和链表或红黑树</p>\n<ol>\n<li>\n<p>当我们往 HashMap 中 put 元素时，利用 key 的 hashCode 重新 hash 计算出当前对象的元素在数组中的下标</p>\n</li>\n<li>\n<p>存储时，如果出现 hash 值相同的 key，此时有两种情况。</p>\n</li>\n</ol>\n<p>a. 如果 key 相同，则覆盖原始值；</p>\n<p>b. 如果 key 不同（出现冲突），则将当前的 key-value 放入链表或红黑树中</p>\n<ol start=\"3\">\n<li>获取时，直接找到 hash 值对应的下标，在进一步判断 key 是否相同，从而找到对应值。</li>\n</ol>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428204902016.png\" alt=\"image-20230428204902016\" /></p>\n<p>面试官追问：HashMap 的 jdk1.7 和 jdk1.8 有什么区别</p>\n<ul>\n<li>\n<p>JDK1.8 之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n</li>\n<li>\n<p>jdk1.8 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8） 时并且数组长度达到 64 时，将链表转化为红黑树，以减少搜索时间。扩容 resize ( ) 时，红黑树拆分成的树的结点数小于等于临界值 6 个，则退化成链表</p>\n</li>\n</ul>\n<h3 id=\"34-面试题-hashmap的put方法的具体流程\"><a class=\"anchor\" href=\"#34-面试题-hashmap的put方法的具体流程\">#</a> 3.4 面试题 - HashMap 的 put 方法的具体流程</h3>\n<h4 id=\"341-hashmap常见属性\"><a class=\"anchor\" href=\"#341-hashmap常见属性\">#</a> 3.4.1 hashMap 常见属性</h4>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210404117.png\" alt=\"image-20230428210404117\" /></p>\n<h4 id=\"342-源码分析\"><a class=\"anchor\" href=\"#342-源码分析\">#</a> 3.4.2 源码分析</h4>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210450744.png\" alt=\"image-20230428210450744\" /></p>\n<ul>\n<li>\n<p>HashMap 是懒惰加载，在创建对象时并没有初始化数组</p>\n</li>\n<li>\n<p>在无参的构造函数中，设置了默认的加载因子是 0.75</p>\n</li>\n</ul>\n<p>添加数据流程图</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210624847.png\" alt=\"image-20230428210624847\" /></p>\n<p>具体的源码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> onlyIfAbsent<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                   <span class=\"token keyword\">boolean</span> evict<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> p<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 判断数组是否未初始化</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">// 如果未初始化，调用 resize 方法 进行初始化</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token comment\">// 如果没有，直接将数据放在该下标位置</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// 该数组下标有数据的情况</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e<span class=\"token punctuation\">;</span> <span class=\"token class-name\">K</span> k<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token comment\">// 判断该位置数据的 key 和新来的数据是否一样</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token comment\">// 如果一样，证明为修改操作，该节点的数据赋值给 e, 后边会用到</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 判断是不是红黑树</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token comment\">// 如果是红黑树的话，进行红黑树的操作</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TreeNode</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">putTreeVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token comment\">// 新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token comment\">// 遍历链表</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> binCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>binCount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token comment\">// 判断 next 节点，如果为空的话，证明遍历到链表尾部了</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                    <span class=\"token comment\">// 把新值放入链表尾部</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                    p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                    <span class=\"token comment\">// 因为新插入了一条数据，所以判断链表长度是不是大于等于 8</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>binCount <span class=\"token operator\">>=</span> <span class=\"token constant\">TREEIFY_THRESHOLD</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// -1 for 1st</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                        <span class=\"token comment\">// 如果是，进行转换红黑树操作</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                        <span class=\"token function\">treeifyBin</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                <span class=\"token comment\">// 判断链表当中有数据相同的值，如果一样，证明为修改操作</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>                <span class=\"token comment\">// 把下一个节点赋值为当前节点</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>        <span class=\"token comment\">// 判断 e 是否为空（e 值为修改操作存放原数据的变量）</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// existing mapping for key</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>            <span class=\"token comment\">// 不为空的话证明是修改操作，取出老值</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>            <span class=\"token class-name\">V</span> oldValue <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token comment\">// 一定会执行  onlyIfAbsent 传进来的是 false</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>onlyIfAbsent <span class=\"token operator\">||</span> oldValue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>                <span class=\"token comment\">// 将新值赋值当前节点</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>                e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>            <span class=\"token function\">afterNodeAccess</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>            <span class=\"token comment\">// 返回老值</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>            <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>    <span class=\"token comment\">// 计数器，计算当前节点的修改次数</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>    <span class=\"token operator\">++</span>modCount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>    <span class=\"token comment\">// 当前数组中的数据数量如果大于扩容阈值</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>size <span class=\"token operator\">></span> threshold<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>        <span class=\"token comment\">// 进行扩容操作</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    <span class=\"token comment\">// 空方法</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>    <span class=\"token function\">afterNodeInsertion</span><span class=\"token punctuation\">(</span>evict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>    <span class=\"token comment\">// 添加操作时 返回空值</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol>\n<li>\n<p>判断键值对数组 table 是否为空或为 null，否则执行 resize () 进行扩容（初始化）</p>\n</li>\n<li>\n<p>根据键值 key 计算 hash 值得到数组索引</p>\n</li>\n<li>\n<p>判断 table [i]==null，条件成立，直接新建节点添加</p>\n</li>\n<li>\n<p>如果 table [i]==null , 不成立</p>\n<p>4.1 判断 table [i] 的首个元素是否和 key 一样，如果相同直接覆盖 value</p>\n<p>4.2 判断 table [i] 是否为 treeNode，即 table [i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p>\n<p>4.3 遍历 table [i]，链表的尾部插入数据，然后判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现 key 已经存在直接覆盖 value</p>\n</li>\n<li>\n<p>插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold（数组长度 * 0.75），如果超过，进行扩容。</p>\n</li>\n</ol>\n<h3 id=\"35-面试题-讲一讲hashmap的扩容机制\"><a class=\"anchor\" href=\"#35-面试题-讲一讲hashmap的扩容机制\">#</a> 3.5 面试题 - 讲一讲 HashMap 的扩容机制</h3>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428210844694.png\" alt=\"image-20230428210844694\" /></p>\n<p>扩容的流程：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428211031968.png\" alt=\"image-20230428211031968\" /></p>\n<p>源码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 扩容、初始化数组</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">final</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> oldTab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    \t<span class=\"token comment\">// 如果当前数组为 null 的时候，把 oldCap 老数组容量设置为 0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">int</span> oldCap <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>oldTab <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> oldTab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 老的扩容阈值</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    \t<span class=\"token keyword\">int</span> oldThr <span class=\"token operator\">=</span> threshold<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">int</span> newCap<span class=\"token punctuation\">,</span> newThr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 判断数组容量是否大于 0，大于 0 说明数组已经初始化</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCap <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token comment\">// 判断当前数组长度是否大于最大数组长度</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCap <span class=\"token operator\">>=</span> <span class=\"token constant\">MAXIMUM_CAPACITY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                <span class=\"token comment\">// 如果是，将扩容阈值直接设置为 int 类型的最大数值并直接返回</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                threshold <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token keyword\">return</span> oldTab<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token comment\">// 如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1 等价于 oldCap*2</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token comment\">// 运算过后判断是不是最大值并且 oldCap 需要大于 16</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">=</span> oldCap <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">MAXIMUM_CAPACITY</span> <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                     oldCap <span class=\"token operator\">>=</span> <span class=\"token constant\">DEFAULT_INITIAL_CAPACITY</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                newThr <span class=\"token operator\">=</span> oldThr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//double threshold  等价于 oldThr*2</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    \t<span class=\"token comment\">// 如果 oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       \t\t\t如果是首次初始化，它的临界值则为 0</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldThr <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// initial capacity was placed in threshold</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            newCap <span class=\"token operator\">=</span> oldThr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">// 数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    \t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>               <span class=\"token comment\">// zero initial threshold signifies using defaults</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            newCap <span class=\"token operator\">=</span> <span class=\"token constant\">DEFAULT_INITIAL_CAPACITY</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            newThr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token constant\">DEFAULT_LOAD_FACTOR</span> <span class=\"token operator\">*</span> <span class=\"token constant\">DEFAULT_INITIAL_CAPACITY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    \t<span class=\"token comment\">// 初始化容量小于 16 的时候，扩容阈值是没有赋值的</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newThr <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token comment\">// 创建阈值</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token keyword\">float</span> ft <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>newCap <span class=\"token operator\">*</span> loadFactor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>            <span class=\"token comment\">// 判断新容量和新阈值是否大于最大容量</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            newThr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">&lt;</span> <span class=\"token constant\">MAXIMUM_CAPACITY</span> <span class=\"token operator\">&amp;&amp;</span> ft <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token constant\">MAXIMUM_CAPACITY</span> <span class=\"token operator\">?</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                      <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>ft <span class=\"token operator\">:</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    \t<span class=\"token comment\">// 计算出来的阈值赋值</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        threshold <span class=\"token operator\">=</span> newThr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"rawtypes\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token comment\">// 根据上边计算得出的容量 创建新的数组       </span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    \t<span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTab <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">[</span>newCap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    \t<span class=\"token comment\">// 赋值</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    \ttable <span class=\"token operator\">=</span> newTab<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    \t<span class=\"token comment\">// 扩容操作，判断不为空证明不是初始化数组</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldTab <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>            <span class=\"token comment\">// 遍历数组</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> oldCap<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>                <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>                <span class=\"token comment\">// 判断当前下标为 j 的数组如果不为空的话赋值个 e，进行下一步操作</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> oldTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>                    <span class=\"token comment\">// 将数组位置置空</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>                    oldTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>                    <span class=\"token comment\">// 判断是否有下个节点</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>                        <span class=\"token comment\">// 如果没有，就重新计算在新数组中的下标并放进去</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>                        newTab<span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>                   \t<span class=\"token comment\">// 有下个节点的情况，并且判断是否已经树化</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>                    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>                        <span class=\"token comment\">// 进行红黑树的操作</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>                        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TreeNode</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> newTab<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> oldCap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>                    <span class=\"token comment\">// 有下个节点的情况，并且没有树化（链表形式）</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>                        <span class=\"token comment\">// 比如老数组容量是 16，那下标就为 0-15</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>                        <span class=\"token comment\">// 扩容操作 * 2，容量就变为 32，下标为 0-31</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>                        <span class=\"token comment\">// 低位：0-15，高位 16-31</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>                        <span class=\"token comment\">// 定义了四个变量</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                        <span class=\"token comment\">//        低位头          低位尾</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> loHead <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> loTail <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                        <span class=\"token comment\">//        高位头\t\t   高位尾</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>                        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> hiHead <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> hiTail <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>                        <span class=\"token comment\">// 下个节点</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>                        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>                        <span class=\"token comment\">// 循环遍历</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>                        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>                            <span class=\"token comment\">// 取出 next 节点</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>                            next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>                            <span class=\"token comment\">// 通过 与操作 计算得出结果为 0</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">&amp;</span> oldCap<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>                                <span class=\"token comment\">// 如果低位尾为 null，证明当前数组位置为空，没有任何数据</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loTail <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>                                    <span class=\"token comment\">// 将 e 值放入低位头</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>                                    loHead <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>                                <span class=\"token comment\">// 低位尾不为 null，证明已经有数据了</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>                                <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>                                    <span class=\"token comment\">// 将数据放入 next 节点</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>                                    loTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>                                <span class=\"token comment\">// 记录低位尾数据</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>                                loTail <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>                            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>                            <span class=\"token comment\">// 通过 与操作 计算得出结果不为 0</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>                            <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>                                 <span class=\"token comment\">// 如果高位尾为 null，证明当前数组位置为空，没有任何数据</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hiTail <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>                                    <span class=\"token comment\">// 将 e 值放入高位头</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>                                    hiHead <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>                                <span class=\"token comment\">// 高位尾不为 null，证明已经有数据了</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>                                <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>                                    <span class=\"token comment\">// 将数据放入 next 节点</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>                                    hiTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>                               <span class=\"token comment\">// 记录高位尾数据</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>                               \thiTail <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>                            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>                            </pre></td></tr><tr><td data-num=\"106\"></td><td><pre>                        <span class=\"token punctuation\">&#125;</span> </pre></td></tr><tr><td data-num=\"107\"></td><td><pre>                        <span class=\"token comment\">// 如果 e 不为空，证明没有到链表尾部，继续执行循环</span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>                        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>                        <span class=\"token comment\">// 低位尾如果记录的有数据，是链表</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre>                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loTail <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre>                            <span class=\"token comment\">// 将下一个元素置空</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>                            loTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre>                            <span class=\"token comment\">// 将低位头放入新数组的原下标位置</span></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>                            newTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> loHead<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>                        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre>                        <span class=\"token comment\">// 高位尾如果记录的有数据，是链表</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre>                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hiTail <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"118\"></td><td><pre>                            <span class=\"token comment\">// 将下一个元素置空</span></pre></td></tr><tr><td data-num=\"119\"></td><td><pre>                            hiTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"120\"></td><td><pre>                            <span class=\"token comment\">// 将高位头放入新数组的 (原下标 + 原数组容量) 位置</span></pre></td></tr><tr><td data-num=\"121\"></td><td><pre>                            newTab<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> oldCap<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> hiHead<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"122\"></td><td><pre>                        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"123\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"124\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"125\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"126\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"127\"></td><td><pre>    \t<span class=\"token comment\">// 返回新的数组对象</span></pre></td></tr><tr><td data-num=\"128\"></td><td><pre>        <span class=\"token keyword\">return</span> newTab<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"129\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>\n<p>在添加元素或初始化的时候需要调用 resize 方法进行扩容，第一次添加数据初始化数组长度为 16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>\n</li>\n<li>\n<p>每次扩容的时候，都是扩容之前容量的 2 倍；</p>\n</li>\n<li>\n<p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>\n<ul>\n<li>没有 hash 冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li>\n<li>如果是红黑树，走红黑树的添加</li>\n<li>如果是链表，则需要遍历链表，可能需要拆分链表，判断 (e.hash &amp; oldCap) 是否为 0，该元素的位置要么停留在原始位置，要么移动到原始位置 + 增加的数组大小这个位置上</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"36-面试题-hashmap的寻址算法\"><a class=\"anchor\" href=\"#36-面试题-hashmap的寻址算法\">#</a> 3.6 面试题 - hashMap 的寻址算法</h3>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428212501408.png\" alt=\"image-20230428212501408\" /></p>\n<p>在 putVal 方法中，有一个 hash (key) 方法，这个方法就是来去计算 key 的 hash 值的，看下面的代码</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428212601977.png\" alt=\"image-20230428212601977\" /></p>\n<p>首先获取 key 的 hashCode 值，然后右移 16 位 异或运算 原来的 hashCode 值，主要作用就是使原来的 hash 值更加均匀，减少 hash 冲突</p>\n<p>有了 hash 值之后，就很方便的去计算当前 key 的在数组中存储的下标，看下面的代码：</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428212729580.png\" alt=\"image-20230428212729580\" /></p>\n<p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是 2 的 n 次幂</p>\n<p><strong>关于 hash 值的其他面试题：为何 HashMap 的数组长度一定是 2 的次幂？</strong></p>\n<ol>\n<li>\n<p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>\n</li>\n<li>\n<p>扩容时重新计算索引效率更高： hash &amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap</p>\n</li>\n</ol>\n<h3 id=\"37-面试题-hashmap在17情况下的多线程死循环问题\"><a class=\"anchor\" href=\"#37-面试题-hashmap在17情况下的多线程死循环问题\">#</a> 3.7 面试题 - hashmap 在 1.7 情况下的多线程死循环问题</h3>\n<p>jdk7 的的数据结构是：数组 + 链表</p>\n<p>在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428213115071.png\" alt=\"image-20230428213115071\" /></p>\n<ul>\n<li>\n<p>变量 e 指向的是需要迁移的对象</p>\n</li>\n<li>\n<p>变量 next 指向的是下一个需要迁移的对象</p>\n</li>\n<li>\n<p>Jdk1.7 中的链表采用的头插法</p>\n</li>\n<li>\n<p>在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用</p>\n</li>\n</ul>\n<p>产生死循环的过程：</p>\n<p>线程 1 和线程 2 的变量 e 和 next 都引用了这个两个节点</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428213533483.png\" alt=\"image-20230428213533483\" /></p>\n<p>线程 2 扩容后，由于头插法，链表顺序颠倒，但是线程 1 的临时变量 e 和 next 还引用了这两个节点</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214732877.png\" alt=\"image-20230428214732877\" /></p>\n<p>第一次循环</p>\n<p>由于线程 2 迁移的时候，已经把 B 的 next 执行了 A</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214806072.png\" alt=\"image-20230428214806072\" /></p>\n<p>第二次循环</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214908652.png\" alt=\"image-20230428214908652\" /></p>\n<p>第三次循环</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230428214937231.png\" alt=\"image-20230428214937231\" /></p>\n<p>参考回答：</p>\n<p>在 jdk1.7 的 hashmap 中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p>\n<p>比如说，现在有两个线程</p>\n<p>线程一：读取到当前的 hashmap 数据，数据中一个链表，在准备扩容时，线程二介入</p>\n<p>线程二：也读取 hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是 AB，扩容后的顺序是 BA，线程二执行结束。</p>\n<p>线程一：继续执行的时候就会出现死循环的问题。</p>\n<p>线程一先将 A 移入新的链表，再将 B 插入到链头，由于另外一个线程的原因，B 的 next 指向了 A，</p>\n<p>所以 B-&gt;A-&gt;B, 形成循环。</p>\n<p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了 jdk7 中死循环的问题。</p>\n<h3 id=\"38-面试题-hashset与hashmap的区别\"><a class=\"anchor\" href=\"#38-面试题-hashset与hashmap的区别\">#</a> 3.8 面试题 - HashSet 与 HashMap 的区别</h3>\n<p>(1) HashSet 实现了 Set 接口，仅存储对象；HashMap 实现了 Map 接口，存储的是键值对.</p>\n<p>(2) HashSet 底层其实是用 HashMap 实现存储的，HashSet 封装了一系列 HashMap 的方法。依靠 HashMap 来存储元素值，(利用 hashMap 的 key 键进行存储), 而 value 值默认为 Object 对象。所以 HashSet 也不允许出现重复值，判断标准和 HashMap 判断标准相同，两个元素的 hashCode 相等并且通过 equals () 方法返回 true.</p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20221007110404375.png\" alt=\"image-20221007110404375\" /></p>\n<h3 id=\"39-面试题-hashtable与hashmap的区别\"><a class=\"anchor\" href=\"#39-面试题-hashtable与hashmap的区别\">#</a> 3.9 面试题 - HashTable 与 HashMap 的区别</h3>\n<blockquote>\n<p>难易程度：☆☆</p>\n<p>出现频率：☆☆</p>\n</blockquote>\n<p>主要区别：</p>\n<table>\n<thead>\n<tr>\n<th><strong>区别</strong></th>\n<th><strong>HashTable</strong></th>\n<th><strong>HashMap</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据结构</td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td>是否可以为 null</td>\n<td>Key 和 value 都不能为 null</td>\n<td>可以为 null</td>\n</tr>\n<tr>\n<td>hash 算法</td>\n<td>key 的 hashCode ()</td>\n<td>二次 hash</td>\n</tr>\n<tr>\n<td>扩容方式</td>\n<td>当前容量翻倍 +1</td>\n<td>当前容量翻倍</td>\n</tr>\n<tr>\n<td>线程安全</td>\n<td>同步 (synchronized) 的，线程安全</td>\n<td>非线程安全</td>\n</tr>\n</tbody>\n</table>\n<p>在实际开中不建议使用 HashTable，在多线程环境下可以使用 ConcurrentHashMap 类</p>\n<h2 id=\"3-真实面试还原\"><a class=\"anchor\" href=\"#3-真实面试还原\">#</a> 3 真实面试还原</h2>\n<h3 id=\"31-java常见的集合类\"><a class=\"anchor\" href=\"#31-java常见的集合类\">#</a> 3.1 Java 常见的集合类</h3>\n<blockquote>\n<p><strong>面试官</strong>：说一说 Java 提供的常见集合？（画一下集合结构图）</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯～～，好的。</p>\n<p>在 java 中提供了量大类的集合框架，主要分为两类：</p>\n<p>第一个是 Collection  属于单列集合，第二个是 Map  属于双列集合</p>\n<ul>\n<li>在 Collection 中有两个子接口 List 和 Set。在我们平常开发的过程中用的比较多像 list 接口中的实现类 ArrarList 和 LinkedList。  在 Set 接口中有实现类 HashSet 和 TreeSet。</li>\n<li>在 map 接口中有很多的实现类，平时比较常见的是 HashMap、TreeMap，还有一个线程安全的 map:ConcurrentHashMap</li>\n</ul>\n</blockquote>\n<h3 id=\"32-list\"><a class=\"anchor\" href=\"#32-list\">#</a> 3.2 List</h3>\n<blockquote>\n<p><strong>面试官</strong>：ArrayList 底层是如何实现的？</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯～，我阅读过 arraylist 的源码，我主要说一下 add 方法吧</p>\n<p>第一：确保数组已使用长度（size）加 1 之后足够存下下一个数据</p>\n<p>第二：计算数组的容量，如果当前数组已使用长度 + 1 后的大于当前的数组长度，则调用 grow 方法扩容（原来的 1.5 倍）</p>\n<p>第三：确保新增的数据有地方存储之后，则将新元素添加到位于 size 的位置上。</p>\n<p>第四：返回添加成功布尔值。</p>\n<p><strong>面试官</strong>：ArrayList list=new ArrayList (10) 中的 list 扩容几次</p>\n<p><strong>候选人</strong>：</p>\n<p>​\t是 new 了一个 ArrarList 并且给了一个构造参数 10，对吧？(问题一定要问清楚再答)</p>\n<p><strong>面试官</strong>：是的</p>\n<p><strong>候选人</strong>：</p>\n<p>​    好的，在 ArrayList 的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个 10 的参数，就是指定了集合的初始长度是 10，这里面并没有扩容。</p>\n<hr />\n<p><strong>面试官</strong>：如何实现数组和 List 之间的转换</p>\n<p><strong>候选人</strong>：</p>\n<p>​\t嗯，这个在我们平时开发很常见</p>\n<p>​    数组转 list，可以使用 jdk 自动的一个工具类 Arrars，里面有一个 asList 方法可以转换为数组</p>\n<p>​    List 转数组，可以直接调用 list 中的 toArray 方法，需要给一个参数，指定数组的类型，需要指定数组的长度。</p>\n<p><strong>面试官</strong>：用 Arrays.asList 转 List 后，如果修改了数组内容，list 受影响吗？List 用 toArray 转数组后，如果修改了 List 内容，数组受影响吗</p>\n<p><strong>候选人</strong>：</p>\n<p>Arrays.asList 转换 list 之后，如果修改了数组的内容，list 会受影响，因为它的底层使用的 Arrays 类中的一个内部类 ArrayList 来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>\n<p>list 用了 toArray 转数组后，如果修改了 list 内容，数组不会影响，当调用了 toArray 以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使 list 修改了以后，数组也不受影响</p>\n<hr />\n<p><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。</p>\n<p>1，从操作数据效率来说</p>\n<p>ArrayList 按照下标查询的时间复杂度 O (1)【内存是连续的，根据寻址公式】， LinkedList 不支持下标查询</p>\n<p>查找（未知索引）： ArrayList 需要遍历，链表也需要链表，时间复杂度都是 O (n)</p>\n<p>新增和删除</p>\n<ul>\n<li>ArrayList 尾部插入和删除，时间复杂度是 O (1)；其他部分增删需要挪动数组，时间复杂度是 O (n)</li>\n<li>LinkedList 头尾节点增删时间复杂度是 O (1)，其他都需要遍历链表，时间复杂度是 O (n)</li>\n</ul>\n<p>2，从内存空间占用来说</p>\n<p>ArrayList 底层是数组，内存连续，节省内存</p>\n<p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p>\n<p>3，从线程安全来说，ArrayList 和 LinkedList 都不是线程安全的</p>\n<p><strong>面试官</strong>：嗯，好的，刚才你说了 ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯，是这样的，主要有两种解决方案：</p>\n<p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p>\n<p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p>\n<p>ArrayList 可以通过 Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p>\n<p>LinkedList 换成 ConcurrentLinkedQueue 来使用</p>\n</blockquote>\n<h3 id=\"34-hashmap\"><a class=\"anchor\" href=\"#34-hashmap\">#</a> 3.4 HashMap</h3>\n<blockquote>\n<p><strong>面试官</strong>：说一下 HashMap 的实现原理？</p>\n<p><strong>候选人</strong>：</p>\n<p>​\t嗯。它主要分为了一下几个部分：</p>\n<p>1，底层使用 hash 表数据结构，即数组 +（链表 | 红黑树）</p>\n<p>2，添加数据时，计算 key 的值确定元素在数组中的下标</p>\n<p>​\tkey 相同则替换</p>\n<p>​\t不同则存入链表或红黑树中</p>\n<p>3，获取数据通过 key 的 hash 计算数组下标获取元素</p>\n<p><strong>面试官</strong>：HashMap 的 jdk1.7 和 jdk1.8 有什么区别</p>\n<p><strong>候选人</strong>：</p>\n<ul>\n<li>\n<p>JDK1.8 之前采用的拉链法，数组 + 链表</p>\n</li>\n<li>\n<p>JDK1.8 之后采用数组 + 链表 + 红黑树，链表长度大于 8 且数组长度大于 64 则会从链表转化为红黑树</p>\n</li>\n</ul>\n<p><strong>面试官</strong>：好的，你能说下 HashMap 的 put 方法的具体流程吗？</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯好的。</p>\n<ol>\n<li>\n<p>判断键值对数组 table 是否为空或为 null，否则执行 resize () 进行扩容（初始化）</p>\n</li>\n<li>\n<p>根据键值 key 计算 hash 值得到数组索引</p>\n</li>\n<li>\n<p>判断 table [i]==null，条件成立，直接新建节点添加</p>\n</li>\n<li>\n<p>如果 table [i]==null , 不成立</p>\n</li>\n</ol>\n<p>4.1 判断 table [i] 的首个元素是否和 key 一样，如果相同直接覆盖 value</p>\n<p>4.2 判断 table [i] 是否为 treeNode，即 table [i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p>\n<p>4.3 遍历 table [i]，链表的尾部插入数据，然后判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现 key 已经存在直接覆盖 value</p>\n<ol start=\"5\">\n<li>插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold（数组长度 * 0.75），如果超过，进行扩容。</li>\n</ol>\n<p><strong>面试官</strong>：好的，刚才你多次介绍了 hsahmap 的扩容，能讲一讲 HashMap 的扩容机制吗？</p>\n<p><strong>候选人</strong>：</p>\n<p>好的</p>\n<ul>\n<li>\n<p>在添加元素或初始化的时候需要调用 resize 方法进行扩容，第一次添加数据初始化数组长度为 16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>\n</li>\n<li>\n<p>每次扩容的时候，都是扩容之前容量的 2 倍；</p>\n</li>\n<li>\n<p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>\n</li>\n<li>\n<p>没有 hash 冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p>\n</li>\n<li>\n<p>如果是红黑树，走红黑树的添加</p>\n</li>\n<li>\n<p>如果是链表，则需要遍历链表，可能需要拆分链表，判断 (e.hash &amp; oldCap) 是否为 0，该元素的位置要么停留在原始位置，要么移动到原始位置 + 增加的数组大小这个位置上</p>\n</li>\n</ul>\n<p><strong>面试官</strong>：好的，刚才你说的通过 hash 计算后找到数组的下标，是如何找到的呢，你了解 hashMap 的寻址算法吗？</p>\n<p><strong>候选人</strong>：</p>\n<p>这个哈希方法首先计算出 key 的 hashCode 值，然后通过这个 hash 值右移 16 位后的二进制进行按位<strong>异或运算</strong>得到最后的 hash 值。</p>\n<p>在 putValue 的方法中，计算数组下标的时候使用 hash 值与数组长度取模得到存储数据下标的位置，hashmap 为了性能更好，并没有直接采用取模的方式，而是使用了数组长度 - 1 得到一个值，用这个值按位与运算 hash 值，最终得到数组的位置。</p>\n<p><strong>面试官</strong>：为何 HashMap 的数组长度一定是 2 的次幂？</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯，好的。hashmap 这么设计主要有两个原因：</p>\n<p>第一：</p>\n<p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>\n<p>第二：</p>\n<p>扩容时重新计算索引效率更高：在进行扩容是会进行判断 hash 值按位与运算旧数组长租是否 == 0</p>\n<p>如果等于 0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标 + 旧数组长度</p>\n<p><strong>面试官</strong>：好的，我看你对 hashmap 了解的挺深入的，你知道 hashmap 在 1.7 情况下的多线程死循环问题吗？</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯，知道的。是这样</p>\n<p>jdk7 的的数据结构是：数组 + 链表</p>\n<p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p>\n<p>比如说，现在有两个线程</p>\n<p>线程一：<strong>读取</strong>到当前的 hashmap 数据，数据中一个链表，在准备扩容时，线程二介入</p>\n<p>线程二也读取 hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是 AB，扩容后的顺序是 BA，线程二执行结束。</p>\n<p>当线程一再继续执行的时候就会出现死循环的问题。</p>\n<p>线程一先将 A 移入新的链表，再将 B 插入到链头，由于另外一个线程的原因，B 的 next 指向了 A，所以 B-&gt;A-&gt;B, 形成循环。</p>\n<p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了 jdk7 中死循环的问题。</p>\n<p><strong>面试官</strong>：好的，hashmap 是线程安全的吗？</p>\n<p><strong>候选人</strong>：不是线程安全的</p>\n<p><strong>面试官</strong>：那我们想要使用线程安全的 map 该怎么做呢？</p>\n<p><strong>候选人</strong>：我们可以采用 ConcurrentHashMap 进行使用，它是一个线程安全的 HashMap</p>\n<p><strong>面试官</strong>：那你能聊一下 ConcurrentHashMap 的原理吗？</p>\n<p><strong>候选人</strong>：好的，请参考《多线程相关面试题》中的 ConcurrentHashMap 部分的讲解</p>\n<hr />\n<p><strong>面试官</strong>：HashSet 与 HashMap 的区别？</p>\n<p><strong>候选人</strong>：嗯，是这样。</p>\n<p>HashSet 底层其实是用 HashMap 实现存储的，HashSet 封装了一系列 HashMap 的方法。依靠 HashMap 来存储元素值，(利用 hashMap 的 key 键进行存储), 而 value 值默认为 Object 对象。所以 HashSet 也不允许出现重复值，判断标准和 HashMap 判断标准相同，两个元素的 hashCode 相等并且通过 equals () 方法返回 true.</p>\n<p><strong>面试官</strong>：HashTable 与 HashMap 的区别</p>\n<p><strong>候选人</strong>：</p>\n<p>嗯，他们的主要区别是有几个吧</p>\n<p>第一，数据结构不一样，hashtable 是数组 + 链表，hashmap 在 1.8 之后改为了数组 + 链表 + 红黑树</p>\n<p>第二，hashtable 存储数据的时候都不能为 null，而 hashmap 是可以的</p>\n<p>第三，hash 算法不同，hashtable 是用本地修饰的 hashcode 值，而 hashmap 经常了二次 hash</p>\n<p>第四，扩容方式不同，hashtable 是当前容量翻倍 + 1，hashmap 是当前容量翻倍</p>\n<p>第五，hashtable 是线程安全的，操作数据的时候加了锁 synchronized，hashmap 不是线程安全的，效率更高一些</p>\n<p>在实际开中不建议使用 HashTable，在多线程环境下可以使用 ConcurrentHashMap 类</p>\n</blockquote>\n",
            "tags": [
                "面经",
                "Java基础"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/interview/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "url": "http://zero-yuan.gitee.io/interview/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "title": "消息中间件相关面试题",
            "date_published": "2023-08-11T16:00:00.000Z",
            "content_html": "<h3 id=\"面试官rabbitmq-如何保证消息不丢失\"><a class=\"anchor\" href=\"#面试官rabbitmq-如何保证消息不丢失\">#</a> 面试官：RabbitMQ - 如何保证消息不丢失</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！我们当时 MYSQL 和 Redis 的数据双写一致性就是采用 RabbitMQ 实现同步的，这里面就要求了消息的高可用性，我们要保证消息的不丢失。主要从三个层面考虑</p>\n<p>第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据</p>\n<p>第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化</p>\n<p>第三个是开启消费者确认机制为 auto，由 spring 确认消息处理成功后完成 ack，当然也需要设置一定的重试次数，我们当时设置了 3 次，如果重试 3 次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理</p>\n</blockquote>\n<h3 id=\"面试官rabbitmq消息的重复消费问题如何解决的\"><a class=\"anchor\" href=\"#面试官rabbitmq消息的重复消费问题如何解决的\">#</a> 面试官：RabbitMQ 消息的重复消费问题如何解决的</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个我们还真遇到过，是这样的，我们当时消费者是设置了自动确认机制，当服务还没来得及给 MQ 确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了</p>\n<p>因为我们当时处理的支付（订单 | 业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</p>\n</blockquote>\n<h3 id=\"面试官那你还知道其他的解决方案吗\"><a class=\"anchor\" href=\"#面试官那你还知道其他的解决方案吗\">#</a> 面试官：那你还知道其他的解决方案吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，我想想～</p>\n<p>其实这个就是典型的幂等的问题，比如，redis 分布式锁、数据库的锁都是可以的</p>\n</blockquote>\n<h3 id=\"面试官rabbitmq中死信交换机-rabbitmq延迟队列有了解过嘛\"><a class=\"anchor\" href=\"#面试官rabbitmq中死信交换机-rabbitmq延迟队列有了解过嘛\">#</a> 面试官：RabbitMQ 中死信交换机？（RabbitMQ 延迟队列有了解过嘛）</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！了解过！</p>\n<p>我们当时的 xx 项目有一个 xx 业务，需要用到延迟队列，其中就是使用 RabbitMQ 来实现的。</p>\n<p>延迟队列就是用到了死信交换机和 TTL（消息存活时间）实现的。</p>\n<p>如果消息超时未消费就会变成死信，在 RabbitMQ 中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定 TTL 的时间，这样就实现了延迟队列的功能了。</p>\n<p>我记得 RabbitMQ 还有一种方式可以实现延迟队列，在 RabbitMQ 中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行了，相对于死信交换机 + TTL 要省略了一些步骤</p>\n</blockquote>\n<h3 id=\"面试官如果有100万消息堆积在mq-如何解决\"><a class=\"anchor\" href=\"#面试官如果有100万消息堆积在mq-如何解决\">#</a> 面试官：如果有 100 万消息堆积在 MQ , 如何解决？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>我在实际的开发中，没遇到过这种情况，不过，如果发生了堆积的问题，解决方案也所有很多的</p>\n<p>第一：提高消费者的消费能力，可以使用多线程消费任务</p>\n<p>第二：增加更多消费者，提高消费速度</p>\n<p>​\t\t\t 使用工作队列模式，设置多个消费者消费消费同一个队列中的消息</p>\n<p>第三：扩大队列容积，提高堆积上限</p>\n<p>可以使用 RabbitMQ 惰性队列，惰性队列的好处主要是</p>\n<p>①接收到消息后直接存入磁盘而非内存</p>\n<p>②消费者要消费消息时才会从磁盘中读取并加载到内存</p>\n<p>③支持数百万条的消息存储</p>\n</blockquote>\n<h3 id=\"面试官rabbitmq的高可用机制有了解过嘛\"><a class=\"anchor\" href=\"#面试官rabbitmq的高可用机制有了解过嘛\">#</a> 面试官：RabbitMQ 的高可用机制有了解过嘛</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，熟悉的～</p>\n<p>我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了 3 台机器。</p>\n<p>镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失</p>\n</blockquote>\n<h3 id=\"面试官那出现丢数据怎么解决呢\"><a class=\"anchor\" href=\"#面试官那出现丢数据怎么解决呢\">#</a> 面试官：那出现丢数据怎么解决呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于 Raft 协议，强一致。</p>\n<p>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p>\n</blockquote>\n<h3 id=\"面试官kafka是如何保证消息不丢失\"><a class=\"anchor\" href=\"#面试官kafka是如何保证消息不丢失\">#</a> 面试官：Kafka 是如何保证消息不丢失</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个保证机制很多，在发送消息到消费者接收消息，在每个阶段都有可能会丢失消息，所以我们解决的话也是从多个方面考虑</p>\n<p>第一个是生产者发送消息的时候，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获取失败后的消息信息，可以考虑重试或记录日志，后边再做补偿都是可以的。同时在生产者这边还可以设置消息重试，有的时候是由于网络抖动的原因导致发送不成功，就可以使用重试机制来解决</p>\n<p>第二个在 broker 中消息有可能会丢失，我们可以通过 kafka 的复制机制来确保消息不丢失，在生产者发送消息的时候，可以设置一个 acks，就是确认机制。我们可以设置参数为 all，这样的话，当生产者发送消息到了分区之后，不仅仅只在 leader 分区保存确认，在 follwer 分区也会保存确认，只有当所有的副本都保存确认以后才算是成功发送了消息，所以，这样设置就很大程度了保证了消息不会在 broker 丢失</p>\n<p>第三个有可能是在消费者端丢失消息，kafka 消费消息都是按照 offset 进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔 5s 提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给 broker 消费的位置，这样就可以避免消息丢失和重复消费了</p>\n</blockquote>\n<h3 id=\"面试官kafka中消息的重复消费问题如何解决的\"><a class=\"anchor\" href=\"#面试官kafka中消息的重复消费问题如何解决的\">#</a> 面试官：Kafka 中消息的重复消费问题如何解决的</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>kafka 消费消息都是按照 offset 进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔 5s 提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给 broker 消费的位置，这样就可以避免消息丢失和重复消费了</p>\n<p>为了消息的幂等，我们也可以设置唯一主键来进行区分，或者是加锁，数据库的锁，或者是 redis 分布式锁，都能解决幂等的问题</p>\n</blockquote>\n<h3 id=\"面试官kafka是如何保证消费的顺序性\"><a class=\"anchor\" href=\"#面试官kafka是如何保证消费的顺序性\">#</a> 面试官：Kafka 是如何保证消费的顺序性</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>kafka 默认存储和消费消息，是不能保证顺序性的，因为一个 topic 数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>\n<p>如果有这样的需求的话，我们是可以解决的，把消息都存储同一个分区下就行了，有两种方式都可以进行设置，第一个是发送消息时指定分区号，第二个是发送消息时按照相同的业务设置相同的 key，因为默认情况下分区也是通过 key 的 hashcode 值来选择分区的，hash 值如果一样的话，分区肯定也是一样的</p>\n</blockquote>\n<h3 id=\"面试官kafka的高可用机制有了解过嘛\"><a class=\"anchor\" href=\"#面试官kafka的高可用机制有了解过嘛\">#</a> 面试官：Kafka 的高可用机制有了解过嘛</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，主要是有两个层面，第一个是集群，第二个是提供了复制机制</p>\n<p>kafka 集群指的是由多个 broker 实例组成，即使某一台宕机，也不耽误其他 broker 继续对外提供服务</p>\n<p>复制机制是可以保证 kafka 的高可用的，一个 topic 有多个分区，每个分区有多个副本，有一个 leader，其余的是 follower，副本存储在不同的 broker 中；所有的分区副本的内容是都是相同的，如果 leader 发生故障时，会自动将其中一个 follower 提升为 leader，保证了系统的容错性、高可用性</p>\n</blockquote>\n<h3 id=\"面试官解释一下复制机制中的isr\"><a class=\"anchor\" href=\"#面试官解释一下复制机制中的isr\">#</a> 面试官：解释一下复制机制中的 ISR</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>ISR 的意思是 in-sync replica，就是需要同步复制保存的 follower</p>\n<p>其中分区副本有很多的 follower，分为了两类，一个是 ISR，与 leader 副本同步保存数据，另外一个普通的副本，是异步同步数据，当 leader 挂掉之后，会优先从 ISR 副本列表中选取一个作为 leader，因为 ISR 是同步保存数据，数据更加的完整一些，所以优先选择 ISR 副本列表</p>\n</blockquote>\n<h3 id=\"面试官kafka数据清理机制了解过嘛\"><a class=\"anchor\" href=\"#面试官kafka数据清理机制了解过嘛\">#</a> 面试官：Kafka 数据清理机制了解过嘛</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，了解过～～</p>\n<p>Kafka 中 topic 的数据存储在分区上，分区如果文件过大会分段存储 segment</p>\n<p>每个分段都在磁盘上以索引 (xxxx.index) 和日志文件 (xxxx.log) 的形式存储，这样分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便 kafka 进行日志清理。</p>\n<p>在 kafka 中提供了两个日志的清理策略：</p>\n<p>第一，根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是 168 小时（ 7 天）</p>\n<p>第二是根据 topic 存储的数据大小，当 topic 所占的日志文件大小大于一定的阈值，则开始删除最久的消息。这个默认是关闭的</p>\n<p>这两个策略都可以通过 kafka 的 broker 中的配置文件进行设置</p>\n</blockquote>\n<h3 id=\"面试官kafka中实现高性能的设计有了解过嘛\"><a class=\"anchor\" href=\"#面试官kafka中实现高性能的设计有了解过嘛\">#</a> 面试官：Kafka 中实现高性能的设计有了解过嘛</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>Kafka 高性能，是多方面协同的结果，包括宏观架构、分布式存储、ISR 数据同步、以及高效的利用磁盘、操作系统特性等。主要体现有这么几点：</p>\n<p>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</p>\n<p>顺序读写：磁盘顺序读写，提升读写效率</p>\n<p>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</p>\n<p>零拷贝：减少上下文切换及数据拷贝</p>\n<p>消息压缩：减少磁盘 IO 和网络 IO</p>\n<p>分批发送：将消息打包批量发送，减少网络开销</p>\n</blockquote>\n",
            "tags": [
                "面经",
                "微服务"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "url": "http://zero-yuan.gitee.io/interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "title": "微服务相关面试题",
            "date_published": "2023-08-10T16:00:00.000Z",
            "content_html": "<h3 id=\"面试官spring-cloud-5大组件有哪些\"><a class=\"anchor\" href=\"#面试官spring-cloud-5大组件有哪些\">#</a> 面试官：Spring Cloud 5 大组件有哪些？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>早期我们一般认为的 Spring Cloud 五大组件是</p>\n<ul>\n<li>Eureka   : 注册中心</li>\n<li>Ribbon  : 负载均衡</li>\n<li>Feign     : 远程调用</li>\n<li>Hystrix :  服务熔断</li>\n<li>Zuul/Gateway  : 网关</li>\n</ul>\n<p>随着 SpringCloudAlibba 在国内兴起，我们项目中使用了一些阿里巴巴的组件</p>\n<ul>\n<li>\n<p>注册中心 / 配置中心 Nacos</p>\n</li>\n<li>\n<p>负载均衡 Ribbon</p>\n</li>\n<li>\n<p>服务调用 Feign</p>\n</li>\n<li>\n<p>服务保护 sentinel</p>\n</li>\n<li>\n<p>服务网关 Gateway</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"面试官服务注册和发现是什么意思spring-cloud-如何实现服务注册发现\"><a class=\"anchor\" href=\"#面试官服务注册和发现是什么意思spring-cloud-如何实现服务注册发现\">#</a> 面试官：服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我理解的是主要三块大功能，分别是服务注册 、服务发现、服务状态监控</p>\n<p>我们当时项目采用的 eureka 作为注册中心，这个也是 spring cloud 体系中的一个核心组件</p>\n<p><strong>服务注册</strong>：服务提供者需要把自己的信息注册到 eureka，由 eureka 来保存这些信息，比如服务名称、ip、端口等等</p>\n<p><strong>服务发现</strong>：消费者向 eureka 拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</p>\n<p><strong>服务监控</strong>：服务提供者会每隔 30 秒向 eureka 发送心跳，报告健康状态，如果 eureka 服务 90 秒没接收到心跳，从 eureka 中剔除</p>\n</blockquote>\n<h3 id=\"面试官我看你之前也用过nacos-你能说下nacos与eureka的区别\"><a class=\"anchor\" href=\"#面试官我看你之前也用过nacos-你能说下nacos与eureka的区别\">#</a> 面试官：我看你之前也用过 nacos、你能说下 nacos 与 eureka 的区别？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我们当时 xx 项目就是采用的 nacos 作为注册中心，选择 nacos 还要一个重要原因就是它支持配置中心，不过 nacos 作为注册中心，也比 eureka 要方便好用一些，主要相同不同点在于几点：</p>\n<ul>\n<li>共同点</li>\n</ul>\n<p>Nacos 与 eureka 都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测</p>\n<ul>\n<li>Nacos 与 Eureka 的区别</li>\n</ul>\n<p>①Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</p>\n<p>②临时实例心跳不正常会被剔除，非临时实例则不会被剔除</p>\n<p>③Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</p>\n<p>④Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式</p>\n</blockquote>\n<h3 id=\"面试官你们项目负载均衡如何实现的\"><a class=\"anchor\" href=\"#面试官你们项目负载均衡如何实现的\">#</a> 面试官：你们项目负载均衡如何实现的？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>是这样～～</p>\n<p>在服务调用过程中的负载均衡一般使用 SpringCloud 的 Ribbon 组件实现，Feign 的底层已经自动集成了 Ribbon  , 使用起来非常简单</p>\n<p>当发起远程调用时，ribbon 先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，一般的调用策略是轮询</p>\n</blockquote>\n<h3 id=\"面试官ribbon负载均衡策略有哪些\"><a class=\"anchor\" href=\"#面试官ribbon负载均衡策略有哪些\">#</a> 面试官：Ribbon 负载均衡策略有哪些？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我想想啊，有很多种，我记得几个：</p>\n<ul>\n<li>\n<p>RoundRobinRule：简单轮询服务列表来选择服务器</p>\n</li>\n<li>\n<p>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</p>\n</li>\n<li>\n<p>RandomRule：随机选择一个可用的服务器</p>\n</li>\n<li>\n<p>ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询 (默认)</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"面试官如果想自定义负载均衡策略如何实现\"><a class=\"anchor\" href=\"#面试官如果想自定义负载均衡策略如何实现\">#</a> 面试官：如果想自定义负载均衡策略如何实现？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>提供了两种方式：</p>\n<p>1，创建类实现 IRule 接口，可以指定负载均衡策略，这个是全局的，对所有的远程调用都起作用</p>\n<p>2，在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略，只是对配置的这个服务生效远程调用</p>\n</blockquote>\n<h3 id=\"面试官什么是服务雪崩怎么解决这个问题\"><a class=\"anchor\" href=\"#面试官什么是服务雪崩怎么解决这个问题\">#</a> 面试官：什么是服务雪崩，怎么解决这个问题？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>服务雪崩是指一个服务失败，导致整条链路的服务都失败的情形，一般我们在项目解决的话就是两种方案，第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流</p>\n<p>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与 feign 接口整合，编写降级逻辑</p>\n<p>服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>\n</blockquote>\n<h3 id=\"面试官你们的微服务是怎么监控的\"><a class=\"anchor\" href=\"#面试官你们的微服务是怎么监控的\">#</a> 面试官：你们的微服务是怎么监控的？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我们项目中采用的 skywalking 进行监控的</p>\n<p>1，skywalking 主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</p>\n<p>2，我们还在 skywalking 设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的 bug 情况，第一时间修复</p>\n</blockquote>\n<h3 id=\"面试官你们项目中有没有做过限流-怎么做的\"><a class=\"anchor\" href=\"#面试官你们项目中有没有做过限流-怎么做的\">#</a> 面试官：你们项目中有没有做过限流？怎么做的？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我当时做的 xx 项目，采用就是微服务的架构，因为 xx 因为，应该会有突发流量，最大 QPS 可以达到 2000，但是服务支撑不住，我们项目都通过压测最多可以支撑 1200QPS。因为我们平时的 QPS 也就不到 100，为了解决这些突发流量，所以采用了限流。</p>\n<p>【版本 1】</p>\n<p>我们当时采用的 nginx 限流操作，nginx 使用的漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量，我们控制的速率是按照 ip 进行限流，限制的流量是每秒 20</p>\n<p>【版本 2】</p>\n<p>我们当时采用的是 spring cloud gateway 中支持局部过滤器 RequestRateLimiter 来做限流，使用的是令牌桶算法，可以根据 ip 或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</p>\n</blockquote>\n<h3 id=\"面试官限流常见的算法有哪些呢\"><a class=\"anchor\" href=\"#面试官限流常见的算法有哪些呢\">#</a> 面试官：限流常见的算法有哪些呢？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>比较常见的限流算法有漏桶算法和令牌桶算法</p>\n<p>漏桶算法是把请求存入到桶中，以固定速率从桶中流出，可以让我们的服务做到绝对的平均，起到很好的限流效果</p>\n<p>令牌桶算法在桶中存储的是令牌，按照一定的速率生成令牌，每个请求都要先申请令牌，申请到令牌以后才能正常请求，也可以起到很好的限流作用</p>\n<p>它们的区别是，漏桶和令牌桶都可以处理突发流量，其中漏桶可以做到绝对的平滑，令牌桶有可能会产生突发大量请求的情况，一般 nginx 限流采用的漏桶，spring cloud gateway 中可以支持令牌桶算法</p>\n</blockquote>\n<h3 id=\"面试官什么是cap理论\"><a class=\"anchor\" href=\"#面试官什么是cap理论\">#</a> 面试官：什么是 CAP 理论？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>CAP 主要是在分布式项目下的一个理论。包含了三项，一致性、可用性、分区容错性</p>\n<ul>\n<li>\n<p>一致性 (Consistency) 是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致 (强一致性)，不能存在中间状态。</p>\n</li>\n<li>\n<p>可用性 (Availability) 是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>\n</li>\n<li>\n<p>分区容错性 (Partition tolerance) 是指分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"面试官为什么分布式系统中无法同时保证一致性和可用性\"><a class=\"anchor\" href=\"#面试官为什么分布式系统中无法同时保证一致性和可用性\">#</a> 面试官：为什么分布式系统中无法同时保证一致性和可用性？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，是这样的～～</p>\n<p>首先一个前提，对于分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在设计分布式系统的时候只能从一致性（C）和可用性（A）之间进行取舍。</p>\n<p>如果保证了一致性（C）：对于节点 N1 和 N2，当往 N1 里写数据时，N2 上的操作必须被暂停，只有当 N1 同步数据到 N2 时才能对 N2 进行读写请求，在 N2 被暂停操作期间客户端提交的请求会收到失败或超时。显然，这与可用性是相悖的。</p>\n<p>如果保证了可用性（A）：那就不能暂停 N2 的读写操作，但同时 N1 在写数据的话，这就违背了一致性的要求。</p>\n</blockquote>\n<h3 id=\"面试官什么是base理论\"><a class=\"anchor\" href=\"#面试官什么是base理论\">#</a> 面试官：什么是 BASE 理论？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个也是 CAP 分布式系统设计理论</p>\n<p>BASE 是 CAP 理论中 AP 方案的延伸，核心思想是即使无法做到强一致性（StrongConsistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。它的思想包含三方面：</p>\n<p>1、Basically Available（基本可用）：基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。</p>\n<p>2、Soft state（软状态）：即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>\n<p>3、Eventually consistent（最终一致性）：强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>\n</blockquote>\n<h3 id=\"面试官你们采用哪种分布式事务解决方案\"><a class=\"anchor\" href=\"#面试官你们采用哪种分布式事务解决方案\">#</a> 面试官：你们采用哪种分布式事务解决方案？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我们当时是 xx 项目，主要使用到的 seata 的 at 模式解决的分布式事务</p>\n<p>seata 的 AT 模型分为两个阶段：</p>\n<p>1、阶段一 RM 的工作：① 注册分支事务  ② 记录 undo-log（数据快照）③ 执行业务 sql 并提交 ④报告事务状态</p>\n<p>2、阶段二提交时 RM 的工作：删除 undo-log 即可</p>\n<p>3、阶段二回滚时 RM 的工作：根据 undo-log 恢复数据到更新前</p>\n<p>at 模式牺牲了一致性，保证了可用性，不过，它保证的是最终一致性</p>\n</blockquote>\n<h3 id=\"面试官分布式服务的接口幂等性如何设计\"><a class=\"anchor\" href=\"#面试官分布式服务的接口幂等性如何设计\">#</a> 面试官：分布式服务的接口幂等性如何设计？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>嗯，我们当时有一个 xx 项目的下单操作，采用的 token+redis 实现的，流程是这样的</p>\n<p>第一次请求，也就是用户打开了商品详情页面，我们会发起一个请求，在后台生成一个唯一 token 存入 redis，key 就是用户的 id，value 就是这个 token，同时把这个 token 返回前端</p>\n<p>第二次请求，当用户点击了下单操作会后，会携带之前的 token，后台先到 redis 进行验证，如果存在 token，可以执行业务，同时删除 token；如果不存在，则直接返回，不处理业务，就保证了同一个 token 只处理一次业务，就保证了幂等性</p>\n</blockquote>\n<h3 id=\"面试官xxl-job路由策略有哪些\"><a class=\"anchor\" href=\"#面试官xxl-job路由策略有哪些\">#</a> 面试官：xxl-job 路由策略有哪些？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>xxl-job 提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</p>\n</blockquote>\n<h3 id=\"面试官xxl-job任务执行失败怎么解决\"><a class=\"anchor\" href=\"#面试官xxl-job任务执行失败怎么解决\">#</a> 面试官：xxl-job 任务执行失败怎么解决？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>有这么几个操作</p>\n<p>第一：路由策略选择故障转移，优先使用健康的实例来执行任务</p>\n<p>第二，如果还有失败的，我们在创建任务时，可以设置重试次数</p>\n<p>第三，如果还有失败的，就可以查看日志或者配置邮件告警来通知相关负责人解决</p>\n</blockquote>\n<h3 id=\"面试官如果有大数据量的任务同时都需要执行怎么解决\"><a class=\"anchor\" href=\"#面试官如果有大数据量的任务同时都需要执行怎么解决\">#</a> 面试官：如果有大数据量的任务同时都需要执行，怎么解决？</h3>\n<blockquote>\n<p><strong>候选人：</strong></p>\n<p>我们会让部署多个实例，共同去执行这些批量的任务，其中任务的路由策略是分片广播</p>\n<p>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行就可以了</p>\n</blockquote>\n",
            "tags": [
                "面经",
                "微服务"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "url": "http://zero-yuan.gitee.io/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "title": "Spring相关面试题",
            "date_published": "2023-08-09T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>本文引用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=\">黑马程序员 Java 面试宝典</span></p>\n</blockquote>\n<h3 id=\"面试官spring框架中的单例bean是线程安全的吗\"><a class=\"anchor\" href=\"#面试官spring框架中的单例bean是线程安全的吗\">#</a> 面试官：Spring 框架中的单例 bean 是线程安全的吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：<br />\n嗯！</p>\n<p>不是线程安全的，是这样的</p>\n<p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。</p>\n<p>Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。</p>\n<p>比如：我们通常在项目中使用的 Spring bean 都是不可可变的状态 (比如 Service 类和 DAO 类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。</p>\n<p>如果你的 bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用由 “<strong>singleton</strong>” 变更为 “<strong>prototype</strong>”。</p>\n</blockquote>\n<h3 id=\"面试官什么是aop\"><a class=\"anchor\" href=\"#面试官什么是aop\">#</a> 面试官：什么是 AOP</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>aop 是面向切面编程，在 spring 中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为公共日志保存，事务处理等</p>\n</blockquote>\n<h3 id=\"面试官你们项目中有没有使用到aop\"><a class=\"anchor\" href=\"#面试官你们项目中有没有使用到aop\">#</a> 面试官：你们项目中有没有使用到 AOP</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>我们当时在后台管理系统中，就是使用 aop 来记录了系统的操作日志</p>\n<p>主要思路是这样的，使用 aop 中的环绕通知 + 切点表达式，这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库</p>\n</blockquote>\n<h3 id=\"面试官spring中的事务是如何实现的\"><a class=\"anchor\" href=\"#面试官spring中的事务是如何实现的\">#</a> 面试官：Spring 中的事务是如何实现的</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>spring 实现的事务本质就是 aop 完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>\n</blockquote>\n<h3 id=\"面试官spring中事务失效的场景有哪些\"><a class=\"anchor\" href=\"#面试官spring中事务失效的场景有哪些\">#</a> 面试官：Spring 中事务失效的场景有哪些</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！这个在项目中之前遇到过，我想想啊</p>\n<p>第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了跑出去就行了</p>\n<p>第二个，如果方法抛出检查异常，如果报错也会导致事务失效，最后在 spring 事务的注解上，就是 @Transactional 上配置 rollbackFor 属性为 Exception，这样别管是什么异常，都会回滚事务</p>\n<p>第三，我之前还遇到过一个，如果方法上不是 public 修饰的，也会导致事务失效</p>\n<p>嗯，就能想起来那么多</p>\n</blockquote>\n<h3 id=\"面试官spring的bean的生命周期\"><a class=\"anchor\" href=\"#面试官spring的bean的生命周期\">#</a> 面试官：Spring 的 bean 的生命周期</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！，这个步骤还是挺多的，我之前看过一些源码，它大概流程是这样的</p>\n<p>首先会通过一个非常重要的类，叫做 BeanDefinition 获取 bean 的定义信息，这里面就封装了 bean 的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息</p>\n<p>在创建 bean 的时候，第一步是调用构造函数实例化 bean</p>\n<p>第二步是 bean 的依赖注入，比如一些 set 方法注入，像平时开发用的 @Autowire 都是这一步完成</p>\n<p>第三步是处理 Aware 接口，如果某一个 bean 实现了 Aware 接口就会重写方法执行</p>\n<p>第四步是 bean 的后置处理器 BeanPostProcessor，这个是前置处理器</p>\n<p>第五步是初始化方法，比如实现了接口 InitializingBean 或者自定义了方法 init-method 标签或 @PostContruct</p>\n<p>第六步是执行了 bean 的后置处理器 BeanPostProcessor，主要是对 bean 进行增强，有可能在这里产生代理对象</p>\n<p>最后一步是销毁 bean</p>\n</blockquote>\n<h3 id=\"面试官spring中的循环引用\"><a class=\"anchor\" href=\"#面试官spring中的循环引用\">#</a> 面试官：Spring 中的循环引用</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，好的，我来解释一下</p>\n<p>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的 bean 互相持有对方，最终形成闭环。比如 A 依赖于 B,B 依赖于 A</p>\n<p>循环依赖在 spring 中是允许存在，spring 框架依据三级缓存已经解决了大部分的循环依赖</p>\n<p>①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的 bean 对象</p>\n<p>②二级缓存：缓存早期的 bean 对象（生命周期还没走完）</p>\n<p>③三级缓存：缓存的是 ObjectFactory，表示对象工厂，用来创建某个对象的</p>\n</blockquote>\n<h3 id=\"面试官那具体解决流程清楚吗\"><a class=\"anchor\" href=\"#面试官那具体解决流程清楚吗\">#</a> 面试官：那具体解决流程清楚吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>第一，先实例 A 对象，同时会创建 ObjectFactory 对象存入三级缓存 singletonFactories</p>\n<p>第二，A 在初始化的时候需要 B 对象，这个走 B 的创建的逻辑</p>\n<p>第三，B 实例化完成，也会创建 ObjectFactory 对象存入三级缓存 singletonFactories</p>\n<p>第四，B 需要注入 A，通过三级缓存中获取 ObjectFactory 来生成一个 A 的对象同时存入二级缓存，这个是有两种情况，一个是可能是 A 的普通对象，另外一个是 A 的代理对象，都可以让 ObjectFactory 来生产对应的对象，这也是三级缓存的关键</p>\n<p>第五，B 通过从通过二级缓存 earlySingletonObjects  获得到 A 的对象后可以正常注入，B 创建成功，存入一级缓存 singletonObjects</p>\n<p>第六，回到 A 对象初始化，因为 B 对象已经创建完成，则可以直接注入 B，A 创建成功存入一次缓存 singletonObjects</p>\n<p>第七，二级缓存中的临时对象 A 清除</p>\n</blockquote>\n<h3 id=\"面试官构造方法出现了循环依赖怎么解决\"><a class=\"anchor\" href=\"#面试官构造方法出现了循环依赖怎么解决\">#</a> 面试官：构造方法出现了循环依赖怎么解决？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>由于 bean 的生命周期中构造函数是第一个执行的，spring 框架并不能解决构造函数的的依赖注入，可以使用 @Lazy 懒加载，什么时候需要对象再进行 bean 对象的创建</p>\n</blockquote>\n<h3 id=\"面试官springmvc的执行流程知道嘛\"><a class=\"anchor\" href=\"#面试官springmvc的执行流程知道嘛\">#</a> 面试官：SpringMVC 的执行流程知道嘛</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个知道的，它分了好多步骤</p>\n<p>1、用户发送出请求到前端控制器 DispatcherServlet，这是一个调度中心</p>\n<p>2、DispatcherServlet 收到请求调用 HandlerMapping（处理器映射器）。</p>\n<p>3、HandlerMapping 找到具体的处理器 (可查找 xml 配置或注解配置)，生成处理器对象及处理器拦截器 (如果有)，再一起返回给 DispatcherServlet。</p>\n<p>4、DispatcherServlet 调用 HandlerAdapter（处理器适配器）。</p>\n<p>5、HandlerAdapter 经过适配调用具体的处理器（Handler/Controller）。</p>\n<p>6、Controller 执行完成返回 ModelAndView 对象。</p>\n<p>7、HandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet。</p>\n<p>8、DispatcherServlet 将 ModelAndView 传给 ViewReslover（视图解析器）。</p>\n<p>9、ViewReslover 解析后返回具体 View（视图）。</p>\n<p>10、DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</p>\n<p>11、DispatcherServlet 响应用户。</p>\n<p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是 handler 中使用 Response 直接结果返回</p>\n</blockquote>\n<h3 id=\"面试官springboot自动配置原理\"><a class=\"anchor\" href=\"#面试官springboot自动配置原理\">#</a> 面试官：Springboot 自动配置原理</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，好的，它是这样的。</p>\n<p>在 Spring Boot 项目中的引导类上有一个注解 @SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p>\n<ul>\n<li>\n<p>@SpringBootConfiguration</p>\n</li>\n<li>\n<p>@EnableAutoConfiguration</p>\n</li>\n<li>\n<p>@ComponentScan</p>\n</li>\n</ul>\n<p>其中 <code>@EnableAutoConfiguration</code>  是实现自动化配置的核心注解。</p>\n<p>该注解通过 <code>@Import</code>  注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的 Jar 包的的 classpath 路径下<strong> META-INF/spring.factories</strong> 文件中的所配置的类的全类名。</p>\n<p>在这些配置类中所定义的 Bean 会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到 Spring 容器中。</p>\n<p>一般条件判断会有像 <code>@ConditionalOnClass</code>  这样的注解，判断是否有对应的 class 文件，如果有则加载该类，把这个配置类的所有的 Bean 放入 spring 容器中使用。</p>\n</blockquote>\n<h3 id=\"面试官spring-的常见注解有哪些\"><a class=\"anchor\" href=\"#面试官spring-的常见注解有哪些\">#</a> 面试官：Spring 的常见注解有哪些？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个就很多了</p>\n<p>第一类是：声明 bean，有 @Component、@Service、@Repository、@Controller</p>\n<p>第二类是：依赖注入相关的，有 @Autowired、@Qualifier、@Resourse</p>\n<p>第三类是：设置作用域 @Scope</p>\n<p>第四类是：spring 配置相关的，比如 @Configuration，@ComponentScan 和 @Bean</p>\n<p>第五类是：跟 aop 相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p>\n</blockquote>\n<h3 id=\"面试官springmvc常见的注解有哪些\"><a class=\"anchor\" href=\"#面试官springmvc常见的注解有哪些\">#</a> 面试官：SpringMVC 常见的注解有哪些？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个也很多的</p>\n<p>有 @RequestMapping：用于映射请求路径；</p>\n<p>@RequestBody：注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象；</p>\n<p>@RequestParam：指定请求参数的名称；</p>\n<p>@PathViriable：从请求路径下中获取请求参数 (/user/{id})，传递给方法的形式参数；@ResponseBody：注解实现将 controller 方法返回对象转化为 json 对象响应给客户端。@RequestHeader：获取指定的请求头数据，还有像 @PostMapping、@GetMapping 这些。</p>\n</blockquote>\n<h3 id=\"面试官springboot常见注解有哪些\"><a class=\"anchor\" href=\"#面试官springboot常见注解有哪些\">#</a> 面试官：Springboot 常见注解有哪些？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯～～</p>\n<p>Spring Boot 的核心注解是 @SpringBootApplication , 他由几个注解组成 :</p>\n<ul>\n<li>@SpringBootConfiguration： 组合了 - @Configuration 注解，实现配置文件的功能；</li>\n<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</li>\n<li>@ComponentScan：Spring 组件扫描</li>\n</ul>\n</blockquote>\n<h3 id=\"面试官mybatis执行流程\"><a class=\"anchor\" href=\"#面试官mybatis执行流程\">#</a> 面试官：MyBatis 执行流程</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>好，这个知道的，不过步骤也很多</p>\n<p>①读取 MyBatis 配置文件：mybatis-config.xml 加载运行环境和映射文件</p>\n<p>②构造会话工厂 SqlSessionFactory，一个项目只需要一个，单例的，一般由 spring 进行管理</p>\n<p>③会话工厂创建 SqlSession 对象，这里面就含了执行 SQL 语句的所有方法</p>\n<p>④操作数据库的接口，Executor 执行器，同时负责查询缓存的维护</p>\n<p>⑤Executor 接口的执行方法中有一个 MappedStatement 类型的参数，封装了映射信息</p>\n<p>⑥输入参数映射</p>\n<p>⑦输出结果映射</p>\n</blockquote>\n<h3 id=\"面试官mybatis是否支持延迟加载\"><a class=\"anchor\" href=\"#面试官mybatis是否支持延迟加载\">#</a> 面试官：Mybatis 是否支持延迟加载？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>是支持的～</p>\n<p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p>\n<p>Mybatis 支持一对一关联对象和一对多关联集合对象的延迟加载</p>\n<p>在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false，默认是关闭的</p>\n</blockquote>\n<h3 id=\"面试官延迟加载的底层原理知道吗\"><a class=\"anchor\" href=\"#面试官延迟加载的底层原理知道吗\">#</a> 面试官：延迟加载的底层原理知道吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，我想想啊</p>\n<p>延迟加载在底层主要使用的 CGLIB 动态代理完成的</p>\n<p>第一是，使用 CGLIB 创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的 mapper</p>\n<p>第二个是当调用目标方法时，进入拦截器 invoke 方法，发现目标方法是 null 值，再执行 sql 查询</p>\n<p>第三个是获取数据以后，调用 set 方法设置属性值，再继续查询目标方法，就有值了</p>\n</blockquote>\n<h3 id=\"面试官mybatis的一级-二级缓存用过吗\"><a class=\"anchor\" href=\"#面试官mybatis的一级-二级缓存用过吗\">#</a> 面试官：Mybatis 的一级、二级缓存用过吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯～～，用过的～</p>\n<p>mybatis 的一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session 进行 flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存</p>\n<p>关于二级缓存需要单独开启</p>\n<p>二级缓存是基于 namespace 和 mapper 的作用域起作用的，不是依赖于 SQL session，默认也是采用 PerpetualCache，HashMap 存储。</p>\n<p>如果想要开启二级缓存需要在全局配置文件和映射文件中开启配置才行。</p>\n</blockquote>\n<h3 id=\"面试官mybatis的二级缓存什么时候会清理缓存中的数据\"><a class=\"anchor\" href=\"#面试官mybatis的二级缓存什么时候会清理缓存中的数据\">#</a> 面试官：Mybatis 的二级缓存什么时候会清理缓存中的数据</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！！</p>\n<p>当某一个作用域 (一级缓存 Session / 二级缓存 Namespaces) 的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n</blockquote>\n",
            "tags": [
                "面经",
                "Spring"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/HTTP%E5%92%8CWebsocket%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/",
            "url": "http://zero-yuan.gitee.io/HTTP%E5%92%8CWebsocket%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/",
            "title": "HTTP和Websocket的前世今生",
            "date_published": "2023-08-08T16:00:00.000Z",
            "content_html": "<p><img data-src=\"https://raw.githubusercontent.com/lin0yuan/Image/master/f4e0159841ab450d861dde9e8fb5ba0d.gif\" alt=\"csdn\" /></p>\n<blockquote>\n<p>📝个人博客：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl82MTk1NzI4OT90eXBlPWJsb2c=\">零元</span></p>\n</blockquote>\n<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>相信大家都对 HTTP 协议比较熟悉，因为它是我们接触最多的一个协议。但 Websocket 跟它又有什么关系，有什么作用呢？这篇文章我们通过 HTTP 来引出 Webscoket 这个协议。</p>\n<h1 id=\"一-关于http\"><a class=\"anchor\" href=\"#一-关于http\">#</a> 一、关于 HTTP</h1>\n<h2 id=\"1-http请求\"><a class=\"anchor\" href=\"#1-http请求\">#</a> 1. HTTP 请求</h2>\n<ul>\n<li><strong>OSI 七层架构：</strong></li>\n</ul>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/7e6e42704eff475e963c5c77cefe75d1.png\" alt=\"此处有图片\" /><br />\n大家都知道，HTTP 协议是基于 TCP 协议开发的一款应用层协议，它主要针对的就是网站的一些请求</p>\n<ul>\n<li>\n<p><strong>请求图：</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/60a5da665ddf48be90383fa1192fabe1.png\" alt=\"此处有图片\" /><br />\n像这种可以算的上 HTTP 最简单的请求了，客户端向服务器请求数据，此时服务器响应数据，根据客户端请求的数据来返回对应的信息，可以进行一些基本的获取信息、请求数据一类的请求。</p>\n<p>当然根据 REST 规范，还有 POST 请求、PUT 请求、HEAD 请求，这里就不一一列举了，大家有兴趣可以自己查一下。</p>\n</li>\n</ul>\n<blockquote>\n<p>因为 HTTP 这种协议只能客户端发送请求，服务器不能主动发送请求。大家看到这或许会有疑惑，为什么还要要求服务器主动推送呢。</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>普通请求：</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/43956a553b454c838785fbfc24722037.png\" alt=\"此处有图片\" />普通请求结合 Ajax 代码示例：</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  $<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/to/hong\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">,</span> status</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>大家看这个图就知道了，此时小明想向小红炫耀一下自家的猫多么厉害 (或许这就是孩童的乐趣吧)，可是服务器并不能主动推送信息，小红永远也收不到，也就无法看到能后空翻的小猫了。</p>\n</li>\n</ul>\n<blockquote>\n<p>那么该如何解决这个问题呢？乐于助人的攻城狮想出了办法：可以让客户端频繁的去请求服务器不就行了，只要我请求的频率到一定程度，不就和服务器主动推送没区别了吗。</p>\n</blockquote>\n<h2 id=\"2-传统轮询\"><a class=\"anchor\" href=\"#2-传统轮询\">#</a> 2. 传统轮询</h2>\n<ul>\n<li>\n<p><strong>轮询方式:</strong></p>\n<p><img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/image-20230811104845648.png\" alt=\"image-20230811104845648\" /></p>\n<p>传统轮询请求结合 Ajax 代码示例：</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>      $<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/path/to/server\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">,</span> status</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>          console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>          <span class=\"token comment\">// 发起下一次请求</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>          <span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>因为 HTTP 请求是请求响应类型的，所以每次 HTTP 请求之后都会返回数据，即使没有信息，也会返回一个空值。这样对于聊天的话就会做很多无用的请求，让服务器遭受 “凌迟之痛”，并且消耗大量带宽。</p>\n</li>\n</ul>\n<blockquote>\n<p>小明也很苦恼，明明就发一个消息，为什么消耗这么多流量呢？刚充的花费就没了。乐于助人的攻城狮肯定不会眼睁睁的看着小明因为约会把自己的金钱全部掏空，于是就做了一个违背祖宗的决定。</p>\n</blockquote>\n<h2 id=\"3-长轮询\"><a class=\"anchor\" href=\"#3-长轮询\">#</a> 3. 长轮询</h2>\n<blockquote>\n<p>在上面的传统轮询中，巨量的请求都涌向服务器，占据大量网络资源。那么如何才能改进，避免大量资源的占用呢？</p>\n</blockquote>\n<p>长轮询意味着浏览器只需启动一个 HTTP 请求，其连接的服务器会 “hold” 住此次连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的 HTTP 请求，以此类推。</p>\n<ul>\n<li>\n<p><strong>轮询示例：</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/635cd2a0ea404a0695cf91ce5fc85e2c.png\" alt=\"此处有图片\" />跟上面的短轮询对比，从图片上就感觉到不是那么密密麻麻的了。网络也是如此，减少了大量不必要的请求。</p>\n<p><strong>轮询可能在以下 3 种情况时终止：</strong></p>\n<ul>\n<li>有新数据推送 。当服务器向浏览器推送信息后，应该主动结束程序运行从而让连接断开，这样浏览器才能及时收到数据。</li>\n<li>没有新数据推送 。应该设定一个最长时限，避免 WEB 服务器超时（Timeout），若一直没有新信息，服务器应主动向浏览器发送本次轮询无新信息的正常响应，并断开连接，这也被称为 “心跳” 信息。</li>\n<li>网络故障或异常 。由于网络故障等因素造成的请求超时或出错也可能导致轮询的意外中断，此时浏览器将收到错误信息。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这时候小明才长长叹拉口气，终于不会把自己的小金库花光了，还准备跟小红约会的时候用呢。</p>\n</blockquote>\n<ul>\n<li><strong>注意：长轮询和长连接是有区别的。长连接是基于 TCP 的，在协议上的修改，而长轮询是编程挂起手动修改的</strong></li>\n</ul>\n<h1 id=\"二-关于websocket\"><a class=\"anchor\" href=\"#二-关于websocket\">#</a> 二、关于 WebSocket</h1>\n<p>在上面你会发现，就算是 HTTP 的长轮询也是基于请求 - 应答的这种半双工通信模式，虽然可以双向的收发数据，但一个时刻只能一个方向有动作，传输效率低。最终要的一点就是，它是一种被动的通信模式，服务器只能被动的响应客户端请求，无法主动发送数据。</p>\n<blockquote>\n<p>做人不能总是主动，你越主动就越廉价。当然攻城狮也明白这个道理，为了让小明的爱情更加美好，就开始想办法做一个全双工的通信模型，不用像 HTTP 一样回合制类型那么客套了。于是，服务器就可以变得更加主动，一旦服务器有新的数据，就可以推送给小明，不需要再轮询了，通讯效率也变高了。</p>\n</blockquote>\n<h2 id=\"1websocket基础\"><a class=\"anchor\" href=\"#1websocket基础\">#</a> 1.WebSocket 基础</h2>\n<p>WebSocket 采用了二进制帧结构，语法、语义跟 HTTP 完全不兼容，但现在的龙头老大还是 HTTP，于是就尽量的往 HTTP 靠拢。</p>\n<p>服务发现方面，WebSocket 没有使用 TCP 的”IP 地址 + 端口号 &quot;，而是沿用了 HTTP 的 URL 格式，但开头协议名不是 http，而是 ws 和 wss，默认端口也选择了 80 和 443。</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token literal-property property\">ws</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>baidu<span class=\"token punctuation\">.</span>com<span class=\"token operator\">:</span><span class=\"token number\">8080</span><span class=\"token operator\">/</span>server</pre></td></tr></table></figure><p>这便是 websocket 的请求路径，唯一不同的就是协议名</p>\n<h2 id=\"2-websocket请求流程\"><a class=\"anchor\" href=\"#2-websocket请求流程\">#</a> 2. WebSocket 请求流程</h2>\n<blockquote>\n<p>作为一个新星协议，它是如何建立连接的呢</p>\n</blockquote>\n<ul>\n<li><strong>建立连接：</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/20210306165527435.png\" alt=\"\" />从上面这个图可以看出来，Websocket 竟然和 HTTP 有关系，最上面的是 HTTP1.1 版本，使用的 GET 请求，其中请求头一个字段很重要 Upgrade，看这个意思大家应该都知道，是升级的意思。这个请求就是使用 HTTP 请求向服务器传达一个信息，我要开始转换为 WebSocket 协议。</li>\n</ul>\n<p>如果用啦 HTTP 请求那肯定会有一个响应，因为 HTTP 就是请求应答模型的，当然这次也肯定不例外。</p>\n<ul>\n<li><strong>连接响应：</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/20210306170713531.png\" alt=\"\" /><br />\n上面这个就是服务端产生的应答，告诉客户端，已经转换成功，以后我们就可以用 Websocket 交流信息了 (HTTP：就没人管我的死活吗？T﹏T)</li>\n</ul>\n<p><strong>那么 websocket 是如何工作的呢？</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/5caa193a74d44eefa72cac2c9a930a79.png\" alt=\"此处有图片\" /><br />\n首先就是上面提到的建立连接，建立连接成功之后，就开始进行全双工通信，这时服务端和客户端就可以自由发送请求了。</p>\n<p><strong>websocket 聊天示例:</strong><br />\n<img data-src=\"https://anoxia-picgo.oss-cn-beijing.aliyuncs.com/758c808bfab64e8390fc882e4494c92d.png\" alt=\"此处有图片\" /></p>\n<blockquote>\n<p>小明：程序猿太厉害了吧，我以后也要成为一名程序猿</p>\n</blockquote>\n<h2 id=\"3-websocket总结\"><a class=\"anchor\" href=\"#3-websocket总结\">#</a> 3. Websocket 总结</h2>\n<p>WebSocket 是一种基于 TCP 协议的通信协议，它提供了全双工的实时通信能力，使服务器和客户端之间可以进行双向的、实时的数据传输。</p>\n<p><strong>以下是 WebSocket 的一些重要特点和用法：</strong></p>\n<ul>\n<li>\n<p>双向通信：WebSocket 允许服务器和客户端之间进行双向通信，无需依赖于客户端发起请求。服务器可以主动向客户端推送消息或数据，而不需要等待客户端发送请求。</p>\n</li>\n<li>\n<p>实时性：WebSocket 提供了低延迟的实时通信能力，适用于需要及时推送数据的场景，如即时聊天、实时消息更新等。</p>\n</li>\n<li>\n<p>长连接：与传统的 HTTP 请求 - 响应模式不同，WebSocket 在握手阶段建立连接后，连接会保持打开，双方可以长时间保持通信状态，避免了频繁建立和关闭连接的开销。</p>\n</li>\n<li>\n<p>二进制支持：WebSocket 不仅可以传输文本数据，还支持传输二进制数据，这使得它能够处理多媒体数据、文件传输等更复杂的场景。</p>\n</li>\n<li>\n<p>适用于 Web 应用和移动应用：WebSocket 可以被广泛应用于 Web 应用和移动应用中，为实时通信提供了强大的支持。</p>\n</li>\n</ul>\n<p>在使用 WebSocket 进行通信时，开发者可以借助相应的 WebSocket 客户端库或者浏览器提供的 WebSocket API 来实现与服务器的连接和数据传输。同时，服务器端也需要支持 WebSocket 协议来处理客户端的连接和消息。</p>\n<h1 id=\"三-总结\"><a class=\"anchor\" href=\"#三-总结\">#</a> 三、总结</h1>\n<p><strong>关于 HTTP 请求和 WebSocket 的对比：</strong></p>\n<ul>\n<li>\n<p>连接方式：HTTP 是一种无状态的请求 - 响应协议，每次请求都需要重新建立连接。而 WebSocket 则是一种全双工通信协议，通过一次握手后，客户端和服务器之间可以保持长时间的连接，实现双向通信。</p>\n</li>\n<li>\n<p>通信效率：由于 HTTP 协议的特性，每次请求 - 响应的过程会带来较大的开销。而 WebSocket 的长连接可以减少频繁的握手和头部信息传输，从而提高通信效率，特别适合实时性要求高的场景。</p>\n</li>\n<li>\n<p>数据格式：HTTP 使用文本形式的请求和响应，通常以 JSON 或 XML 格式进行数据传输。而 WebSocket 可以传输二进制数据，可以更高效地处理多媒体数据或其他复杂的格式。</p>\n</li>\n<li>\n<p>支持性：WebSocket 是一种相对较新的协议，不是所有的浏览器和服务器都完全支持它。而 HTTP 是通用的协议，几乎所有的浏览器和服务器都能良好支持。</p>\n</li>\n</ul>\n<p>综上所述，WebSocket 相对于 HTTP 具有更低的通信延迟、更高的效率和更强大的功能，特别适用于实时通信、推送和实时更新的场景。但在一些简单的请求 - 响应交互中，仍然可以使用 HTTP。选择使用哪种协议取决于具体的需求和场景。</p>\n<hr />\n<p><strong>小明后续：</strong><br />\n差点跑题了，咱们损耗好几个攻城狮为的就是小明，主要还是要关注小明和小红的进度。</p>\n<p>第二天：</p>\n<p>不争气的小明因为真的陪小红看了一晚上小猫后空翻把小红给气走了。</p>\n",
            "tags": [
                "计算机基础"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/",
            "url": "http://zero-yuan.gitee.io/redis/%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/",
            "title": "关于缓存读写一致问题",
            "date_published": "2023-08-07T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>📝个人博客：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl82MTk1NzI4OT90eXBlPWJsb2c=\">零元</span></p>\n</blockquote>\n<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>在项目使用 Redis 过程中，当数据更新时，我们要保证缓存和数据库的一致性，否则会导致很多脏数据出现。此时我们就要思考如何去进行数据更新。</p>\n<hr />\n<h2 id=\"一-普通删除\"><a class=\"anchor\" href=\"#一-普通删除\">#</a> 一、普通删除</h2>\n<p>在数据更新过程中，大家无非使用两种方法进行缓存和数据库的更新</p>\n<ul>\n<li>先删除缓存，再更新数据库</li>\n<li>先更新数据库，再更新缓存</li>\n</ul>\n<p>那这两种方法究竟有什么不同呢？</p>\n<h3 id=\"1-先删除缓存\"><a class=\"anchor\" href=\"#1-先删除缓存\">#</a> 1. 先删除缓存</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/08/08/pPVTSbR.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>\n<blockquote>\n<p>问题：此时缓存有了旧数据，在下次修改此数据之前，所有请求获取的都是旧数据，导致读写不一致</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-后删除缓存\"><a class=\"anchor\" href=\"#2-后删除缓存\">#</a> 2. 后删除缓存</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/08/08/pPVoxKJ.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>\n<blockquote>\n<p>问题 1：在小明修改数据库到删除缓存这段时间，所有请求都是旧数据</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>问题 2：如果缓存删除失败，后续所有请求都是旧数据 (这个问题开启事务的话，就可以解决)</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二-双删策略\"><a class=\"anchor\" href=\"#二-双删策略\">#</a> 二、双删策略</h2>\n<p>在普通删除策略中，大家会发现后删缓存策略是比较好的一种，但还是存在一点问题，所以提出了双删策略</p>\n<blockquote>\n<p>关于这个地方我是存在疑问的，因为我认为双删并不会比后删缓存策略更好，反而增加了一次数据库查询的操作。但有的博客却提了这个策略，我就在这里提一下，大家可以在评论进行交流</p>\n</blockquote>\n<h3 id=\"1-普通双删\"><a class=\"anchor\" href=\"#1-普通双删\">#</a> 1. 普通双删</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/08/08/pPVT9V1.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>\n<blockquote>\n<p>问题：因为线程调度一些问题导致查询后写入缓存停止，会导致旧缓存依旧存在</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-延迟双删\"><a class=\"anchor\" href=\"#2-延迟双删\">#</a> 2. 延迟双删</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/08/08/pPVTCUx.png\" alt=\"在这里插入图片描述\" /><br />\n这样的话看似把普通双删的问题给解决了，但并没有完全解决，反而引发新的问题。</p>\n<ul>\n<li>\n<blockquote>\n<p>问题：延时时长问题，时间太长导致性能下降，时间太短又会跟普通双删一样</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"三-读写锁\"><a class=\"anchor\" href=\"#三-读写锁\">#</a> 三、读写锁</h2>\n<p>读写锁根据字面意思就知道是加锁，因此效率肯定比不加锁效率低，但是可以完全避免旧数据读取的发生。</p>\n<ul>\n<li>读写锁是读读共享，读写和写写互斥的<br />\n<img data-src=\"https://s1.ax1x.com/2023/08/08/pPVozr9.png\" alt=\"在这里插入图片描述\" /></li>\n</ul>\n<h2 id=\"四-异步通知\"><a class=\"anchor\" href=\"#四-异步通知\">#</a> 四、异步通知</h2>\n<h3 id=\"1-消息中间件异步通知\"><a class=\"anchor\" href=\"#1-消息中间件异步通知\">#</a> 1. 消息中间件异步通知</h3>\n<p><img data-src=\"https://s1.ax1x.com/2023/08/08/pPVojv4.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n<li>对于这个博主认为是把延迟双删的延迟给优化了，不再占用本线程的时间，只不过部分请求会导致旧数据。</li>\n</ul>\n<h3 id=\"2canal\"><a class=\"anchor\" href=\"#2canal\">#</a> 2.Canal</h3>\n<blockquote>\n<p>关于 Canal，大家可以看这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2Fvd2VpeGlvbmcvcC8xMTgyNDQyMy5odG1s\">Canal 原理架构应用场景</span></p>\n</blockquote>\n<p>Canal 是一个开源的数据库数据增量订阅和消费组件，用于实时捕获数据库的变更并将其传递给其他系统。具体而言，Canal 主要用于解决数据库之间的数据同步和实时数据分析需求。<br />\nCanal 支持对 MySQL、Oracle 等主流数据库进行增量数据订阅和消费。它通过解析数据库的日志（如 MySQL 的 binlog 或 Oracle 的 redo log），实时捕获数据库的变更操作，然后将变更数据以事件的形式发送给订阅者。可以将这些变更数据用于数据同步、实时数据仓库、搜索引擎索引更新、缓存更新等应用场景。<br />\nCanal 的主要特性包括：</p>\n<ul>\n<li>. 数据库无侵入：Canal 通过解析数据库日志来捕获数据变更，不需要对数据库进行任何修改，不会对数据库的性能产生影响。</li>\n<li>实时的增量数据：Canal 能够几乎实时地捕获到数据库的变更操作，并以事件的形式进行传递，保证了数据的实时性。</li>\n<li>灵活的订阅和过滤：Canal 支持基于数据库、表、列级别的订阅和过滤，可以按需选择需要同步的数据，减少数据传输和处理的压力。</li>\n<li>多种协议支持：Canal 支持多种数据传输协议，如基于 TCP 的简单文本协议、Kafka、RocketMQ 等，可以根据具体需求选择适合的协议进行数据传输。</li>\n<li>高可用和容错：Canal 支持多节点部署，通过主备模式或者集群模式来保证高可用性和容错性。</li>\n</ul>\n<h2 id=\"五-总结\"><a class=\"anchor\" href=\"#五-总结\">#</a> 五。总结</h2>\n<p>总体来说这几种方式各有优缺点，不过现在主要用的就是普通删除中的后删缓存的方法，如果一致性要求比较高的话，可以用读写锁的方式，如果没有那么强的一致性要求，可以使用后删缓存或者异步通知的方式。</p>\n",
            "tags": [
                "Redis",
                "Redis"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/",
            "url": "http://zero-yuan.gitee.io/project/bug%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/",
            "title": "项目常见问题",
            "date_published": "2023-08-06T16:00:00.000Z",
            "content_html": "<h3 id=\"maven问题\"><a class=\"anchor\" href=\"#maven问题\">#</a> Maven 问题</h3>\n<h4 id=\"maven右侧出现root字样\"><a class=\"anchor\" href=\"#maven右侧出现root字样\">#</a> maven 右侧出现 root 字样</h4>\n<ul>\n<li>\n<p>问题原因：由于父工程未导入该子模块，所以 maven 认为该模块为根模块.</p>\n</li>\n<li>\n<p>解决方法:</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>modules</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>module</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>module</span><span class=\"token punctuation\">></span></span> <span class=\"token comment\">&lt;!-- 此处放置该子模块 --></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>modules</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"java问题\"><a class=\"anchor\" href=\"#java问题\">#</a> JAVA 问题</h3>\n<h4 id=\"使用排除注解所遇问题\"><a class=\"anchor\" href=\"#使用排除注解所遇问题\">#</a> 使用排除注解所遇问题</h4>\n<ul>\n<li>\n<p>问题代码:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>IllegalStateException</span><span class=\"token operator\">:</span> <span class=\"token class-name\">The</span> following classes could not be excluded because they are not auto<span class=\"token operator\">-</span>configuration classes<span class=\"token operator\">:</span></pre></td></tr></table></figure><figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>xxxxxxxxxx6 <span class=\"token number\">1</span>private <span class=\"token class-name\">LocalDateTime</span> createTime<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token number\">2</span>​<span class=\"token number\">3</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setCreateTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> createTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token number\">4</span> <span class=\"token class-name\">LocalDateTime</span> localDateTime <span class=\"token operator\">=</span> createTime<span class=\"token punctuation\">.</span><span class=\"token function\">toInstant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">atZone</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ZoneId</span><span class=\"token punctuation\">.</span><span class=\"token function\">systemDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLocalDateTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token number\">5</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createTime <span class=\"token operator\">=</span> localDateTime<span class=\"token punctuation\">;</span><span class=\"token number\">6</span>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span>java</pre></td></tr></table></figure></li>\n<li>\n<p>解决办法:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span><span class=\"token punctuation\">(</span>exclude <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token class-name\">DataSourceAutoConfiguration</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>查看一下类是否写错了，修改即可.</p>\n</li>\n</ul>\n<h4 id=\"mapperscan无法注入\"><a class=\"anchor\" href=\"#mapperscan无法注入\">#</a> mapperscan 无法注入</h4>\n<ul>\n<li>\n<p>问题描述：在代码界面，红色警告（启动程序并无异常）。</p>\n</li>\n<li>\n<p>问题原因：mapper 类是使用的 mybatis 生成的，spring 无法检测出，但运行没有问题。</p>\n</li>\n<li>\n<p>解决办法：</p>\n<ol>\n<li>\n<p>禁止红色警告（不建议，因为别的地方如果自动装配出问题无法及时发现）</p>\n</li>\n<li>\n<p>在 mapper 类加入 @Mapper 注解（mybatis 自带注解，没导入 mybatis 的话，要在启动类加入 @mapperscan）</p>\n</li>\n<li>\n<p>在 mapper 类加入 @Repository 注解跟 mapperscan 结合（spring 自带注解）</p>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"nacos异常\"><a class=\"anchor\" href=\"#nacos异常\">#</a> nacos 异常</h4>\n<ul>\n<li>\n<p>问题代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Failed</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">start</span> bean 'nacosWatch'<span class=\"token punctuation\">;</span> nested exception is <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>RuntimeException</span><span class=\"token operator\">:</span> <span class=\"token class-name\">ErrCode</span><span class=\"token operator\">:</span><span class=\"token operator\">-</span><span class=\"token number\">400</span></pre></td></tr></table></figure></li>\n<li>\n<p>问题原因：pom 文件导入的 nacos 版本和 springboot 版本不兼容。</p>\n</li>\n<li>\n<p>解决办法：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNzM1Mzky\">点击查看对应版本</span>，重新导入即可对应版本。</p>\n</li>\n</ul>\n",
            "tags": [
                "项目总结",
                "Mysql",
                "bug"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/project/Mysql%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/",
            "url": "http://zero-yuan.gitee.io/project/Mysql%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/",
            "title": "连接数据库遇到问题",
            "date_published": "2023-08-06T16:00:00.000Z",
            "content_html": "<h3 id=\"1-时区转换问题\"><a class=\"anchor\" href=\"#1-时区转换问题\">#</a> 1. 时区转换问题</h3>\n<blockquote>\n<p>相信大多数人都遇见过数据库时间提取到 Java 对象之后，发生时间不一致的问题</p>\n</blockquote>\n<p>连接数据库的时候若不设置，就会引发时区转换的问题，其原因是因为:<br />\n<mark> 咱们所在时区为东八区，而默认时区为 0 区，差距八个小时，所以每次在与数据库交互时就会发生八小时的误差，</mark><br />\n 若要解决此问题，就要在连接数据库时设置配置:</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>jdbc<span class=\"token punctuation\">:</span>mysql<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span>3306/friend<span class=\"token punctuation\">?</span>useSSL=false<span class=\"token important\">&amp;serverTimezone=Asia/Shanghai</span></pre></td></tr></table></figure><p>&amp; 后面便是设置的时区，设置之后在与 mysql 交互的时候就不会发生时区的问题了。</p>\n<h3 id=\"2数据库字段创建时间和修改时间\"><a class=\"anchor\" href=\"#2数据库字段创建时间和修改时间\">#</a> 2. 数据库字段创建时间和修改时间</h3>\n<blockquote>\n<p>很多的数据库表都需要有创建时间和修改时间，此时就会引发许多问题</p>\n</blockquote>\n<p>如果是在 Java 类中自己设置时间过于麻烦，此时便可以在数据库建表的时候设置</p>\n<pre><code class=\"language-mysql\"> create_time   timestamp default CURRENT_TIMESTAMP not null comment '创建时间',\n update_time   timestamp default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '修改时间',\n</code></pre>\n<p>创建表的时候进行以上的设置便能在插入字段和修改字段的时候，数据库自动修改时间</p>\n<h3 id=\"3数据库时间转换问题\"><a class=\"anchor\" href=\"#3数据库时间转换问题\">#</a> 3. 数据库时间转换问题</h3>\n<blockquote>\n<p>数据库的 timestamp 时间为时间戳，如果转换到 Java 里面就会遇见一些问题</p>\n</blockquote>\n<p>若是 Java 字段直接用 date 数据接收的话也可以，但是和前端交互的时候就会有格式问题，date 的格式直接发送给前端的话，用户看的话不是特别方便，如果每次发送给前端都要转换就显得有些麻烦<br />\n此时可以在 pojo 类中设置为 localdatetime 类型，修改一下 set 代码，便可成功接收.</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">LocalDateTime</span> createTime<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setCreateTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> createTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">LocalDateTime</span> localDateTime <span class=\"token operator\">=</span> createTime<span class=\"token punctuation\">.</span><span class=\"token function\">toInstant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">atZone</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ZoneId</span><span class=\"token punctuation\">.</span><span class=\"token function\">systemDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLocalDateTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createTime <span class=\"token operator\">=</span> localDateTime<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "项目总结",
                "Mysql",
                "bug"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "url": "http://zero-yuan.gitee.io/interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "title": "Mysql相关面试题",
            "date_published": "2023-08-05T16:00:00.000Z",
            "content_html": "<h3 id=\"面试官mysql中如何定位慢查询\"><a class=\"anchor\" href=\"#面试官mysql中如何定位慢查询\">#</a> 面试官：MySQL 中，如何定位慢查询？</h3>\n<blockquote>\n<p><strong>候选人</strong></p>\n<p>嗯～，我们当时做压测的时候有的接口非常的慢，接口的响应时间超过了 2 秒以上，因为我们当时的系统部署了运维的监控系统 Skywalking ，在展示的报表中可以看到是哪一个接口比较慢，并且可以分析这个接口哪部分比较慢，这里可以看到 SQL 的具体的执行时间，所以可以定位是哪个 sql 出了问题</p>\n<p>如果，项目中没有这种运维的监控系统，其实在 MySQL 中也提供了慢日志查询的功能，可以在 MySQL 的系统配置文件中开启这个慢日志的功能，并且也可以设置 SQL 执行超过多少时间来记录到一个日志文件中，我记得上一个项目配置的是 2 秒，只要 SQL 执行的时间超过了 2 秒就会记录到日志文件中，我们就可以在日志文件找到执行比较慢的 SQL 了。</p>\n</blockquote>\n<h3 id=\"面试官那这个sql语句执行很慢-如何分析呢\"><a class=\"anchor\" href=\"#面试官那这个sql语句执行很慢-如何分析呢\">#</a> 面试官：那这个 SQL 语句执行很慢，如何分析呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：如果一条 sql 执行很慢的话，我们通常会使用 mysql 自动的执行计划 explain 来去查看这条 sql 的执行情况，比如在这里面可以通过 key 和 key_len 检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，第二个，可以通过 type 字段查看 sql 是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过 extra 建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</p>\n</blockquote>\n<h3 id=\"面试官了解过索引吗什么是索引\"><a class=\"anchor\" href=\"#面试官了解过索引吗什么是索引\">#</a> 面试官：了解过索引吗？（什么是索引）</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，索引在项目中还是比较常见的，它是帮助 MySQL 高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的 IO 成本，同时通过索引列对数据进行排序，降低数据排序的成本，也能降低了 CPU 的消耗</p>\n</blockquote>\n<h3 id=\"面试官索引的底层数据结构了解过嘛\"><a class=\"anchor\" href=\"#面试官索引的底层数据结构了解过嘛\">#</a> 面试官：索引的底层数据结构了解过嘛？</h3>\n<blockquote>\n<p><strong>候选人</strong>：MySQL 的默认的存储引擎 InnoDB 采用的 B + 树的数据结构来存储索引，选择 B + 树的主要的原因是：第一阶数更多，路径更短，第二个磁盘读写代价 B + 树更低，非叶子节点只存储指针，叶子阶段存储数据，第三是 B + 树便于扫库和区间查询，叶子节点是一个双向链表</p>\n</blockquote>\n<h3 id=\"面试官b树和b树的区别是什么呢\"><a class=\"anchor\" href=\"#面试官b树和b树的区别是什么呢\">#</a> 面试官：B 树和 B + 树的区别是什么呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：第一：在 B 树中，非叶子节点和叶子节点都会存放数据，而 B + 树的所有的数据都会出现在叶子节点，在查询的时候，B + 树查找效率更加稳定</p>\n<p>第二：在进行范围查询的时候，B + 树效率更高，因为 B + 树都在叶子节点存储，并且叶子节点是一个双向链表</p>\n</blockquote>\n<h3 id=\"面试官什么是聚簇索引什么是非聚簇索引\"><a class=\"anchor\" href=\"#面试官什么是聚簇索引什么是非聚簇索引\">#</a> 面试官：什么是聚簇索引什么是非聚簇索引？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>好的～，聚簇索引主要是指数据与索引放到一块，B + 树的叶子节点保存了整行数据，有且只有一个，一般情况下主键在作为聚簇索引的</p>\n<p>非聚簇索引值的是数据与索引分开存储，B + 树的叶子节点保存对应的主键，可以有多个，一般我们自己定义的索引都是非聚簇索引</p>\n</blockquote>\n<h3 id=\"面试官知道什么是回表查询嘛\"><a class=\"anchor\" href=\"#面试官知道什么是回表查询嘛\">#</a> 面试官：知道什么是回表查询嘛？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，其实跟刚才介绍的聚簇索引和非聚簇索引是有关系的，回表的意思就是通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表</p>\n<p>【<strong>备注</strong>：如果面试官直接问回表，则需要先介绍聚簇索引和非聚簇索引】</p>\n</blockquote>\n<h3 id=\"面试官知道什么叫覆盖索引嘛\"><a class=\"anchor\" href=\"#面试官知道什么叫覆盖索引嘛\">#</a> 面试官：知道什么叫覆盖索引嘛？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯～，清楚的</p>\n<p>覆盖索引是指 select 查询语句使用了索引，在返回的列，必须在索引中全部能够找到，如果我们使用 id 查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p>\n<p>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用 select *，尽量在返回的列中都包含添加索引的字段</p>\n</blockquote>\n<h3 id=\"面试官mysql超大分页怎么处理\"><a class=\"anchor\" href=\"#面试官mysql超大分页怎么处理\">#</a> 面试官：MYSQL 超大分页怎么处理？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，超大分页一般都是在数据量比较大时，我们使用了 limit 分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决</p>\n<p>先分页查询数据的 id 字段，确定了 id 之后，再用子查询来过滤，只查询这个 id 列表中的数据就可以了</p>\n<p>因为查询 id 的时候，走的覆盖索引，所以效率可以提升很多</p>\n</blockquote>\n<h3 id=\"面试官索引创建原则有哪些\"><a class=\"anchor\" href=\"#面试官索引创建原则有哪些\">#</a> 面试官：索引创建原则有哪些？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，这个情况有很多，不过都有一个大前提，就是表中的数据要超过 10 万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。</p>\n<p>还有就是，我们通常创建索引的时候都是使用复合索引来创建，一条 sql 的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。</p>\n<p>如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。</p>\n</blockquote>\n<h3 id=\"面试官什么情况下索引会失效\"><a class=\"anchor\" href=\"#面试官什么情况下索引会失效\">#</a> 面试官：什么情况下索引会失效？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，这个情况比较多，我说一些自己的经验，以前遇到过的</p>\n<p>比如，索引在使用的时候没有遵循最左匹配法则，第二个是，模糊查询，如果 % 号在前面也会导致索引失效。如果在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。</p>\n<p>我们之前还遇到过一个就是，如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效</p>\n<p>所以，通常情况下，想要判断出这条 sql 是否有索引失效的情况，可以使用 explain 执行计划来分析</p>\n</blockquote>\n<h3 id=\"面试官sql的优化的经验\"><a class=\"anchor\" href=\"#面试官sql的优化的经验\">#</a> 面试官：sql 的优化的经验</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，这个在项目还是挺常见的，当然如果直说 sql 优化的话，我们会从这几方面考虑，比如</p>\n<p>建表的时候、使用索引、sql 语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表</p>\n</blockquote>\n<h3 id=\"面试官创建表的时候你们是如何优化的呢\"><a class=\"anchor\" href=\"#面试官创建表的时候你们是如何优化的呢\">#</a> 面试官：创建表的时候，你们是如何优化的呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像 tinyint、int 、bigint 这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择 char 和 varchar 或者 text 类型</p>\n</blockquote>\n<h3 id=\"面试官那在使用索引的时候是如何优化呢\"><a class=\"anchor\" href=\"#面试官那在使用索引的时候是如何优化呢\">#</a> 面试官：那在使用索引的时候，是如何优化呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：【参考索引创建原则    进行描述】</p>\n</blockquote>\n<h3 id=\"面试官你平时对sql语句做了哪些优化呢\"><a class=\"anchor\" href=\"#面试官你平时对sql语句做了哪些优化呢\">#</a> 面试官：你平时对 sql 语句做了哪些优化呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，这个也有很多，比如 SELECT 语句务必指明字段名称，不要直接使用 select * ，还有就是要注意 SQL 语句避免造成索引失效的写法；如果是聚合查询，尽量用 union all 代替 union ，union 会多一次过滤，效率比较低；如果是表关联的话，尽量使用 innerjoin ，不要使用用 left join right join，如必须使用 一定要以小表为驱动</p>\n</blockquote>\n<h3 id=\"面试官事务的特性是什么可以详细说一下吗\"><a class=\"anchor\" href=\"#面试官事务的特性是什么可以详细说一下吗\">#</a> 面试官：事务的特性是什么？可以详细说一下吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，这个比较清楚，ACID，分别指的是：原子性、一致性、隔离性、持久性；我举个例子：</p>\n<p>A 向 B 转账 500，转账成功，A 扣除 500 元，B 增加 500 元，原子操作体现在要么都成功，要么都失败</p>\n<p>在转账的过程中，数据要一致，A 扣除了 500，B 必须增加 500</p>\n<p>在转账的过程中，隔离性体现在 A 像 B 转账，不能受其他事务干扰</p>\n<p>在转账的过程中，持久性体现在事务提交后，要把数据持久化（可以说是落盘操作）</p>\n</blockquote>\n<h3 id=\"面试官并发事务带来哪些问题\"><a class=\"anchor\" href=\"#面试官并发事务带来哪些问题\">#</a> 面试官：并发事务带来哪些问题？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题</p>\n<p>第一是脏读， 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据”，依据 “脏数据” 所做的操作可能是不正确的。</p>\n<p>第二是不可重复读：比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n<p>第三是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n</blockquote>\n<h3 id=\"面试官怎么解决这些问题呢mysql的默认隔离级别是\"><a class=\"anchor\" href=\"#面试官怎么解决这些问题呢mysql的默认隔离级别是\">#</a> 面试官：怎么解决这些问题呢？MySQL 的默认隔离级别是？</h3>\n<blockquote>\n<p><strong>候选人</strong>：解决方案是对事务进行隔离</p>\n<p>MySQL 支持四种隔离级别，分别有：</p>\n<p>第一个是，未提交读（read uncommitted）它解决不了刚才提出的所有问题，一般项目中也不用这个。第二个是读已提交（read committed）它能解决脏读的问题的，但是解决不了不可重复读和幻读。第三个是可重复读（repeatable read）它能解决脏读和不可重复读，但是解决不了幻读，这个也是 mysql 默认的隔离级别。第四个是串行化（serializable）它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。所以，我们一般使用的都是 mysql 默认的隔离级别：可重复读</p>\n</blockquote>\n<h3 id=\"面试官undo-log和redo-log的区别\"><a class=\"anchor\" href=\"#面试官undo-log和redo-log的区别\">#</a> 面试官：undo log 和 redo log 的区别</h3>\n<blockquote>\n<p><strong>候选人</strong>：好的，其中 redo log 日志记录的是数据页的物理变化，服务宕机可用来同步数据，而 undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在 undo log 日志文件中新增一条 delete 语句，如果发生回滚就执行逆操作；</p>\n<p>redo log 保证了事务的持久性，undo log 保证了事务的原子性和一致性</p>\n</blockquote>\n<h3 id=\"面试官事务中的隔离性是如何保证的呢你解释一下mvcc\"><a class=\"anchor\" href=\"#面试官事务中的隔离性是如何保证的呢你解释一下mvcc\">#</a> 面试官：事务中的隔离性是如何保证的呢？(你解释一下 MVCC)</h3>\n<blockquote>\n<p><strong>候选人</strong>：事务的隔离性是由锁和 mvcc 实现的。</p>\n<p>其中 mvcc 的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是 undo log 日志，第三个是 readView 读视图</p>\n<p>隐藏字段是指：在 mysql 中给每个表都设置了隐藏字段，有一个是 trx_id (事务 id)，记录每一次操作的事务 id，是自增的；另一个字段是 roll_pointer (回滚指针)，指向上一个版本的事务版本记录地址</p>\n<p>undo log 主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过 roll_pointer 指针形成一个链表</p>\n<p>readView 解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务 id 判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是 rc 隔离级别，每一次执行快照读时生成 ReadView，如果是 rr 隔离级别仅在事务中第一次执行快照读时生成 ReadView，后续复用</p>\n</blockquote>\n<h3 id=\"面试官mysql主从同步原理\"><a class=\"anchor\" href=\"#面试官mysql主从同步原理\">#</a> 面试官：MySQL 主从同步原理</h3>\n<blockquote>\n<p><strong>候选人</strong>：MySQL 主从复制的核心就是二进制日志 (DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：</p>\n<p>第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p>\n<p>第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>\n<p>第三：从库重做中继日志中的事件，将改变反映它自己的数据</p>\n</blockquote>\n<h3 id=\"面试官你们项目用过mysql的分库分表吗\"><a class=\"anchor\" href=\"#面试官你们项目用过mysql的分库分表吗\">#</a> 面试官：你们项目用过 MySQL 的分库分表吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，因为我们都是微服务开发，每个微服务对应了一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。</p>\n</blockquote>\n<h3 id=\"面试官那你之前使用过水平分库吗\"><a class=\"anchor\" href=\"#面试官那你之前使用过水平分库吗\">#</a> 面试官：那你之前使用过水平分库吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个是使用过的，我们当时的业务是 (xxx)，一开始，我们也是单库，后来这个业务逐渐发展，业务量上来的很迅速，其中 (xx) 表已经存放了超过 1000 万的数据，我们做了很多优化也不好使，性能依然很慢，所以当时就使用了水平分库。</p>\n<p>我们一开始先做了 3 台服务器对应了 3 个数据库，由于库多了，需要分片，我们当时采用的 mycat 来作为数据库的中间件。数据都是按照 id（自增）取模的方式来存取的。</p>\n<p>当然一开始的时候，那些旧数据，我们做了一些清洗的工作，我们也是按照 id 取模规则分别存储到了各个数据库中，好处就是可以让各个数据库分摊存储和读取的压力，解决了我们当时性能的问题</p>\n</blockquote>\n<ul>\n<li>本文引自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=\">黑马程序员 Java 面试宝典</span></li>\n</ul>\n",
            "tags": [
                "面经",
                "Mysql"
            ]
        },
        {
            "id": "http://zero-yuan.gitee.io/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "url": "http://zero-yuan.gitee.io/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94/",
            "title": "Redis相关面试题",
            "date_published": "2023-08-05T16:00:00.000Z",
            "content_html": "<h3 id=\"面试官什么是缓存穿透-怎么解决\"><a class=\"anchor\" href=\"#面试官什么是缓存穿透-怎么解决\">#</a> 面试官：什么是缓存穿透？怎么解决？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯～～，我想一下</p>\n<p>缓存穿透是指查询一个一定<strong>不存在</strong>的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。</p>\n<p>解决方案的话，我们通常都会用布隆过滤器来解决它</p>\n</blockquote>\n<h3 id=\"面试官好的你能介绍一下布隆过滤器吗\"><a class=\"anchor\" href=\"#面试官好的你能介绍一下布隆过滤器吗\">#</a> 面试官：好的，你能介绍一下布隆过滤器吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，是这样～</p>\n<p>布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是 redisson 实现的布隆过滤器。</p>\n<p>它的底层主要是先去初始化一个比较大数组，里面存放的二进制 0 或 1。在一开始都是 0，当一个 key 来了之后经过 3 次 hash 计算，模于数组长度找到数据的下标然后把数组中原来的 0 改为 1，这样的话，三个数组的位置就能标明一个 key 的存在。查找的过程也是一样的。</p>\n<p>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过 5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5% 以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p>\n</blockquote>\n<h3 id=\"面试官什么是缓存击穿-怎么解决\"><a class=\"anchor\" href=\"#面试官什么是缓存击穿-怎么解决\">#</a> 面试官：什么是缓存击穿？怎么解决？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！！</p>\n<p>缓存击穿的意思是对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p>\n<p>解决方案有两种方式：</p>\n<p>第一可以使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的方法</p>\n<p>第二种方案可以设置当前 key 逻辑过期，大概是思路如下：</p>\n<p>①：在设置 key 的时候，设置一个过期时间字段一块存入缓存中，不给当前 key 设置过期时间</p>\n<p>②：当查询的时候，从 redis 取出数据后判断时间是否过期</p>\n<p>③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</p>\n<p>当然两种方案各有利弊：</p>\n<p>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</p>\n<p>如果选择 key 的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p>\n</blockquote>\n<h3 id=\"面试官什么是缓存雪崩-怎么解决\"><a class=\"anchor\" href=\"#面试官什么是缓存雪崩-怎么解决\">#</a> 面试官：什么是缓存雪崩？怎么解决？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯！！</p>\n<p>缓存雪崩意思是设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多 key，击穿是某一个 key 缓存。</p>\n<p>解决方案主要是可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>\n</blockquote>\n<h3 id=\"面试官redis做为缓存mysql的数据如何与redis进行同步呢双写一致性\"><a class=\"anchor\" href=\"#面试官redis做为缓存mysql的数据如何与redis进行同步呢双写一致性\">#</a> 面试官：redis 做为缓存，mysql 的数据如何与 redis 进行同步呢？（双写一致性）</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯！就说我最近做的这个项目，里面有 xxxx（<strong>根据自己的简历上写</strong>）的功能，需要让数据库与 redis 高度保持一致，因为要求时效性比较高，我们当时采用的读写锁保证的强一致性。</p>\n<p>我们采用的是 redisson 实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。</p>\n</blockquote>\n<h3 id=\"面试官那这个排他锁是如何保证读写-读读互斥的呢\"><a class=\"anchor\" href=\"#面试官那这个排他锁是如何保证读写-读读互斥的呢\">#</a> 面试官：那这个排他锁是如何保证读写、读读互斥的呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：其实排他锁底层使用也是 setnx，保证了同时只能有一个线程操作锁住的方法</p>\n</blockquote>\n<h3 id=\"面试官你听说过延时双删吗为什么不用它呢\"><a class=\"anchor\" href=\"#面试官你听说过延时双删吗为什么不用它呢\">#</a> 面试官：你听说过延时双删吗？为什么不用它呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。</p>\n</blockquote>\n<h3 id=\"面试官redis做为缓存数据的持久化是怎么做的\"><a class=\"anchor\" href=\"#面试官redis做为缓存数据的持久化是怎么做的\">#</a> 面试官：redis 做为缓存，数据的持久化是怎么做的？</h3>\n<blockquote>\n<p><strong>候选人</strong>：在 Redis 中提供了两种数据持久化的方式：1、RDB  2、AOF</p>\n</blockquote>\n<h3 id=\"面试官这两种持久化方式有什么区别呢\"><a class=\"anchor\" href=\"#面试官这两种持久化方式有什么区别呢\">#</a> 面试官：这两种持久化方式有什么区别呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：RDB 是一个快照文件，它是把 redis 内存存储的数据写到磁盘上，当 redis 实例宕机恢复数据的时候，方便从 RDB 的快照文件中恢复数据。</p>\n<p>AOF 的含义是追加文件，当 redis 操作写命令的时候，都会存储这个文件中，当 redis 实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据</p>\n</blockquote>\n<h3 id=\"面试官这两种方式哪种恢复的比较快呢\"><a class=\"anchor\" href=\"#面试官这两种方式哪种恢复的比较快呢\">#</a> 面试官：这两种方式，哪种恢复的比较快呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：RDB 因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用 AOF 来恢复数据，虽然 AOF 恢复的速度慢一些，但是它丢数据的风险要小很多，在 AOF 文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</p>\n</blockquote>\n<h3 id=\"面试官redis的数据过期策略有哪些\"><a class=\"anchor\" href=\"#面试官redis的数据过期策略有哪些\">#</a> 面试官：Redis 的数据过期策略有哪些？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯～，在 redis 中提供了两种数据过期删除策略</p>\n<p>第一种是惰性删除，在设置该 key 过期时间后，我们不去管它，当需要该 key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该 key。</p>\n<p>第二种是 定期删除，就是说每隔一段时间，我们就对一些 key 进行检查，删除里面过期的 key</p>\n<p>定期清理的两种模式：</p>\n<ul>\n<li>SLOW 模式是定时任务，执行频率默认为 10hz，每次不超过 25ms，以通过修改配置文件 redis.conf 的 <strong>hz</strong> 选项来调整这个次数</li>\n<li>FAST 模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于 2ms，每次耗时不超过 1ms</li>\n</ul>\n<p>Redis 的过期删除策略：<strong>惰性删除 + 定期删除</strong>两种策略进行配合使用。</p>\n</blockquote>\n<h3 id=\"面试官redis的数据淘汰策略有哪些\"><a class=\"anchor\" href=\"#面试官redis的数据淘汰策略有哪些\">#</a> 面试官：Redis 的数据淘汰策略有哪些？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个在 redis 中提供了很多种，默认是 noeviction，不删除任何数据，内部不足直接报错</p>\n<p>是可以在 redis 的配置文件中进行设置的，里面有两个非常重要的概念，一个是 LRU，另外一个是 LFU</p>\n<p>LRU 的意思就是最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p>\n<p>LFU 的意思是最少频率使用。会统计每个 key 的访问频率，值越小淘汰优先级越高</p>\n<p>我们在项目设置的 allkeys-lru，挑选最近最少使用的数据淘汰，把一些经常访问的 key 留在 redis 中</p>\n</blockquote>\n<h3 id=\"面试官数据库有1000万数据-redis只能缓存20w数据-如何保证redis中的数据都是热点数据\"><a class=\"anchor\" href=\"#面试官数据库有1000万数据-redis只能缓存20w数据-如何保证redis中的数据都是热点数据\">#</a> 面试官：数据库有 1000 万数据，Redis 只能缓存 20w 数据，如何保证 Redis 中的数据都是热点数据？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，我想一下～～</p>\n<p>可以使用 allkeys-lru （挑选最近最少使用的数据淘汰）淘汰策略，那留下来的都是经常访问的热点数据</p>\n</blockquote>\n<h3 id=\"面试官redis的内存用完了会发生什么\"><a class=\"anchor\" href=\"#面试官redis的内存用完了会发生什么\">#</a> 面试官：Redis 的内存用完了会发生什么？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯～，这个要看 redis 的数据淘汰策略是什么，如果是默认的配置，redis 内存用完以后则直接报错。我们当时设置的 allkeys-lru 策略。把最近最常访问的数据留在缓存中。</p>\n</blockquote>\n<h3 id=\"面试官redis分布式锁如何实现\"><a class=\"anchor\" href=\"#面试官redis分布式锁如何实现\">#</a> 面试官：Redis 分布式锁如何实现？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，在 redis 中提供了一个命令 setnx (SET if not exists)</p>\n<p>由于 redis 的单线程的，用了命令之后，只能有一个客户端对某一个 key 设置值，在没有过期或删除 key 的时候是其他客户端是不能设置这个 key 的</p>\n</blockquote>\n<h3 id=\"面试官好的那你如何控制redis实现分布式锁有效时长呢\"><a class=\"anchor\" href=\"#面试官好的那你如何控制redis实现分布式锁有效时长呢\">#</a> 面试官：好的，那你如何控制 Redis 实现分布式锁有效时长呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，的确，redis 的 setnx 指令不好控制这个问题，我们当时采用的 redis 的一个框架 redisson 实现的。</p>\n<p>在 redisson 中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在 redisson 中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了</p>\n<p>还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户 1 持有锁的时候，客户 2 来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户 1 释放之后，客户 2 就可以马上持有锁，性能也得到了提升。</p>\n</blockquote>\n<h3 id=\"面试官好的redisson实现的分布式锁是可重入的吗\"><a class=\"anchor\" href=\"#面试官好的redisson实现的分布式锁是可重入的吗\">#</a> 面试官：好的，redisson 实现的分布式锁是可重入的吗？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的 hash 结构，大 key 可以按照自己的业务进行定制，其中小 key 是当前线程的唯一标识，value 是当前线程重入的次数</p>\n</blockquote>\n<h3 id=\"面试官redisson实现的分布式锁能解决主从一致性的问题吗\"><a class=\"anchor\" href=\"#面试官redisson实现的分布式锁能解决主从一致性的问题吗\">#</a> 面试官：redisson 实现的分布式锁能解决主从一致性的问题吗</h3>\n<blockquote>\n<p><strong>候选人</strong>：这个是不能的，比如，当线程 1 加锁成功后，master 节点数据会异步复制到 slave 节点，此时当前持有 Redis 锁的 master 节点宕机，slave 节点被提升为新的 master 节点，假如现在来了一个线程 2，再次加锁，会在新的 master 节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。</p>\n<p>我们可以利用 redisson 提供的红锁来解决这个问题，它的主要作用是，不能只在一个 redis 实例上创建锁，应该是在多个 redis 实例上创建锁，并且要求在大多数 redis 节点上都成功创建锁，红锁中要求是 redis 的节点数量要过半。这样就能避免线程 1 加锁成功后 master 节点宕机导致线程 2 成功加锁到新的 master 节点上的问题了。</p>\n<p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁</p>\n</blockquote>\n<h3 id=\"面试官好的如果业务非要保证数据的强一致性这个该怎么解决呢\"><a class=\"anchor\" href=\"#面试官好的如果业务非要保证数据的强一致性这个该怎么解决呢\">#</a> 面试官：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？</h3>\n<blockquote>\n<p>** 候选人：** 嗯～，redis 本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用 zookeeper 实现的分布式锁，它是可以保证强一致性的。</p>\n</blockquote>\n<h3 id=\"面试官redis集群有哪些方案-知道嘛\"><a class=\"anchor\" href=\"#面试官redis集群有哪些方案-知道嘛\">#</a> 面试官：Redis 集群有哪些方案，知道嘛？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯～～，在 Redis 中提供的集群方案总共有三种：主从复制、哨兵模式、Redis 分片集群</p>\n</blockquote>\n<h3 id=\"面试官那你来介绍一下主从同步\"><a class=\"anchor\" href=\"#面试官那你来介绍一下主从同步\">#</a> 面试官：那你来介绍一下主从同步</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯，是这样的，单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中</p>\n</blockquote>\n<h3 id=\"面试官能说一下主从同步数据的流程\"><a class=\"anchor\" href=\"#面试官能说一下主从同步数据的流程\">#</a> 面试官：能说一下，主从同步数据的流程</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯～～，好！主从同步分为了两个阶段，一个是全量同步，一个是增量同步</p>\n<p>全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p>\n<p>第一：从节点请求主节点同步数据，其中从节点会携带自己的 replication id 和 offset 偏移量。</p>\n<p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个 replication id，如果不是，就说明是第一次同步，那主节点就会把自己的 replication id 和 offset 发送给从节点，让从节点与主节点的信息保持一致。</p>\n<p>第三：在同时主节点会执行 bgsave，生成 rdb 文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的 rdb 文件，这样就保持了一致</p>\n<p>当然，如果在 rdb 生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步</p>\n<p>增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的 offset 值，然后主节点从命令日志中获取 offset 值之后的数据，发送给从节点进行数据同步</p>\n</blockquote>\n<h3 id=\"面试官怎么保证redis的高并发高可用\"><a class=\"anchor\" href=\"#面试官怎么保证redis的高并发高可用\">#</a> 面试官：怎么保证 Redis 的高并发高可用</h3>\n<blockquote>\n<p><strong>候选人</strong>：首先可以搭建主从集群，再加上使用 redis 中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主；同时 Sentinel 也充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端，所以一般项目都会采用哨兵的模式来保证 redis 的高并发高可用</p>\n</blockquote>\n<h3 id=\"面试官你们使用redis是单点还是集群哪种集群\"><a class=\"anchor\" href=\"#面试官你们使用redis是单点还是集群哪种集群\">#</a> 面试官：你们使用 redis 是单点还是集群，哪种集群</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯！，我们当时使用的是主从（1 主 1 从）加哨兵。一般单节点不超过 10G 内存，如果 Redis 内存不足则可以给不同服务分配独立的 Redis 主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用 lua 脚本和事务</p>\n</blockquote>\n<h3 id=\"面试官redis集群脑裂该怎么解决呢\"><a class=\"anchor\" href=\"#面试官redis集群脑裂该怎么解决呢\">#</a> 面试官：redis 集群脑裂，该怎么解决呢？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯！ 这个在项目很少见，不过脑裂的问题是这样的，我们现在用的是 redis 的哨兵模式集群的</p>\n<p>有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于 redis master 节点和 redis salve 节点和 sentinel 处于不同的网络分区，使得 sentinel 没有能够心跳感知到 master，所以通过选举的方式提升了一个 salve 为 master，这样就存在了两个 master，就像大脑分裂了一样，这样会导致客户端还在 old master 那里写入数据，新节点无法同步数据，当网络恢复后，sentinel 会将 old master 降为 salve，这时再从新 master 同步数据，这会导致 old master 中的大量数据丢失。</p>\n<p>关于解决的话，我记得在 redis 的配置中可以设置：第一可以设置最少的 salve 节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>\n</blockquote>\n<h3 id=\"面试官redis的分片集群有什么作用\"><a class=\"anchor\" href=\"#面试官redis的分片集群有什么作用\">#</a> 面试官：redis 的分片集群有什么作用</h3>\n<blockquote>\n<p><strong>候选人</strong>：分片集群主要解决的是，海量数据存储的问题，集群中有多个 master，每个 master 保存不同数据，并且还可以给每个 master 设置多个 slave 节点，就可以继续增大集群的高并发能力。同时每个 master 之间通过 ping 监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>\n</blockquote>\n<h3 id=\"面试官redis分片集群中数据是怎么存储和读取的\"><a class=\"anchor\" href=\"#面试官redis分片集群中数据是怎么存储和读取的\">#</a> 面试官：Redis 分片集群中数据是怎么存储和读取的？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯～，在 redis 集群中是这样的</p>\n<p>Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。</p>\n<p>取值的逻辑是一样的</p>\n</blockquote>\n<h3 id=\"面试官redis是单线程的但是为什么还那么快\"><a class=\"anchor\" href=\"#面试官redis是单线程的但是为什么还那么快\">#</a> 面试官：Redis 是单线程的，但是为什么还那么快？</h3>\n<blockquote>\n<p><strong>候选人</strong>：</p>\n<p>嗯，这个有几个原因吧～～～</p>\n<p>1、完全基于内存的，C 语言编写</p>\n<p>2、采用单线程，避免不必要的上下文切换可竞争条件</p>\n<p>3、使用多路 I/O 复用模型，非阻塞 IO</p>\n<p>例如：bgsave 和 bgrewriteaof  都是在<strong>后台</strong>执行操作，不影响主线程的正常使用，不会产生阻塞</p>\n</blockquote>\n<h3 id=\"面试官能解释一下io多路复用模型\"><a class=\"anchor\" href=\"#面试官能解释一下io多路复用模型\">#</a> 面试官：能解释一下 I/O 多路复用模型？</h3>\n<blockquote>\n<p><strong>候选人</strong>：嗯～～，I/O 多路复用是指利用单个线程来同时监听多个 Socket ，并在某个 Socket 可读、可写时得到通知，从而避免无效的等待，充分利用 CPU 资源。目前的 I/O 多路复用都是采用的 epoll 模式实现，它会在通知用户进程 Socket 就绪的同时，把已就绪的 Socket 写入用户空间，不需要挨个遍历 Socket 来判断是否就绪，提升了性能。</p>\n<p>其中 Redis 的网络模型就是使用 I/O 多路复用结合事件的处理器来应对多个 Socket 请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；</p>\n<p>在 Redis6.0 之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>\n</blockquote>\n<ul>\n<li>本文引自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlUNDExSDdZSy8=\">黑马程序员 Java 面试宝典</span></li>\n</ul>\n",
            "tags": [
                "面经",
                "Redis"
            ]
        }
    ]
}